/******/ (() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ 8820: /***/ (module) => {
      "use strict";

      // base-x encoding / decoding
      // Copyright (c) 2018 base-x contributors
      // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
      // Distributed under the MIT software license, see the accompanying
      // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
      function base(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
        var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
        function encode(source) {
          if (source instanceof Uint8Array) {
          } else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(
              source.buffer,
              source.byteOffset,
              source.byteLength
            );
          } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
          }
          if (!(source instanceof Uint8Array)) {
            throw new TypeError("Expected Uint8Array");
          }
          if (source.length === 0) {
            return "";
          }
          // Skip & count leading zeroes.
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          // Allocate enough space in big-endian base58 representation.
          var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
          var b58 = new Uint8Array(size);
          // Process the bytes.
          while (pbegin !== pend) {
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for (
              var it1 = size - 1;
              (carry !== 0 || i < length) && it1 !== -1;
              it1--, i++
            ) {
              carry += (256 * b58[it1]) >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = (carry / BASE) >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i;
            pbegin++;
          }
          // Skip leading zeroes in base58 result.
          var it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          // Translate the result into a string.
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return new Uint8Array();
          }
          var psz = 0;
          // Skip leading spaces.
          if (source[psz] === " ") {
            return;
          }
          // Skip and count leading '1's.
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          // Allocate enough space in big-endian base256 representation.
          var size = ((source.length - psz) * FACTOR + 1) >>> 0; // log(58) / log(256), rounded up.
          var b256 = new Uint8Array(size);
          // Process the characters.
          while (source[psz]) {
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) {
              return;
            }
            var i = 0;
            for (
              var it3 = size - 1;
              (carry !== 0 || i < length) && it3 !== -1;
              it3--, i++
            ) {
              carry += (BASE * b256[it3]) >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = (carry / 256) >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i;
            psz++;
          }
          // Skip trailing spaces.
          if (source[psz] === " ") {
            return;
          }
          // Skip leading zeroes in b256.
          var it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = new Uint8Array(zeroes + (size - it4));
          var j = zeroes;
          while (it4 !== size) {
            vch[j++] = b256[it4++];
          }
          return vch;
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) {
            return buffer;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode,
          decodeUnsafe: decodeUnsafe,
          decode: decode,
        };
      }
      module.exports = base;

      /***/
    },

    /***/ 6365: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA2 = void 0;
      const utils_1 = __webpack_require__(8359);
      // Polyfill for Safari 14
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(0xffffffff);
        const wh = Number((value >> _32n) & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      // Base SHA2 class (RFC 6234)
      class SHA2 extends utils_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_1.createView)(this.buffer);
        }
        update(data) {
          if (this.destroyed) throw new Error("instance is destroyed");
          const { view, buffer, blockLen, finished } = this;
          if (finished) throw new Error("digest() was already called");
          data = (0, utils_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
              const dataView = (0, utils_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          if (this.destroyed) throw new Error("instance is destroyed");
          if (!(out instanceof Uint8Array) || out.length < this.outputLen)
            throw new Error("_Sha2: Invalid output buffer");
          if (this.finished) throw new Error("digest() was already called");
          this.finished = true;
          // Padding
          // We can avoid allocation of buffer for padding completely if it
          // was previously not allocated here. But it won't change performance.
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          // append the bit '1' to the message
          buffer[pos++] = 0b10000000;
          this.buffer.subarray(pos).fill(0);
          // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          // Pad until full block byte with zeros
          for (let i = pos; i < blockLen; i++) buffer[i] = 0;
          // NOTE: sha512 requires length to be 128bit integer, but length in JS will overflow before that
          // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
          // So we just write lowest 64bit of that value.
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_1.createView)(out);
          this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen) to.buffer.set(buffer);
          return to;
        }
      }
      exports.SHA2 = SHA2;

      /***/
    },

    /***/ 901: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = {
        node: undefined,
        web:
          typeof self === "object" && "crypto" in self
            ? self.crypto
            : undefined,
      };

      /***/
    },

    /***/ 7050: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ripemd160 = exports.RIPEMD160 = void 0;
      const _sha2_1 = __webpack_require__(6365);
      const utils_1 = __webpack_require__(8359);
      // https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
      // https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
      const Rho = new Uint8Array([
        7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
      ]);
      const Id = Uint8Array.from({ length: 16 }, (_, i) => i);
      const Pi = Id.map((i) => (9 * i + 5) % 16);
      let idxL = [Id];
      let idxR = [Pi];
      for (let i = 0; i < 4; i++)
        for (let j of [idxL, idxR]) j.push(j[i].map((k) => Rho[k]));
      const shifts = [
        [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
        [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
        [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
        [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
        [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
      ].map((i) => new Uint8Array(i));
      const shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
      const shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
      const Kl = new Uint32Array([
        0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
      ]);
      const Kr = new Uint32Array([
        0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
      ]);
      // The rotate left (circular left shift) operation for uint32
      const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
      // It's called f() in spec.
      function f(group, x, y, z) {
        if (group === 0) return x ^ y ^ z;
        else if (group === 1) return (x & y) | (~x & z);
        else if (group === 2) return (x | ~y) ^ z;
        else if (group === 3) return (x & z) | (y & ~z);
        else return x ^ (y | ~z);
      }
      // Temporary buffer, not used to store anything between runs
      const BUF = new Uint32Array(16);
      class RIPEMD160 extends _sha2_1.SHA2 {
        constructor() {
          super(64, 20, 8, true);
          this.h0 = 0x67452301 | 0;
          this.h1 = 0xefcdab89 | 0;
          this.h2 = 0x98badcfe | 0;
          this.h3 = 0x10325476 | 0;
          this.h4 = 0xc3d2e1f0 | 0;
        }
        get() {
          const { h0, h1, h2, h3, h4 } = this;
          return [h0, h1, h2, h3, h4];
        }
        set(h0, h1, h2, h3, h4) {
          this.h0 = h0 | 0;
          this.h1 = h1 | 0;
          this.h2 = h2 | 0;
          this.h3 = h3 | 0;
          this.h4 = h4 | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
          // prettier-ignore
          let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
          // Instead of iterating 0 to 80, we split it into 5 groups
          // And use the groups in constants, functions, etc. Much simpler
          for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
              const tl =
                (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) +
                  el) |
                0;
              al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
              const tr =
                (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) +
                  er) |
                0;
              ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
          }
          // Add the compressed chunk to the current hash value
          this.set(
            (this.h1 + cl + dr) | 0,
            (this.h2 + dl + er) | 0,
            (this.h3 + el + ar) | 0,
            (this.h4 + al + br) | 0,
            (this.h0 + bl + cr) | 0
          );
        }
        roundClean() {
          BUF.fill(0);
        }
        destroy() {
          this.destroyed = true;
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0);
        }
      }
      exports.RIPEMD160 = RIPEMD160;
      exports.ripemd160 = (0, utils_1.wrapConstructor)(() => new RIPEMD160());

      /***/
    },

    /***/ 5374: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha256 = void 0;
      const _sha2_1 = __webpack_require__(6365);
      const utils_1 = __webpack_require__(8359);
      // Choice: a ? b : c
      const Chi = (a, b, c) => (a & b) ^ (~a & c);
      // Majority function, true if any two inpust is true
      const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
      // Round constants:
      // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
      // prettier-ignore
      const SHA256_K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
      // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
      // prettier-ignore
      const IV = new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
      // Temporary buffer, not used to store anything between runs
      // Named this way because it matches specification.
      const SHA256_W = new Uint32Array(64);
      class SHA256 extends _sha2_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          // We cannot use array here since array allows indexing by variable
          // which means optimizer/compiler cannot use registers.
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
        process(view, offset) {
          // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 =
              (0, utils_1.rotr)(W15, 7) ^
              (0, utils_1.rotr)(W15, 18) ^
              (W15 >>> 3);
            const s1 =
              (0, utils_1.rotr)(W2, 17) ^
              (0, utils_1.rotr)(W2, 19) ^
              (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
          }
          // Compression function main loop, 64 rounds
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 =
              (0, utils_1.rotr)(E, 6) ^
              (0, utils_1.rotr)(E, 11) ^
              (0, utils_1.rotr)(E, 25);
            const T1 =
              (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 =
              (0, utils_1.rotr)(A, 2) ^
              (0, utils_1.rotr)(A, 13) ^
              (0, utils_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
          }
          // Add the compressed chunk to the current hash value
          A = (A + this.A) | 0;
          B = (B + this.B) | 0;
          C = (C + this.C) | 0;
          D = (D + this.D) | 0;
          E = (E + this.E) | 0;
          F = (F + this.F) | 0;
          G = (G + this.G) | 0;
          H = (H + this.H) | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      }
      exports.sha256 = (0, utils_1.wrapConstructor)(() => new SHA256());

      /***/
    },

    /***/ 8359: /***/ (module, exports, __webpack_require__) => {
      "use strict";
      /* module decorator */ module = __webpack_require__.nmd(module);

      /*! noble-hashes - MIT License (c) 2021 Paul Miller (paulmillr.com) */
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.randomBytes =
        exports.wrapConstructorWithOpts =
        exports.wrapConstructor =
        exports.checkOpts =
        exports.Hash =
        exports.assertHash =
        exports.assertBool =
        exports.assertNumber =
        exports.toBytes =
        exports.asyncLoop =
        exports.nextTick =
        exports.bytesToHex =
        exports.isLE =
        exports.rotr =
        exports.createView =
        exports.u32 =
        exports.u8 =
          void 0;
      // The import here is via the package name. This is to ensure
      // that exports mapping/resolution does fall into place.
      const crypto_1 = __webpack_require__(901);
      // Cast array to different type
      const u8 = (arr) =>
        new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.u8 = u8;
      const u32 = (arr) =>
        new Uint32Array(
          arr.buffer,
          arr.byteOffset,
          Math.floor(arr.byteLength / 4)
        );
      exports.u32 = u32;
      // Cast array to view
      const createView = (arr) =>
        new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.createView = createView;
      // The rotate right (circular right shift) operation for uint32
      const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
      exports.rotr = rotr;
      exports.isLE =
        new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
      // There is almost no big endian hardware, but js typed arrays uses platform specific endianess.
      // So, just to be sure not to corrupt anything.
      if (!exports.isLE)
        throw new Error("Non little-endian hardware is not supported");
      const hexes = Array.from({ length: 256 }, (v, i) =>
        i.toString(16).padStart(2, "0")
      );
      function bytesToHex(uint8a) {
        // pre-caching chars could speed this up 6x.
        let hex = "";
        for (let i = 0; i < uint8a.length; i++) {
          hex += hexes[uint8a[i]];
        }
        return hex;
      }
      exports.bytesToHex = bytesToHex;
      // Currently avoid insertion of polyfills with packers (browserify/webpack/etc)
      // But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here
      exports.nextTick = (() => {
        const nodeRequire =
          true &&
          typeof module.require === "function" &&
          module.require.bind(module);
        try {
          if (nodeRequire) {
            const { setImmediate } = nodeRequire("timers");
            return () => new Promise((resolve) => setImmediate(resolve));
          }
        } catch (e) {}
        return () => new Promise((resolve) => setTimeout(resolve, 0));
      })();
      // Returns control to thread each 'tick' ms to avoid blocking
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick) continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      exports.asyncLoop = asyncLoop;
      function toBytes(data) {
        if (typeof data === "string") data = new TextEncoder().encode(data);
        if (!(data instanceof Uint8Array))
          throw new TypeError(
            `Expected input type is Uint8Array (got ${typeof data})`
          );
        return data;
      }
      exports.toBytes = toBytes;
      function assertNumber(n) {
        if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);
      }
      exports.assertNumber = assertNumber;
      function assertBool(b) {
        if (typeof b !== "boolean") {
          throw new Error(`Expected boolean, not ${b}`);
        }
      }
      exports.assertBool = assertBool;
      function assertHash(hash) {
        if (typeof hash !== "function" || typeof hash.init !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        assertNumber(hash.outputLen);
        assertNumber(hash.blockLen);
      }
      exports.assertHash = assertHash;
      // For runtime check if class implements interface
      class Hash {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      }
      exports.Hash = Hash;
      // Check if object doens't have custom constructor (like Uint8Array/Array)
      const isPlainObject = (obj) =>
        Object.prototype.toString.call(obj) === "[object Object]" &&
        obj.constructor === Object;
      function checkOpts(def, _opts) {
        if (
          _opts !== undefined &&
          (typeof _opts !== "object" || !isPlainObject(_opts))
        )
          throw new TypeError("Options should be object or undefined");
        const opts = Object.assign(def, _opts);
        return opts;
      }
      exports.checkOpts = checkOpts;
      function wrapConstructor(hashConstructor) {
        const hashC = (message) =>
          hashConstructor().update(toBytes(message)).digest();
        const tmp = hashConstructor();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashConstructor();
        hashC.init = hashC.create;
        return hashC;
      }
      exports.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) =>
          hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        hashC.init = hashC.create;
        return hashC;
      }
      exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto.web) {
          return crypto_1.crypto.web.getRandomValues(
            new Uint8Array(bytesLength)
          );
        } else if (crypto_1.crypto.node) {
          return new Uint8Array(
            crypto_1.crypto.node.randomBytes(bytesLength).buffer
          );
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      }
      exports.randomBytes = randomBytes;

      /***/
    },

    /***/ 1337: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      /*! noble-secp256k1 - MIT License (c) Paul Miller (paulmillr.com) */
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.utils =
        exports.schnorr =
        exports.verify =
        exports.signSync =
        exports.sign =
        exports.getSharedSecret =
        exports.recoverPublicKey =
        exports.getPublicKey =
        exports.SignResult =
        exports.Signature =
        exports.Point =
        exports.CURVE =
          void 0;
      const CURVE = {
        a: 0n,
        b: 7n,
        P: 2n ** 256n - 2n ** 32n - 977n,
        n: 2n ** 256n - 432420386565659656852420866394968145599n,
        h: 1n,
        Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,
        Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,
        beta: 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501een,
      };
      exports.CURVE = CURVE;
      function weistrass(x) {
        const { a, b } = CURVE;
        return mod(x ** 3n + a * x + b);
      }
      const USE_ENDOMORPHISM = CURVE.a === 0n;
      class JacobianPoint {
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        static fromAffine(p) {
          if (!(p instanceof Point)) {
            throw new TypeError("JacobianPoint#fromAffine: expected Point");
          }
          return new JacobianPoint(p.x, p.y, 1n);
        }
        static toAffineBatch(points) {
          const toInv = invertBatch(points.map((p) => p.z));
          return points.map((p, i) => p.toAffine(toInv[i]));
        }
        static normalizeZ(points) {
          return JacobianPoint.toAffineBatch(points).map(
            JacobianPoint.fromAffine
          );
        }
        equals(other) {
          const a = this;
          const b = other;
          const az2 = mod(a.z * a.z);
          const az3 = mod(a.z * az2);
          const bz2 = mod(b.z * b.z);
          const bz3 = mod(b.z * bz2);
          return (
            mod(a.x * bz2) === mod(az2 * b.x) &&
            mod(a.y * bz3) === mod(az3 * b.y)
          );
        }
        negate() {
          return new JacobianPoint(this.x, mod(-this.y), this.z);
        }
        double() {
          const X1 = this.x;
          const Y1 = this.y;
          const Z1 = this.z;
          const A = mod(X1 ** 2n);
          const B = mod(Y1 ** 2n);
          const C = mod(B ** 2n);
          const D = mod(2n * (mod(mod((X1 + B) ** 2n)) - A - C));
          const E = mod(3n * A);
          const F = mod(E ** 2n);
          const X3 = mod(F - 2n * D);
          const Y3 = mod(E * (D - X3) - 8n * C);
          const Z3 = mod(2n * Y1 * Z1);
          return new JacobianPoint(X3, Y3, Z3);
        }
        add(other) {
          if (!(other instanceof JacobianPoint)) {
            throw new TypeError("JacobianPoint#add: expected JacobianPoint");
          }
          const X1 = this.x;
          const Y1 = this.y;
          const Z1 = this.z;
          const X2 = other.x;
          const Y2 = other.y;
          const Z2 = other.z;
          if (X2 === 0n || Y2 === 0n) return this;
          if (X1 === 0n || Y1 === 0n) return other;
          const Z1Z1 = mod(Z1 ** 2n);
          const Z2Z2 = mod(Z2 ** 2n);
          const U1 = mod(X1 * Z2Z2);
          const U2 = mod(X2 * Z1Z1);
          const S1 = mod(Y1 * Z2 * Z2Z2);
          const S2 = mod(mod(Y2 * Z1) * Z1Z1);
          const H = mod(U2 - U1);
          const r = mod(S2 - S1);
          if (H === 0n) {
            if (r === 0n) {
              return this.double();
            } else {
              return JacobianPoint.ZERO;
            }
          }
          const HH = mod(H ** 2n);
          const HHH = mod(H * HH);
          const V = mod(U1 * HH);
          const X3 = mod(r ** 2n - HHH - 2n * V);
          const Y3 = mod(r * (V - X3) - S1 * HHH);
          const Z3 = mod(Z1 * Z2 * H);
          return new JacobianPoint(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        multiplyUnsafe(scalar) {
          if (!isValidScalar(scalar))
            throw new TypeError("Point#multiply: expected valid scalar");
          let n = mod(BigInt(scalar), CURVE.n);
          if (!USE_ENDOMORPHISM) {
            let p = JacobianPoint.ZERO;
            let d = this;
            while (n > 0n) {
              if (n & 1n) p = p.add(d);
              d = d.double();
              n >>= 1n;
            }
            return p;
          }
          let [k1neg, k1, k2neg, k2] = splitScalarEndo(n);
          let k1p = JacobianPoint.ZERO;
          let k2p = JacobianPoint.ZERO;
          let d = this;
          while (k1 > 0n || k2 > 0n) {
            if (k1 & 1n) k1p = k1p.add(d);
            if (k2 & 1n) k2p = k2p.add(d);
            d = d.double();
            k1 >>= 1n;
            k2 >>= 1n;
          }
          if (k1neg) k1p = k1p.negate();
          if (k2neg) k2p = k2p.negate();
          k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
          return k1p.add(k2p);
        }
        precomputeWindow(W) {
          const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
          let points = [];
          let p = this;
          let base = p;
          for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            for (let i = 1; i < 2 ** (W - 1); i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        }
        wNAF(n, affinePoint) {
          if (!affinePoint && this.equals(JacobianPoint.BASE))
            affinePoint = Point.BASE;
          const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
          if (256 % W) {
            throw new Error(
              "Point#wNAF: Invalid precomputation window, must be power of 2"
            );
          }
          let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
          if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
              precomputes = JacobianPoint.normalizeZ(precomputes);
              pointPrecomputes.set(affinePoint, precomputes);
            }
          }
          let p = JacobianPoint.ZERO;
          let f = JacobianPoint.ZERO;
          const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
          const windowSize = 2 ** (W - 1);
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window = 0; window < windows; window++) {
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += 1n;
            }
            if (wbits === 0) {
              f = f.add(
                window % 2 ? precomputes[offset].negate() : precomputes[offset]
              );
            } else {
              const cached = precomputes[offset + Math.abs(wbits) - 1];
              p = p.add(wbits < 0 ? cached.negate() : cached);
            }
          }
          return [p, f];
        }
        multiply(scalar, affinePoint) {
          if (!isValidScalar(scalar))
            throw new TypeError("Point#multiply: expected valid scalar");
          let n = mod(BigInt(scalar), CURVE.n);
          let point;
          let fake;
          if (USE_ENDOMORPHISM) {
            const [k1neg, k1, k2neg, k2] = splitScalarEndo(n);
            let k1p, k2p, f1p, f2p;
            [k1p, f1p] = this.wNAF(k1, affinePoint);
            [k2p, f2p] = this.wNAF(k2, affinePoint);
            if (k1neg) k1p = k1p.negate();
            if (k2neg) k2p = k2p.negate();
            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
            [point, fake] = [k1p.add(k2p), f1p.add(f2p)];
          } else {
            [point, fake] = this.wNAF(n, affinePoint);
          }
          return JacobianPoint.normalizeZ([point, fake])[0];
        }
        toAffine(invZ = invert(this.z)) {
          const invZ2 = invZ ** 2n;
          const x = mod(this.x * invZ2);
          const y = mod(this.y * invZ2 * invZ);
          return new Point(x, y);
        }
      }
      JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, 1n);
      JacobianPoint.ZERO = new JacobianPoint(0n, 1n, 0n);
      const pointPrecomputes = new WeakMap();
      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        static fromCompressedHex(bytes) {
          const isShort = bytes.length === 32;
          const x = bytesToNumber(isShort ? bytes : bytes.slice(1));
          const y2 = weistrass(x);
          let y = sqrtMod(y2);
          const isYOdd = (y & 1n) === 1n;
          if (isShort) {
            if (isYOdd) y = mod(-y);
          } else {
            const isFirstByteOdd = (bytes[0] & 1) === 1;
            if (isFirstByteOdd !== isYOdd) y = mod(-y);
          }
          const point = new Point(x, y);
          point.assertValidity();
          return point;
        }
        static fromUncompressedHex(bytes) {
          const x = bytesToNumber(bytes.slice(1, 33));
          const y = bytesToNumber(bytes.slice(33));
          const point = new Point(x, y);
          point.assertValidity();
          return point;
        }
        static fromHex(hex) {
          const bytes = ensureBytes(hex);
          const header = bytes[0];
          if (
            bytes.length === 32 ||
            (bytes.length === 33 && (header === 0x02 || header === 0x03))
          ) {
            return this.fromCompressedHex(bytes);
          }
          if (bytes.length === 65 && header === 0x04)
            return this.fromUncompressedHex(bytes);
          throw new Error(
            `Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${bytes.length}`
          );
        }
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normalizePrivateKey(privateKey));
        }
        static fromSignature(msgHash, signature, recovery) {
          let h =
            msgHash instanceof Uint8Array
              ? bytesToNumber(msgHash)
              : hexToNumber(msgHash);
          const sig = normalizeSignature(signature);
          const { r, s } = sig;
          if (recovery !== 0 && recovery !== 1) {
            throw new Error("Cannot recover signature: invalid yParity bit");
          }
          const prefix = 2 + (recovery & 1);
          const P_ = Point.fromHex(`0${prefix}${pad64(r)}`);
          const sP = JacobianPoint.fromAffine(P_).multiplyUnsafe(s);
          const hG = JacobianPoint.BASE.multiply(h);
          const rinv = invert(r, CURVE.n);
          const Q = sP.subtract(hG).multiplyUnsafe(rinv);
          const point = Q.toAffine();
          point.assertValidity();
          return point;
        }
        toRawBytes(isCompressed = false) {
          return hexToBytes(this.toHex(isCompressed));
        }
        toHex(isCompressed = false) {
          const x = pad64(this.x);
          if (isCompressed) {
            return `${this.y & 1n ? "03" : "02"}${x}`;
          } else {
            return `04${x}${pad64(this.y)}`;
          }
        }
        toHexX() {
          return this.toHex(true).slice(2);
        }
        toRawX() {
          return this.toRawBytes(true).slice(1);
        }
        assertValidity() {
          const msg = "Point is not on elliptic curve";
          const { P } = CURVE;
          const { x, y } = this;
          if (x === 0n || y === 0n || x >= P || y >= P) throw new Error(msg);
          const left = mod(y * y);
          const right = weistrass(x);
          if ((left - right) % P !== 0n) throw new Error(msg);
        }
        equals(other) {
          return this.x === other.x && this.y === other.y;
        }
        negate() {
          return new Point(this.x, mod(-this.y));
        }
        double() {
          return JacobianPoint.fromAffine(this).double().toAffine();
        }
        add(other) {
          return JacobianPoint.fromAffine(this)
            .add(JacobianPoint.fromAffine(other))
            .toAffine();
        }
        subtract(other) {
          return this.add(other.negate());
        }
        multiply(scalar) {
          return JacobianPoint.fromAffine(this)
            .multiply(scalar, this)
            .toAffine();
        }
      }
      exports.Point = Point;
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
      Point.ZERO = new Point(0n, 0n);
      function sliceDer(s) {
        return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
      }
      class Signature {
        constructor(r, s) {
          this.r = r;
          this.s = s;
        }
        static fromCompact(hex) {
          if (typeof hex !== "string" && !(hex instanceof Uint8Array)) {
            throw new TypeError(
              `Signature.fromCompact: Expected string or Uint8Array`
            );
          }
          const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;
          if (str.length !== 128)
            throw new Error("Signature.fromCompact: Expected 64-byte hex");
          const sig = new Signature(
            hexToNumber(str.slice(0, 64)),
            hexToNumber(str.slice(64, 128))
          );
          sig.assertValidity();
          return sig;
        }
        static fromDER(hex) {
          const fn = "Signature.fromDER";
          if (typeof hex !== "string" && !(hex instanceof Uint8Array)) {
            throw new TypeError(`${fn}: Expected string or Uint8Array`);
          }
          const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;
          const length = parseByte(str.slice(2, 4));
          if (
            str.slice(0, 2) !== "30" ||
            length !== str.length - 4 ||
            str.slice(4, 6) !== "02"
          ) {
            throw new Error(`${fn}: Invalid signature ${str}`);
          }
          const rLen = parseByte(str.slice(6, 8));
          const rEnd = 8 + rLen;
          const rr = str.slice(8, rEnd);
          if (rr.startsWith("00") && parseByte(rr.slice(2, 4)) <= 0x7f) {
            throw new Error(`${fn}: Invalid r with trailing length`);
          }
          const r = hexToNumber(rr);
          const separator = str.slice(rEnd, rEnd + 2);
          if (separator !== "02") {
            throw new Error(`${fn}: Invalid r-s separator`);
          }
          const sLen = parseByte(str.slice(rEnd + 2, rEnd + 4));
          const diff = length - sLen - rLen - 10;
          if (diff > 0 || diff === -4) {
            throw new Error(`${fn}: Invalid total length`);
          }
          if (sLen > length - rLen - 4) {
            throw new Error(`${fn}: Invalid s`);
          }
          const sStart = rEnd + 4;
          const ss = str.slice(sStart, sStart + sLen);
          if (ss.startsWith("00") && parseByte(ss.slice(2, 4)) <= 0x7f) {
            throw new Error(`${fn}: Invalid s with trailing length`);
          }
          const s = hexToNumber(ss);
          const sig = new Signature(r, s);
          sig.assertValidity();
          return sig;
        }
        static fromHex(hex) {
          return this.fromDER(hex);
        }
        assertValidity() {
          const { r, s } = this;
          if (!isWithinCurveOrder(r))
            throw new Error("Invalid Signature: r must be 0 < r < n");
          if (!isWithinCurveOrder(s))
            throw new Error("Invalid Signature: s must be 0 < s < n");
        }
        toDERRawBytes(isCompressed = false) {
          return hexToBytes(this.toDERHex(isCompressed));
        }
        toDERHex(isCompressed = false) {
          const sHex = sliceDer(numberToHex(this.s));
          if (isCompressed) return sHex;
          const rHex = sliceDer(numberToHex(this.r));
          const rLen = numberToHex(rHex.length / 2);
          const sLen = numberToHex(sHex.length / 2);
          const length = numberToHex(rHex.length / 2 + sHex.length / 2 + 4);
          return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
        }
        toRawBytes() {
          return this.toDERRawBytes();
        }
        toHex() {
          return this.toDERHex();
        }
        toCompactRawBytes() {
          return hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return pad64(this.r) + pad64(this.s);
        }
      }
      exports.Signature = Signature;
      exports.SignResult = Signature;
      function concatBytes(...arrays) {
        if (arrays.length === 1) return arrays[0];
        const length = arrays.reduce((a, arr) => a + arr.length, 0);
        const result = new Uint8Array(length);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const arr = arrays[i];
          result.set(arr, pad);
          pad += arr.length;
        }
        return result;
      }
      function bytesToHex(uint8a) {
        let hex = "";
        for (let i = 0; i < uint8a.length; i++) {
          hex += uint8a[i].toString(16).padStart(2, "0");
        }
        return hex;
      }
      function pad64(num) {
        return num.toString(16).padStart(64, "0");
      }
      function pad32b(num) {
        return hexToBytes(pad64(num));
      }
      function numberToHex(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      function hexToNumber(hex) {
        if (typeof hex !== "string") {
          throw new TypeError(
            "hexToNumber: expected string, got " + typeof hex
          );
        }
        return BigInt(`0x${hex}`);
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string") {
          throw new TypeError("hexToBytes: expected string, got " + typeof hex);
        }
        if (hex.length % 2)
          throw new Error("hexToBytes: received invalid unpadded hex");
        const array = new Uint8Array(hex.length / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          array[i] = Number.parseInt(hex.slice(j, j + 2), 16);
        }
        return array;
      }
      function ensureBytes(hex) {
        return hex instanceof Uint8Array ? hex : hexToBytes(hex);
      }
      function bytesToNumber(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      function parseByte(str) {
        return Number.parseInt(str, 16) * 2;
      }
      function isValidScalar(num) {
        if (typeof num === "bigint" && num > 0n) return true;
        if (typeof num === "number" && num > 0 && Number.isSafeInteger(num))
          return true;
        return false;
      }
      function mod(a, b = CURVE.P) {
        const result = a % b;
        return result >= 0 ? result : b + result;
      }
      function pow2(x, power) {
        const { P } = CURVE;
        let res = x;
        while (power-- > 0n) {
          res *= res;
          res %= P;
        }
        return res;
      }
      function sqrtMod(x) {
        const { P } = CURVE;
        const b2 = (x * x * x) % P;
        const b3 = (b2 * b2 * x) % P;
        const b6 = (pow2(b3, 3n) * b3) % P;
        const b9 = (pow2(b6, 3n) * b3) % P;
        const b11 = (pow2(b9, 2n) * b2) % P;
        const b22 = (pow2(b11, 11n) * b11) % P;
        const b44 = (pow2(b22, 22n) * b22) % P;
        const b88 = (pow2(b44, 44n) * b44) % P;
        const b176 = (pow2(b88, 88n) * b88) % P;
        const b220 = (pow2(b176, 44n) * b44) % P;
        const b223 = (pow2(b220, 3n) * b3) % P;
        const t1 = (pow2(b223, 23n) * b22) % P;
        const t2 = (pow2(t1, 6n) * b2) % P;
        return pow2(t2, 2n);
      }
      function invert(number, modulo = CURVE.P) {
        if (number === 0n || modulo <= 0n) {
          throw new Error(
            `invert: expected positive integers, got n=${number} mod=${modulo}`
          );
        }
        let a = mod(number, modulo);
        let b = modulo;
        let [x, y, u, v] = [0n, 1n, 1n, 0n];
        while (a !== 0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          [b, a] = [a, r];
          [x, y] = [u, v];
          [u, v] = [m, n];
        }
        const gcd = b;
        if (gcd !== 1n) throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      function invertBatch(nums, n = CURVE.P) {
        const len = nums.length;
        const scratch = new Array(len);
        let acc = 1n;
        for (let i = 0; i < len; i++) {
          if (nums[i] === 0n) continue;
          scratch[i] = acc;
          acc = mod(acc * nums[i], n);
        }
        acc = invert(acc, n);
        for (let i = len - 1; i >= 0; i--) {
          if (nums[i] === 0n) continue;
          const tmp = mod(acc * nums[i], n);
          nums[i] = mod(acc * scratch[i], n);
          acc = tmp;
        }
        return nums;
      }
      const divNearest = (a, b) => (a + b / 2n) / b;
      const POW_2_128 = 2n ** 128n;
      function splitScalarEndo(k) {
        const { n } = CURVE;
        const a1 = 0x3086d221a7d46bcde86c90e49284eb15n;
        const b1 = -0xe4437ed6010e88286f547fa90abfe4c3n;
        const a2 = 0x114ca50f7a8e2f3f657c1108d9d44cfd8n;
        const b2 = a1;
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg) k1 = n - k1;
        if (k2neg) k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128)
          throw new Error("splitScalarEndo: Endomorphism failed");
        return [k1neg, k1, k2neg, k2];
      }
      function truncateHash(hash) {
        if (typeof hash !== "string") hash = bytesToHex(hash);
        let msg = hexToNumber(hash || "0");
        const byteLength = hash.length / 2;
        const delta = byteLength * 8 - 256;
        if (delta > 0) {
          msg = msg >> BigInt(delta);
        }
        if (msg >= CURVE.n) {
          msg -= CURVE.n;
        }
        return msg;
      }
      function _abc6979(msgHash, privateKey) {
        if (msgHash == null)
          throw new Error(`sign: expected valid msgHash, not "${msgHash}"`);
        const num =
          typeof msgHash === "string"
            ? hexToNumber(msgHash)
            : bytesToNumber(msgHash);
        const h1 = pad32b(num);
        const h1n = bytesToNumber(h1);
        const x = pad32b(privateKey);
        let v = new Uint8Array(32).fill(1);
        let k = new Uint8Array(32).fill(0);
        const b0 = Uint8Array.from([0x00]);
        const b1 = Uint8Array.from([0x01]);
        return [h1, h1n, x, v, k, b0, b1];
      }
      async function getQRSrfc6979(msgHash, privateKey) {
        const privKey = normalizePrivateKey(privateKey);
        let [h1, h1n, x, v, k, b0, b1] = _abc6979(msgHash, privKey);
        const hmac = exports.utils.hmacSha256;
        k = await hmac(k, v, b0, x, h1);
        v = await hmac(k, v);
        k = await hmac(k, v, b1, x, h1);
        v = await hmac(k, v);
        for (let i = 0; i < 1000; i++) {
          v = await hmac(k, v);
          let qrs = calcQRSFromK(v, h1n, privKey);
          if (qrs) return qrs;
          k = await hmac(k, v, b0);
          v = await hmac(k, v);
        }
        throw new TypeError(
          "secp256k1: Tried 1,000 k values for sign(), all were invalid"
        );
      }
      function getQRSrfc6979Sync(msgHash, privateKey) {
        const privKey = normalizePrivateKey(privateKey);
        let [h1, h1n, x, v, k, b0, b1] = _abc6979(msgHash, privKey);
        const hmac = exports.utils.hmacSha256Sync;
        if (!hmac)
          throw new Error(
            "utils.hmacSha256Sync is undefined, you need to set it"
          );
        k = hmac(k, v, b0, x, h1);
        if (k instanceof Promise)
          throw new Error(
            "To use sync sign(), ensure utils.hmacSha256 is sync"
          );
        v = hmac(k, v);
        k = hmac(k, v, b1, x, h1);
        v = hmac(k, v);
        for (let i = 0; i < 1000; i++) {
          v = hmac(k, v);
          let qrs = calcQRSFromK(v, h1n, privKey);
          if (qrs) return qrs;
          k = hmac(k, v, b0);
          v = hmac(k, v);
        }
        throw new TypeError(
          "secp256k1: Tried 1,000 k values for sign(), all were invalid"
        );
      }
      function isWithinCurveOrder(num) {
        return 0 < num && num < CURVE.n;
      }
      function calcQRSFromK(v, msg, priv) {
        const k = bytesToNumber(v);
        if (!isWithinCurveOrder(k)) return;
        const max = CURVE.n;
        const q = Point.BASE.multiply(k);
        const r = mod(q.x, max);
        const s = mod(invert(k, max) * (msg + r * priv), max);
        if (r === 0n || s === 0n) return;
        return [q, r, s];
      }
      function normalizePrivateKey(key) {
        let num;
        if (typeof key === "bigint") {
          num = key;
        } else if (
          typeof key === "number" &&
          Number.isSafeInteger(key) &&
          key > 0
        ) {
          num = BigInt(key);
        } else if (typeof key === "string") {
          if (key.length !== 64)
            throw new Error("Expected 32 bytes of private key");
          num = hexToNumber(key);
        } else if (key instanceof Uint8Array) {
          if (key.length !== 32)
            throw new Error("Expected 32 bytes of private key");
          num = bytesToNumber(key);
        } else {
          throw new TypeError("Expected valid private key");
        }
        if (!isWithinCurveOrder(num))
          throw new Error("Expected private key: 0 < key < n");
        return num;
      }
      function normalizePublicKey(publicKey) {
        if (publicKey instanceof Point) {
          publicKey.assertValidity();
          return publicKey;
        } else {
          return Point.fromHex(publicKey);
        }
      }
      function normalizeSignature(signature) {
        if (signature instanceof Signature) {
          signature.assertValidity();
          return signature;
        } else {
          return Signature.fromDER(signature);
        }
      }
      function getPublicKey(privateKey, isCompressed = false) {
        const point = Point.fromPrivateKey(privateKey);
        if (typeof privateKey === "string") {
          return point.toHex(isCompressed);
        }
        return point.toRawBytes(isCompressed);
      }
      exports.getPublicKey = getPublicKey;
      function recoverPublicKey(msgHash, signature, recovery) {
        const point = Point.fromSignature(msgHash, signature, recovery);
        return typeof msgHash === "string" ? point.toHex() : point.toRawBytes();
      }
      exports.recoverPublicKey = recoverPublicKey;
      function isPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr) return len === 33 || len === 65;
        if (str) return len === 66 || len === 130;
        if (item instanceof Point) return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = false) {
        if (isPub(privateA))
          throw new TypeError("getSharedSecret: first arg must be private key");
        if (!isPub(publicB))
          throw new TypeError("getSharedSecret: second arg must be public key");
        const b = normalizePublicKey(publicB);
        b.assertValidity();
        const shared = b.multiply(normalizePrivateKey(privateA));
        return typeof privateA === "string"
          ? shared.toHex(isCompressed)
          : shared.toRawBytes(isCompressed);
      }
      exports.getSharedSecret = getSharedSecret;
      function QRSToSig(qrs, opts, str = false) {
        const [q, r, s] = qrs;
        let { canonical, der, recovered } = opts;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n);
        let adjustedS = s;
        const HIGH_NUMBER = CURVE.n >> 1n;
        if (s > HIGH_NUMBER && canonical) {
          adjustedS = CURVE.n - s;
          recovery ^= 1;
        }
        const sig = new Signature(r, adjustedS);
        sig.assertValidity();
        const hex = der === false ? sig.toCompactHex() : sig.toDERHex();
        const hashed = str ? hex : hexToBytes(hex);
        return recovered ? [hashed, recovery] : hashed;
      }
      async function sign(msgHash, privKey, opts = {}) {
        return QRSToSig(
          await getQRSrfc6979(msgHash, privKey),
          opts,
          typeof msgHash === "string"
        );
      }
      exports.sign = sign;
      function signSync(msgHash, privKey, opts = {}) {
        return QRSToSig(
          getQRSrfc6979Sync(msgHash, privKey),
          opts,
          typeof msgHash === "string"
        );
      }
      exports.signSync = signSync;
      function verify(signature, msgHash, publicKey) {
        const { n } = CURVE;
        let sig;
        try {
          sig = normalizeSignature(signature);
        } catch (error) {
          return false;
        }
        const { r, s } = sig;
        const h = truncateHash(msgHash);
        if (h === 0n) return false;
        const pubKey = JacobianPoint.fromAffine(normalizePublicKey(publicKey));
        const s1 = invert(s, n);
        const u1 = mod(h * s1, n);
        const u2 = mod(r * s1, n);
        const Ghs1 = JacobianPoint.BASE.multiply(u1);
        const Prs1 = pubKey.multiplyUnsafe(u2);
        const R = Ghs1.add(Prs1).toAffine();
        const v = mod(R.x, n);
        return v === r;
      }
      exports.verify = verify;
      async function taggedHash(tag, ...messages) {
        const tagB = new Uint8Array(tag.split("").map((c) => c.charCodeAt(0)));
        const tagH = await exports.utils.sha256(tagB);
        const h = await exports.utils.sha256(
          concatBytes(tagH, tagH, ...messages)
        );
        return bytesToNumber(h);
      }
      async function createChallenge(x, P, message) {
        const rx = pad32b(x);
        const t = await taggedHash(
          "BIP0340/challenge",
          rx,
          P.toRawX(),
          message
        );
        return mod(t, CURVE.n);
      }
      function hasEvenY(point) {
        return mod(point.y, 2n) === 0n;
      }
      class SchnorrSignature {
        constructor(r, s) {
          this.r = r;
          this.s = s;
          if (r <= 0n || s <= 0n || r >= CURVE.P || s >= CURVE.n)
            throw new Error("Invalid signature");
        }
        static fromHex(hex) {
          const bytes = ensureBytes(hex);
          if (bytes.length !== 64) {
            throw new TypeError(
              `SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`
            );
          }
          const r = bytesToNumber(bytes.slice(0, 32));
          const s = bytesToNumber(bytes.slice(32));
          return new SchnorrSignature(r, s);
        }
        toHex() {
          return pad64(this.r) + pad64(this.s);
        }
        toRawBytes() {
          return hexToBytes(this.toHex());
        }
      }
      function schnorrGetPublicKey(privateKey) {
        const P = Point.fromPrivateKey(privateKey);
        return typeof privateKey === "string" ? P.toHexX() : P.toRawX();
      }
      async function schnorrSign(
        msgHash,
        privateKey,
        auxRand = exports.utils.randomBytes()
      ) {
        if (msgHash == null)
          throw new TypeError(`sign: Expected valid message, not "${msgHash}"`);
        if (!privateKey) privateKey = 0n;
        const { n } = CURVE;
        const m = ensureBytes(msgHash);
        const d0 = normalizePrivateKey(privateKey);
        const rand = ensureBytes(auxRand);
        if (rand.length !== 32)
          throw new TypeError("sign: Expected 32 bytes of aux randomness");
        const P = Point.fromPrivateKey(d0);
        const d = hasEvenY(P) ? d0 : n - d0;
        const t0h = await taggedHash("BIP0340/aux", rand);
        const t = d ^ t0h;
        const k0h = await taggedHash("BIP0340/nonce", pad32b(t), P.toRawX(), m);
        const k0 = mod(k0h, n);
        if (k0 === 0n)
          throw new Error("sign: Creation of signature failed. k is zero");
        const R = Point.fromPrivateKey(k0);
        const k = hasEvenY(R) ? k0 : n - k0;
        const e = await createChallenge(R.x, P, m);
        const sig = new SchnorrSignature(R.x, mod(k + e * d, n));
        const isValid = await schnorrVerify(sig.toRawBytes(), m, P.toRawX());
        if (!isValid) throw new Error("sign: Invalid signature produced");
        return typeof msgHash === "string" ? sig.toHex() : sig.toRawBytes();
      }
      async function schnorrVerify(signature, msgHash, publicKey) {
        const sig =
          signature instanceof SchnorrSignature
            ? signature
            : SchnorrSignature.fromHex(signature);
        const m = typeof msgHash === "string" ? hexToBytes(msgHash) : msgHash;
        const P = normalizePublicKey(publicKey);
        const e = await createChallenge(sig.r, P, m);
        const sG = Point.fromPrivateKey(sig.s);
        const eP = P.multiply(e);
        const R = sG.subtract(eP);
        if (R.equals(Point.BASE) || !hasEvenY(R) || R.x !== sig.r) return false;
        return true;
      }
      exports.schnorr = {
        Signature: SchnorrSignature,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
      };
      Point.BASE._setWindowSize(8);
      const crypto = (() => {
        const webCrypto =
          typeof self === "object" && "crypto" in self
            ? self.crypto
            : undefined;
        const nodeRequire = true && "function" === "function";
        return {
          node:
            nodeRequire && !webCrypto ? __webpack_require__(5102) : undefined,
          web: webCrypto,
        };
      })();
      exports.utils = {
        isValidPrivateKey(privateKey) {
          try {
            normalizePrivateKey(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        randomBytes: (bytesLength = 32) => {
          if (crypto.web) {
            return crypto.web.getRandomValues(new Uint8Array(bytesLength));
          } else if (crypto.node) {
            const { randomBytes } = crypto.node;
            return new Uint8Array(randomBytes(bytesLength).buffer);
          } else {
            throw new Error(
              "The environment doesn't have randomBytes function"
            );
          }
        },
        randomPrivateKey: () => {
          let i = 8;
          while (i--) {
            const b32 = exports.utils.randomBytes(32);
            const num = bytesToNumber(b32);
            if (isWithinCurveOrder(num) && num !== 1n) return b32;
          }
          throw new Error(
            "Valid private key was not found in 8 iterations. PRNG is broken"
          );
        },
        sha256: async (message) => {
          if (crypto.web) {
            const buffer = await crypto.web.subtle.digest(
              "SHA-256",
              message.buffer
            );
            return new Uint8Array(buffer);
          } else if (crypto.node) {
            const { createHash } = crypto.node;
            return Uint8Array.from(
              createHash("sha256").update(message).digest()
            );
          } else {
            throw new Error("The environment doesn't have sha256 function");
          }
        },
        hmacSha256: async (key, ...messages) => {
          if (crypto.web) {
            const ckey = await crypto.web.subtle.importKey(
              "raw",
              key,
              { name: "HMAC", hash: { name: "SHA-256" } },
              false,
              ["sign"]
            );
            const message = concatBytes(...messages);
            const buffer = await crypto.web.subtle.sign("HMAC", ckey, message);
            return new Uint8Array(buffer);
          } else if (crypto.node) {
            const { createHmac } = crypto.node;
            const hash = createHmac("sha256", key);
            for (let message of messages) {
              hash.update(message);
            }
            return Uint8Array.from(hash.digest());
          } else {
            throw new Error(
              "The environment doesn't have hmac-sha256 function"
            );
          }
        },
        sha256Sync: undefined,
        hmacSha256Sync: undefined,
        precompute(windowSize = 8, point = Point.BASE) {
          const cached =
            point === Point.BASE ? point : new Point(point.x, point.y);
          cached._setWindowSize(windowSize);
          cached.multiply(3n);
          return cached;
        },
      };

      /***/
    },

    /***/ 4537: /***/ (module) => {
      "use strict";

      module.exports = asPromise;

      /**
       * Callback as used by {@link util.asPromise}.
       * @typedef asPromiseCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {...*} params Additional arguments
       * @returns {undefined}
       */

      /**
       * Returns a promise from a node-style callback function.
       * @memberof util
       * @param {asPromiseCallback} fn Function to call
       * @param {*} ctx Function context
       * @param {...*} params Function arguments
       * @returns {Promise<*>} Promisified function
       */
      function asPromise(fn, ctx /*, varargs */) {
        var params = new Array(arguments.length - 1),
          offset = 0,
          index = 2,
          pending = true;
        while (index < arguments.length) params[offset++] = arguments[index++];
        return new Promise(function executor(resolve, reject) {
          params[offset] = function callback(err /*, varargs */) {
            if (pending) {
              pending = false;
              if (err) reject(err);
              else {
                var params = new Array(arguments.length - 1),
                  offset = 0;
                while (offset < params.length)
                  params[offset++] = arguments[offset];
                resolve.apply(null, params);
              }
            }
          };
          try {
            fn.apply(ctx || null, params);
          } catch (err) {
            if (pending) {
              pending = false;
              reject(err);
            }
          }
        });
      }

      /***/
    },

    /***/ 7419: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      /**
       * A minimal base64 implementation for number arrays.
       * @memberof util
       * @namespace
       */
      var base64 = exports;

      /**
       * Calculates the byte length of a base64 encoded string.
       * @param {string} string Base64 encoded string
       * @returns {number} Byte length
       */
      base64.length = function length(string) {
        var p = string.length;
        if (!p) return 0;
        var n = 0;
        while (--p % 4 > 1 && string.charAt(p) === "=") ++n;
        return Math.ceil(string.length * 3) / 4 - n;
      };

      // Base64 encoding table
      var b64 = new Array(64);

      // Base64 decoding table
      var s64 = new Array(123);

      // 65..90, 97..122, 48..57, 43, 47
      for (var i = 0; i < 64; )
        s64[
          (b64[i] =
            i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : (i - 59) | 43)
        ] = i++;

      /**
       * Encodes a buffer to a base64 encoded string.
       * @param {Uint8Array} buffer Source buffer
       * @param {number} start Source start
       * @param {number} end Source end
       * @returns {string} Base64 encoded string
       */
      base64.encode = function encode(buffer, start, end) {
        var parts = null,
          chunk = [];
        var i = 0, // output index
          j = 0, // goto index
          t; // temporary
        while (start < end) {
          var b = buffer[start++];
          switch (j) {
            case 0:
              chunk[i++] = b64[b >> 2];
              t = (b & 3) << 4;
              j = 1;
              break;
            case 1:
              chunk[i++] = b64[t | (b >> 4)];
              t = (b & 15) << 2;
              j = 2;
              break;
            case 2:
              chunk[i++] = b64[t | (b >> 6)];
              chunk[i++] = b64[b & 63];
              j = 0;
              break;
          }
          if (i > 8191) {
            (parts || (parts = [])).push(
              String.fromCharCode.apply(String, chunk)
            );
            i = 0;
          }
        }
        if (j) {
          chunk[i++] = b64[t];
          chunk[i++] = 61;
          if (j === 1) chunk[i++] = 61;
        }
        if (parts) {
          if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i));
      };

      var invalidEncoding = "invalid encoding";

      /**
       * Decodes a base64 encoded string to a buffer.
       * @param {string} string Source string
       * @param {Uint8Array} buffer Destination buffer
       * @param {number} offset Destination offset
       * @returns {number} Number of bytes written
       * @throws {Error} If encoding is invalid
       */
      base64.decode = function decode(string, buffer, offset) {
        var start = offset;
        var j = 0, // goto index
          t; // temporary
        for (var i = 0; i < string.length; ) {
          var c = string.charCodeAt(i++);
          if (c === 61 && j > 1) break;
          if ((c = s64[c]) === undefined) throw Error(invalidEncoding);
          switch (j) {
            case 0:
              t = c;
              j = 1;
              break;
            case 1:
              buffer[offset++] = (t << 2) | ((c & 48) >> 4);
              t = c;
              j = 2;
              break;
            case 2:
              buffer[offset++] = ((t & 15) << 4) | ((c & 60) >> 2);
              t = c;
              j = 3;
              break;
            case 3:
              buffer[offset++] = ((t & 3) << 6) | c;
              j = 0;
              break;
          }
        }
        if (j === 1) throw Error(invalidEncoding);
        return offset - start;
      };

      /**
       * Tests if the specified string appears to be base64 encoded.
       * @param {string} string String to test
       * @returns {boolean} `true` if probably base64 encoded, otherwise false
       */
      base64.test = function test(string) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(
          string
        );
      };

      /***/
    },

    /***/ 5124: /***/ (module) => {
      "use strict";

      module.exports = codegen;

      /**
       * Begins generating a function.
       * @memberof util
       * @param {string[]} functionParams Function parameter names
       * @param {string} [functionName] Function name if not anonymous
       * @returns {Codegen} Appender that appends code to the function's body
       */
      function codegen(functionParams, functionName) {
        /* istanbul ignore if */
        if (typeof functionParams === "string") {
          functionName = functionParams;
          functionParams = undefined;
        }

        var body = [];

        /**
         * Appends code to the function's body or finishes generation.
         * @typedef Codegen
         * @type {function}
         * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
         * @param {...*} [formatParams] Format parameters
         * @returns {Codegen|Function} Itself or the generated function if finished
         * @throws {Error} If format parameter counts do not match
         */

        function Codegen(formatStringOrScope) {
          // note that explicit array handling below makes this ~50% faster

          // finish the function
          if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose) console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
              var scopeKeys = Object.keys(formatStringOrScope),
                scopeParams = new Array(scopeKeys.length + 1),
                scopeValues = new Array(scopeKeys.length),
                scopeOffset = 0;
              while (scopeOffset < scopeKeys.length) {
                scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                scopeValues[scopeOffset] =
                  formatStringOrScope[scopeKeys[scopeOffset++]];
              }
              scopeParams[scopeOffset] = source;
              return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
          }

          // otherwise append to body
          var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
          while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
          formatOffset = 0;
          formatStringOrScope = formatStringOrScope.replace(
            /%([%dfijs])/g,
            function replace($0, $1) {
              var value = formatParams[formatOffset++];
              switch ($1) {
                case "d":
                case "f":
                  return String(Number(value));
                case "i":
                  return String(Math.floor(value));
                case "j":
                  return JSON.stringify(value);
                case "s":
                  return String(value);
              }
              return "%";
            }
          );
          if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
          body.push(formatStringOrScope);
          return Codegen;
        }

        function toString(functionNameOverride) {
          return (
            "function " +
            (functionNameOverride || functionName || "") +
            "(" +
            ((functionParams && functionParams.join(",")) || "") +
            "){\n  " +
            body.join("\n  ") +
            "\n}"
          );
        }

        Codegen.toString = toString;
        return Codegen;
      }

      /**
       * Begins generating a function.
       * @memberof util
       * @function codegen
       * @param {string} [functionName] Function name if not anonymous
       * @returns {Codegen} Appender that appends code to the function's body
       * @variation 2
       */

      /**
       * When set to `true`, codegen will log generated code to console. Useful for debugging.
       * @name util.codegen.verbose
       * @type {boolean}
       */
      codegen.verbose = false;

      /***/
    },

    /***/ 9211: /***/ (module) => {
      "use strict";

      module.exports = EventEmitter;

      /**
       * Constructs a new event emitter instance.
       * @classdesc A minimal event emitter.
       * @memberof util
       * @constructor
       */
      function EventEmitter() {
        /**
         * Registered listeners.
         * @type {Object.<string,*>}
         * @private
         */
        this._listeners = {};
      }

      /**
       * Registers an event listener.
       * @param {string} evt Event name
       * @param {function} fn Listener
       * @param {*} [ctx] Listener context
       * @returns {util.EventEmitter} `this`
       */
      EventEmitter.prototype.on = function on(evt, fn, ctx) {
        (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn: fn,
          ctx: ctx || this,
        });
        return this;
      };

      /**
       * Removes an event listener or any matching listeners if arguments are omitted.
       * @param {string} [evt] Event name. Removes all listeners if omitted.
       * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
       * @returns {util.EventEmitter} `this`
       */
      EventEmitter.prototype.off = function off(evt, fn) {
        if (evt === undefined) this._listeners = {};
        else {
          if (fn === undefined) this._listeners[evt] = [];
          else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length; )
              if (listeners[i].fn === fn) listeners.splice(i, 1);
              else ++i;
          }
        }
        return this;
      };

      /**
       * Emits an event by calling its listeners with the specified arguments.
       * @param {string} evt Event name
       * @param {...*} args Arguments
       * @returns {util.EventEmitter} `this`
       */
      EventEmitter.prototype.emit = function emit(evt) {
        var listeners = this._listeners[evt];
        if (listeners) {
          var args = [],
            i = 1;
          for (; i < arguments.length; ) args.push(arguments[i++]);
          for (i = 0; i < listeners.length; )
            listeners[i].fn.apply(listeners[i++].ctx, args);
        }
        return this;
      };

      /***/
    },

    /***/ 9054: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = fetch;

      var asPromise = __webpack_require__(4537),
        inquire = __webpack_require__(7199);

      var fs = inquire("fs");

      /**
       * Node-style callback as used by {@link util.fetch}.
       * @typedef FetchCallback
       * @type {function}
       * @param {?Error} error Error, if any, otherwise `null`
       * @param {string} [contents] File contents, if there hasn't been an error
       * @returns {undefined}
       */

      /**
       * Options as used by {@link util.fetch}.
       * @typedef FetchOptions
       * @type {Object}
       * @property {boolean} [binary=false] Whether expecting a binary response
       * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
       */

      /**
       * Fetches the contents of a file.
       * @memberof util
       * @param {string} filename File path or url
       * @param {FetchOptions} options Fetch options
       * @param {FetchCallback} callback Callback function
       * @returns {undefined}
       */
      function fetch(filename, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (!options) options = {};

        if (!callback) return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

        // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
        if (!options.xhr && fs && fs.readFile)
          return fs.readFile(
            filename,
            function fetchReadFileCallback(err, contents) {
              return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(
                    null,
                    options.binary ? contents : contents.toString("utf8")
                  );
            }
          );

        // use the XHR version otherwise.
        return fetch.xhr(filename, options, callback);
      }

      /**
       * Fetches the contents of a file.
       * @name util.fetch
       * @function
       * @param {string} path File path or url
       * @param {FetchCallback} callback Callback function
       * @returns {undefined}
       * @variation 2
       */

      /**
       * Fetches the contents of a file.
       * @name util.fetch
       * @function
       * @param {string} path File path or url
       * @param {FetchOptions} [options] Fetch options
       * @returns {Promise<string|Uint8Array>} Promise
       * @variation 3
       */

      /**/
      fetch.xhr = function fetch_xhr(filename, options, callback) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange /* works everywhere */ =
          function fetchOnReadyStateChange() {
            if (xhr.readyState !== 4) return undefined;

            // local cors security errors return status 0 / empty string, too. afaik this cannot be
            // reliably distinguished from an actually empty file for security reasons. feel free
            // to send a pull request if you are aware of a solution.
            if (xhr.status !== 0 && xhr.status !== 200)
              return callback(Error("status " + xhr.status));

            // if binary data is expected, make sure that some sort of array is returned, even if
            // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
            if (options.binary) {
              var buffer = xhr.response;
              if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                  buffer.push(xhr.responseText.charCodeAt(i) & 255);
              }
              return callback(
                null,
                typeof Uint8Array !== "undefined"
                  ? new Uint8Array(buffer)
                  : buffer
              );
            }
            return callback(null, xhr.responseText);
          };

        if (options.binary) {
          // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
          if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
          xhr.responseType = "arraybuffer";
        }

        xhr.open("GET", filename);
        xhr.send();
      };

      /***/
    },

    /***/ 945: /***/ (module) => {
      "use strict";

      module.exports = factory(factory);

      /**
       * Reads / writes floats / doubles from / to buffers.
       * @name util.float
       * @namespace
       */

      /**
       * Writes a 32 bit float to a buffer using little endian byte order.
       * @name util.float.writeFloatLE
       * @function
       * @param {number} val Value to write
       * @param {Uint8Array} buf Target buffer
       * @param {number} pos Target buffer offset
       * @returns {undefined}
       */

      /**
       * Writes a 32 bit float to a buffer using big endian byte order.
       * @name util.float.writeFloatBE
       * @function
       * @param {number} val Value to write
       * @param {Uint8Array} buf Target buffer
       * @param {number} pos Target buffer offset
       * @returns {undefined}
       */

      /**
       * Reads a 32 bit float from a buffer using little endian byte order.
       * @name util.float.readFloatLE
       * @function
       * @param {Uint8Array} buf Source buffer
       * @param {number} pos Source buffer offset
       * @returns {number} Value read
       */

      /**
       * Reads a 32 bit float from a buffer using big endian byte order.
       * @name util.float.readFloatBE
       * @function
       * @param {Uint8Array} buf Source buffer
       * @param {number} pos Source buffer offset
       * @returns {number} Value read
       */

      /**
       * Writes a 64 bit double to a buffer using little endian byte order.
       * @name util.float.writeDoubleLE
       * @function
       * @param {number} val Value to write
       * @param {Uint8Array} buf Target buffer
       * @param {number} pos Target buffer offset
       * @returns {undefined}
       */

      /**
       * Writes a 64 bit double to a buffer using big endian byte order.
       * @name util.float.writeDoubleBE
       * @function
       * @param {number} val Value to write
       * @param {Uint8Array} buf Target buffer
       * @param {number} pos Target buffer offset
       * @returns {undefined}
       */

      /**
       * Reads a 64 bit double from a buffer using little endian byte order.
       * @name util.float.readDoubleLE
       * @function
       * @param {Uint8Array} buf Source buffer
       * @param {number} pos Source buffer offset
       * @returns {number} Value read
       */

      /**
       * Reads a 64 bit double from a buffer using big endian byte order.
       * @name util.float.readDoubleBE
       * @function
       * @param {Uint8Array} buf Source buffer
       * @param {number} pos Source buffer offset
       * @returns {number} Value read
       */

      // Factory function for the purpose of node-based testing in modified global environments
      function factory(exports) {
        // float: typed array
        if (typeof Float32Array !== "undefined")
          (function () {
            var f32 = new Float32Array([-0]),
              f8b = new Uint8Array(f32.buffer),
              le = f8b[3] === 128;

            function writeFloat_f32_cpy(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
            }

            function writeFloat_f32_rev(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[3];
              buf[pos + 1] = f8b[2];
              buf[pos + 2] = f8b[1];
              buf[pos + 3] = f8b[0];
            }

            /* istanbul ignore next */
            exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
            /* istanbul ignore next */
            exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

            function readFloat_f32_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              return f32[0];
            }

            function readFloat_f32_rev(buf, pos) {
              f8b[3] = buf[pos];
              f8b[2] = buf[pos + 1];
              f8b[1] = buf[pos + 2];
              f8b[0] = buf[pos + 3];
              return f32[0];
            }

            /* istanbul ignore next */
            exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
            /* istanbul ignore next */
            exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

            // float: ieee754
          })();
        else
          (function () {
            function writeFloat_ieee754(writeUint, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign) val = -val;
              if (val === 0)
                writeUint(
                  1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648,
                  buf,
                  pos
                );
              else if (isNaN(val)) writeUint(2143289344, buf, pos);
              else if (val > 3.4028234663852886e38)
                // +-Infinity
                writeUint(((sign << 31) | 2139095040) >>> 0, buf, pos);
              else if (val < 1.1754943508222875e-38)
                // denormal
                writeUint(
                  ((sign << 31) | Math.round(val / 1.401298464324817e-45)) >>>
                    0,
                  buf,
                  pos
                );
              else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                  mantissa =
                    Math.round(val * Math.pow(2, -exponent) * 8388608) &
                    8388607;
                writeUint(
                  ((sign << 31) | ((exponent + 127) << 23) | mantissa) >>> 0,
                  buf,
                  pos
                );
              }
            }

            exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
            exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

            function readFloat_ieee754(readUint, buf, pos) {
              var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = (uint >>> 23) & 255,
                mantissa = uint & 8388607;
              return exponent === 255
                ? mantissa
                  ? NaN
                  : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
            }

            exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
            exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
          })();

        // double: typed array
        if (typeof Float64Array !== "undefined")
          (function () {
            var f64 = new Float64Array([-0]),
              f8b = new Uint8Array(f64.buffer),
              le = f8b[7] === 128;

            function writeDouble_f64_cpy(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
              buf[pos + 4] = f8b[4];
              buf[pos + 5] = f8b[5];
              buf[pos + 6] = f8b[6];
              buf[pos + 7] = f8b[7];
            }

            function writeDouble_f64_rev(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[7];
              buf[pos + 1] = f8b[6];
              buf[pos + 2] = f8b[5];
              buf[pos + 3] = f8b[4];
              buf[pos + 4] = f8b[3];
              buf[pos + 5] = f8b[2];
              buf[pos + 6] = f8b[1];
              buf[pos + 7] = f8b[0];
            }

            /* istanbul ignore next */
            exports.writeDoubleLE = le
              ? writeDouble_f64_cpy
              : writeDouble_f64_rev;
            /* istanbul ignore next */
            exports.writeDoubleBE = le
              ? writeDouble_f64_rev
              : writeDouble_f64_cpy;

            function readDouble_f64_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              f8b[4] = buf[pos + 4];
              f8b[5] = buf[pos + 5];
              f8b[6] = buf[pos + 6];
              f8b[7] = buf[pos + 7];
              return f64[0];
            }

            function readDouble_f64_rev(buf, pos) {
              f8b[7] = buf[pos];
              f8b[6] = buf[pos + 1];
              f8b[5] = buf[pos + 2];
              f8b[4] = buf[pos + 3];
              f8b[3] = buf[pos + 4];
              f8b[2] = buf[pos + 5];
              f8b[1] = buf[pos + 6];
              f8b[0] = buf[pos + 7];
              return f64[0];
            }

            /* istanbul ignore next */
            exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
            /* istanbul ignore next */
            exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

            // double: ieee754
          })();
        else
          (function () {
            function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign) val = -val;
              if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(
                  1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648,
                  buf,
                  pos + off1
                );
              } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
              } else if (val > 1.7976931348623157e308) {
                // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint(((sign << 31) | 2146435072) >>> 0, buf, pos + off1);
              } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) {
                  // denormal
                  mantissa = val / 5e-324;
                  writeUint(mantissa >>> 0, buf, pos + off0);
                  writeUint(
                    ((sign << 31) | (mantissa / 4294967296)) >>> 0,
                    buf,
                    pos + off1
                  );
                } else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2);
                  if (exponent === 1024) exponent = 1023;
                  mantissa = val * Math.pow(2, -exponent);
                  writeUint(
                    (mantissa * 4503599627370496) >>> 0,
                    buf,
                    pos + off0
                  );
                  writeUint(
                    ((sign << 31) |
                      ((exponent + 1023) << 20) |
                      ((mantissa * 1048576) & 1048575)) >>>
                      0,
                    buf,
                    pos + off1
                  );
                }
              }
            }

            exports.writeDoubleLE = writeDouble_ieee754.bind(
              null,
              writeUintLE,
              0,
              4
            );
            exports.writeDoubleBE = writeDouble_ieee754.bind(
              null,
              writeUintBE,
              4,
              0
            );

            function readDouble_ieee754(readUint, off0, off1, buf, pos) {
              var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
              var sign = (hi >> 31) * 2 + 1,
                exponent = (hi >>> 20) & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047
                ? mantissa
                  ? NaN
                  : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign *
                  Math.pow(2, exponent - 1075) *
                  (mantissa + 4503599627370496);
            }

            exports.readDoubleLE = readDouble_ieee754.bind(
              null,
              readUintLE,
              0,
              4
            );
            exports.readDoubleBE = readDouble_ieee754.bind(
              null,
              readUintBE,
              4,
              0
            );
          })();

        return exports;
      }

      // uint helpers

      function writeUintLE(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = (val >>> 8) & 255;
        buf[pos + 2] = (val >>> 16) & 255;
        buf[pos + 3] = val >>> 24;
      }

      function writeUintBE(val, buf, pos) {
        buf[pos] = val >>> 24;
        buf[pos + 1] = (val >>> 16) & 255;
        buf[pos + 2] = (val >>> 8) & 255;
        buf[pos + 3] = val & 255;
      }

      function readUintLE(buf, pos) {
        return (
          (buf[pos] |
            (buf[pos + 1] << 8) |
            (buf[pos + 2] << 16) |
            (buf[pos + 3] << 24)) >>>
          0
        );
      }

      function readUintBE(buf, pos) {
        return (
          ((buf[pos] << 24) |
            (buf[pos + 1] << 16) |
            (buf[pos + 2] << 8) |
            buf[pos + 3]) >>>
          0
        );
      }

      /***/
    },

    /***/ 7199: /***/ (module) => {
      "use strict";

      module.exports = inquire;

      /**
       * Requires a module only if available.
       * @memberof util
       * @param {string} moduleName Module to require
       * @returns {?Object} Required module if available and not empty, otherwise `null`
       */
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName); // eslint-disable-line no-eval
          if (mod && (mod.length || Object.keys(mod).length)) return mod;
        } catch (e) {} // eslint-disable-line no-empty
        return null;
      }

      /***/
    },

    /***/ 8626: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      /**
       * A minimal path module to resolve Unix, Windows and URL paths alike.
       * @memberof util
       * @namespace
       */
      var path = exports;

      var isAbsolute =
        /**
         * Tests if the specified path is absolute.
         * @param {string} path Path to test
         * @returns {boolean} `true` if path is absolute
         */
        (path.isAbsolute = function isAbsolute(path) {
          return /^(?:\/|\w+:)/.test(path);
        });

      var normalize =
        /**
         * Normalizes the specified path.
         * @param {string} path Path to normalize
         * @returns {string} Normalized path
         */
        (path.normalize = function normalize(path) {
          path = path.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
          var parts = path.split("/"),
            absolute = isAbsolute(path),
            prefix = "";
          if (absolute) prefix = parts.shift() + "/";
          for (var i = 0; i < parts.length; ) {
            if (parts[i] === "..") {
              if (i > 0 && parts[i - 1] !== "..") parts.splice(--i, 2);
              else if (absolute) parts.splice(i, 1);
              else ++i;
            } else if (parts[i] === ".") parts.splice(i, 1);
            else ++i;
          }
          return prefix + parts.join("/");
        });

      /**
       * Resolves the specified include path against the specified origin path.
       * @param {string} originPath Path to the origin file
       * @param {string} includePath Include path relative to origin path
       * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
       * @returns {string} Path to the include file
       */
      path.resolve = function resolve(
        originPath,
        includePath,
        alreadyNormalized
      ) {
        if (!alreadyNormalized) includePath = normalize(includePath);
        if (isAbsolute(includePath)) return includePath;
        if (!alreadyNormalized) originPath = normalize(originPath);
        return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length
          ? normalize(originPath + "/" + includePath)
          : includePath;
      };

      /***/
    },

    /***/ 6662: /***/ (module) => {
      "use strict";

      module.exports = pool;

      /**
       * An allocator as used by {@link util.pool}.
       * @typedef PoolAllocator
       * @type {function}
       * @param {number} size Buffer size
       * @returns {Uint8Array} Buffer
       */

      /**
       * A slicer as used by {@link util.pool}.
       * @typedef PoolSlicer
       * @type {function}
       * @param {number} start Start offset
       * @param {number} end End offset
       * @returns {Uint8Array} Buffer slice
       * @this {Uint8Array}
       */

      /**
       * A general purpose buffer pool.
       * @memberof util
       * @function
       * @param {PoolAllocator} alloc Allocator
       * @param {PoolSlicer} slice Slicer
       * @param {number} [size=8192] Slab size
       * @returns {PoolAllocator} Pooled allocator
       */
      function pool(alloc, slice, size) {
        var SIZE = size || 8192;
        var MAX = SIZE >>> 1;
        var slab = null;
        var offset = SIZE;
        return function pool_alloc(size) {
          if (size < 1 || size > MAX) return alloc(size);
          if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
          }
          var buf = slice.call(slab, offset, (offset += size));
          if (offset & 7)
            // align to 32 bit
            offset = (offset | 7) + 1;
          return buf;
        };
      }

      /***/
    },

    /***/ 4997: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      /**
       * A minimal UTF8 implementation for number arrays.
       * @memberof util
       * @namespace
       */
      var utf8 = exports;

      /**
       * Calculates the UTF8 byte length of a string.
       * @param {string} string String
       * @returns {number} Byte length
       */
      utf8.length = function utf8_length(string) {
        var len = 0,
          c = 0;
        for (var i = 0; i < string.length; ++i) {
          c = string.charCodeAt(i);
          if (c < 128) len += 1;
          else if (c < 2048) len += 2;
          else if (
            (c & 0xfc00) === 0xd800 &&
            (string.charCodeAt(i + 1) & 0xfc00) === 0xdc00
          ) {
            ++i;
            len += 4;
          } else len += 3;
        }
        return len;
      };

      /**
       * Reads UTF8 bytes as a string.
       * @param {Uint8Array} buffer Source buffer
       * @param {number} start Source start
       * @param {number} end Source end
       * @returns {string} String read
       */
      utf8.read = function utf8_read(buffer, start, end) {
        var len = end - start;
        if (len < 1) return "";
        var parts = null,
          chunk = [],
          i = 0, // char offset
          t; // temporary
        while (start < end) {
          t = buffer[start++];
          if (t < 128) chunk[i++] = t;
          else if (t > 191 && t < 224)
            chunk[i++] = ((t & 31) << 6) | (buffer[start++] & 63);
          else if (t > 239 && t < 365) {
            t =
              (((t & 7) << 18) |
                ((buffer[start++] & 63) << 12) |
                ((buffer[start++] & 63) << 6) |
                (buffer[start++] & 63)) -
              0x10000;
            chunk[i++] = 0xd800 + (t >> 10);
            chunk[i++] = 0xdc00 + (t & 1023);
          } else
            chunk[i++] =
              ((t & 15) << 12) |
              ((buffer[start++] & 63) << 6) |
              (buffer[start++] & 63);
          if (i > 8191) {
            (parts || (parts = [])).push(
              String.fromCharCode.apply(String, chunk)
            );
            i = 0;
          }
        }
        if (parts) {
          if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i));
      };

      /**
       * Writes a string as UTF8 bytes.
       * @param {string} string Source string
       * @param {Uint8Array} buffer Destination buffer
       * @param {number} offset Destination offset
       * @returns {number} Bytes written
       */
      utf8.write = function utf8_write(string, buffer, offset) {
        var start = offset,
          c1, // character 1
          c2; // character 2
        for (var i = 0; i < string.length; ++i) {
          c1 = string.charCodeAt(i);
          if (c1 < 128) {
            buffer[offset++] = c1;
          } else if (c1 < 2048) {
            buffer[offset++] = (c1 >> 6) | 192;
            buffer[offset++] = (c1 & 63) | 128;
          } else if (
            (c1 & 0xfc00) === 0xd800 &&
            ((c2 = string.charCodeAt(i + 1)) & 0xfc00) === 0xdc00
          ) {
            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);
            ++i;
            buffer[offset++] = (c1 >> 18) | 240;
            buffer[offset++] = ((c1 >> 12) & 63) | 128;
            buffer[offset++] = ((c1 >> 6) & 63) | 128;
            buffer[offset++] = (c1 & 63) | 128;
          } else {
            buffer[offset++] = (c1 >> 12) | 224;
            buffer[offset++] = ((c1 >> 6) & 63) | 128;
            buffer[offset++] = (c1 & 63) | 128;
          }
        }
        return offset - start;
      };

      /***/
    },

    /***/ 9669: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      module.exports = __webpack_require__(1609);

      /***/
    },

    /***/ 5448: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);
      var settle = __webpack_require__(6026);
      var cookies = __webpack_require__(4372);
      var buildURL = __webpack_require__(5327);
      var buildFullPath = __webpack_require__(4097);
      var parseHeaders = __webpack_require__(4109);
      var isURLSameOrigin = __webpack_require__(7985);
      var createError = __webpack_require__(5061);

      module.exports = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;

          if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"]; // Let the browser set it
          }

          var request = new XMLHttpRequest();

          // HTTP basic authentication
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password
              ? unescape(encodeURIComponent(config.auth.password))
              : "";
            requestHeaders.Authorization =
              "Basic " + btoa(username + ":" + password);
          }

          var fullPath = buildFullPath(config.baseURL, config.url);
          request.open(
            config.method.toUpperCase(),
            buildURL(fullPath, config.params, config.paramsSerializer),
            true
          );

          // Set the request timeout in MS
          request.timeout = config.timeout;

          // Listen for ready state
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }

            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (
              request.status === 0 &&
              !(
                request.responseURL &&
                request.responseURL.indexOf("file:") === 0
              )
            ) {
              return;
            }

            // Prepare the response
            var responseHeaders =
              "getAllResponseHeaders" in request
                ? parseHeaders(request.getAllResponseHeaders())
                : null;
            var responseData =
              !config.responseType || config.responseType === "text"
                ? request.responseText
                : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config: config,
              request: request,
            };

            settle(resolve, reject, response);

            // Clean up request
            request = null;
          };

          // Handle browser request cancellation (as opposed to a manual cancellation)
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }

            reject(
              createError("Request aborted", config, "ECONNABORTED", request)
            );

            // Clean up request
            request = null;
          };

          // Handle low level network errors
          request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(createError("Network Error", config, null, request));

            // Clean up request
            request = null;
          };

          // Handle timeout
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage =
              "timeout of " + config.timeout + "ms exceeded";
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(
              createError(timeoutErrorMessage, config, "ECONNABORTED", request)
            );

            // Clean up request
            request = null;
          };

          // Add xsrf header
          // This is only done if running in a standard browser environment.
          // Specifically not if we're in a web worker, or react-native.
          if (utils.isStandardBrowserEnv()) {
            // Add xsrf header
            var xsrfValue =
              (config.withCredentials || isURLSameOrigin(fullPath)) &&
              config.xsrfCookieName
                ? cookies.read(config.xsrfCookieName)
                : undefined;

            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }

          // Add headers to the request
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (
                typeof requestData === "undefined" &&
                key.toLowerCase() === "content-type"
              ) {
                // Remove Content-Type if data is undefined
                delete requestHeaders[key];
              } else {
                // Otherwise add header to the request
                request.setRequestHeader(key, val);
              }
            });
          }

          // Add withCredentials to request if needed
          if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }

          // Add responseType to request if needed
          if (config.responseType) {
            try {
              request.responseType = config.responseType;
            } catch (e) {
              // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
              // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
              if (config.responseType !== "json") {
                throw e;
              }
            }
          }

          // Handle progress if needed
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }

          // Not all browsers support upload events
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener(
              "progress",
              config.onUploadProgress
            );
          }

          if (config.cancelToken) {
            // Handle cancellation
            config.cancelToken.promise.then(function onCanceled(cancel) {
              if (!request) {
                return;
              }

              request.abort();
              reject(cancel);
              // Clean up request
              request = null;
            });
          }

          if (!requestData) {
            requestData = null;
          }

          // Send the request
          request.send(requestData);
        });
      };

      /***/
    },

    /***/ 1609: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);
      var bind = __webpack_require__(1849);
      var Axios = __webpack_require__(321);
      var mergeConfig = __webpack_require__(7185);
      var defaults = __webpack_require__(5655);

      /**
       * Create an instance of Axios
       *
       * @param {Object} defaultConfig The default config for the instance
       * @return {Axios} A new instance of Axios
       */
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);

        // Copy axios.prototype to instance
        utils.extend(instance, Axios.prototype, context);

        // Copy context to instance
        utils.extend(instance, context);

        return instance;
      }

      // Create the default instance to be exported
      var axios = createInstance(defaults);

      // Expose Axios class to allow class inheritance
      axios.Axios = Axios;

      // Factory for creating new instances
      axios.create = function create(instanceConfig) {
        return createInstance(mergeConfig(axios.defaults, instanceConfig));
      };

      // Expose Cancel & CancelToken
      axios.Cancel = __webpack_require__(5263);
      axios.CancelToken = __webpack_require__(4972);
      axios.isCancel = __webpack_require__(6502);

      // Expose all/spread
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = __webpack_require__(8713);

      // Expose isAxiosError
      axios.isAxiosError = __webpack_require__(6268);

      module.exports = axios;

      // Allow use of default import syntax in TypeScript
      module.exports.default = axios;

      /***/
    },

    /***/ 5263: /***/ (module) => {
      "use strict";

      /**
       * A `Cancel` is an object that is thrown when an operation is canceled.
       *
       * @class
       * @param {string=} message The message.
       */
      function Cancel(message) {
        this.message = message;
      }

      Cancel.prototype.toString = function toString() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };

      Cancel.prototype.__CANCEL__ = true;

      module.exports = Cancel;

      /***/
    },

    /***/ 4972: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var Cancel = __webpack_require__(5263);

      /**
       * A `CancelToken` is an object that can be used to request cancellation of an operation.
       *
       * @class
       * @param {Function} executor The executor function.
       */
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }

        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });

        var token = this;
        executor(function cancel(message) {
          if (token.reason) {
            // Cancellation has already been requested
            return;
          }

          token.reason = new Cancel(message);
          resolvePromise(token.reason);
        });
      }

      /**
       * Throws a `Cancel` if cancellation has been requested.
       */
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };

      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token: token,
          cancel: cancel,
        };
      };

      module.exports = CancelToken;

      /***/
    },

    /***/ 6502: /***/ (module) => {
      "use strict";

      module.exports = function isCancel(value) {
        return !!(value && value.__CANCEL__);
      };

      /***/
    },

    /***/ 321: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);
      var buildURL = __webpack_require__(5327);
      var InterceptorManager = __webpack_require__(782);
      var dispatchRequest = __webpack_require__(3572);
      var mergeConfig = __webpack_require__(7185);

      /**
       * Create a new instance of Axios
       *
       * @param {Object} instanceConfig The default config for the instance
       */
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager(),
        };
      }

      /**
       * Dispatch a request
       *
       * @param {Object} config The config specific for this request (merged with this.defaults)
       */
      Axios.prototype.request = function request(config) {
        /*eslint no-param-reassign:0*/
        // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof config === "string") {
          config = arguments[1] || {};
          config.url = arguments[0];
        } else {
          config = config || {};
        }

        config = mergeConfig(this.defaults, config);

        // Set config.method
        if (config.method) {
          config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
          config.method = this.defaults.method.toLowerCase();
        } else {
          config.method = "get";
        }

        // Hook up interceptors middleware
        var chain = [dispatchRequest, undefined];
        var promise = Promise.resolve(config);

        this.interceptors.request.forEach(function unshiftRequestInterceptors(
          interceptor
        ) {
          chain.unshift(interceptor.fulfilled, interceptor.rejected);
        });

        this.interceptors.response.forEach(function pushResponseInterceptors(
          interceptor
        ) {
          chain.push(interceptor.fulfilled, interceptor.rejected);
        });

        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }

        return promise;
      };

      Axios.prototype.getUri = function getUri(config) {
        config = mergeConfig(this.defaults, config);
        return buildURL(
          config.url,
          config.params,
          config.paramsSerializer
        ).replace(/^\?/, "");
      };

      // Provide aliases for supported request methods
      utils.forEach(
        ["delete", "get", "head", "options"],
        function forEachMethodNoData(method) {
          /*eslint func-names:0*/
          Axios.prototype[method] = function (url, config) {
            return this.request(
              mergeConfig(config || {}, {
                method: method,
                url: url,
                data: (config || {}).data,
              })
            );
          };
        }
      );

      utils.forEach(
        ["post", "put", "patch"],
        function forEachMethodWithData(method) {
          /*eslint func-names:0*/
          Axios.prototype[method] = function (url, data, config) {
            return this.request(
              mergeConfig(config || {}, {
                method: method,
                url: url,
                data: data,
              })
            );
          };
        }
      );

      module.exports = Axios;

      /***/
    },

    /***/ 782: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);

      function InterceptorManager() {
        this.handlers = [];
      }

      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      InterceptorManager.prototype.use = function use(fulfilled, rejected) {
        this.handlers.push({
          fulfilled: fulfilled,
          rejected: rejected,
        });
        return this.handlers.length - 1;
      };

      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       */
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };

      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       */
      InterceptorManager.prototype.forEach = function forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      };

      module.exports = InterceptorManager;

      /***/
    },

    /***/ 4097: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var isAbsoluteURL = __webpack_require__(1793);
      var combineURLs = __webpack_require__(7303);

      /**
       * Creates a new URL by combining the baseURL with the requestedURL,
       * only when the requestedURL is not already an absolute URL.
       * If the requestURL is absolute, this function returns the requestedURL untouched.
       *
       * @param {string} baseURL The base URL
       * @param {string} requestedURL Absolute or relative URL to combine
       * @returns {string} The combined full path
       */
      module.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };

      /***/
    },

    /***/ 5061: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var enhanceError = __webpack_require__(481);

      /**
       * Create an Error with the specified message, config, error code, request and response.
       *
       * @param {string} message The error message.
       * @param {Object} config The config.
       * @param {string} [code] The error code (for example, 'ECONNABORTED').
       * @param {Object} [request] The request.
       * @param {Object} [response] The response.
       * @returns {Error} The created error.
       */
      module.exports = function createError(
        message,
        config,
        code,
        request,
        response
      ) {
        var error = new Error(message);
        return enhanceError(error, config, code, request, response);
      };

      /***/
    },

    /***/ 3572: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);
      var transformData = __webpack_require__(8527);
      var isCancel = __webpack_require__(6502);
      var defaults = __webpack_require__(5655);

      /**
       * Throws a `Cancel` if cancellation has been requested.
       */
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
      }

      /**
       * Dispatch a request to the server using the configured adapter.
       *
       * @param {object} config The config that is to be used for the request
       * @returns {Promise} The Promise to be fulfilled
       */
      module.exports = function dispatchRequest(config) {
        throwIfCancellationRequested(config);

        // Ensure headers exist
        config.headers = config.headers || {};

        // Transform request data
        config.data = transformData(
          config.data,
          config.headers,
          config.transformRequest
        );

        // Flatten headers
        config.headers = utils.merge(
          config.headers.common || {},
          config.headers[config.method] || {},
          config.headers
        );

        utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          function cleanHeaderConfig(method) {
            delete config.headers[method];
          }
        );

        var adapter = config.adapter || defaults.adapter;

        return adapter(config).then(
          function onAdapterResolution(response) {
            throwIfCancellationRequested(config);

            // Transform response data
            response.data = transformData(
              response.data,
              response.headers,
              config.transformResponse
            );

            return response;
          },
          function onAdapterRejection(reason) {
            if (!isCancel(reason)) {
              throwIfCancellationRequested(config);

              // Transform response data
              if (reason && reason.response) {
                reason.response.data = transformData(
                  reason.response.data,
                  reason.response.headers,
                  config.transformResponse
                );
              }
            }

            return Promise.reject(reason);
          }
        );
      };

      /***/
    },

    /***/ 481: /***/ (module) => {
      "use strict";

      /**
       * Update an Error with the specified config, error code, and response.
       *
       * @param {Error} error The error to update.
       * @param {Object} config The config.
       * @param {string} [code] The error code (for example, 'ECONNABORTED').
       * @param {Object} [request] The request.
       * @param {Object} [response] The response.
       * @returns {Error} The error.
       */
      module.exports = function enhanceError(
        error,
        config,
        code,
        request,
        response
      ) {
        error.config = config;
        if (code) {
          error.code = code;
        }

        error.request = request;
        error.response = response;
        error.isAxiosError = true;

        error.toJSON = function toJSON() {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: this.config,
            code: this.code,
          };
        };
        return error;
      };

      /***/
    },

    /***/ 7185: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);

      /**
       * Config-specific merge-function which creates a new config-object
       * by merging two configuration objects together.
       *
       * @param {Object} config1
       * @param {Object} config2
       * @returns {Object} New object resulting from merging config2 to config1
       */
      module.exports = function mergeConfig(config1, config2) {
        // eslint-disable-next-line no-param-reassign
        config2 = config2 || {};
        var config = {};

        var valueFromConfig2Keys = ["url", "method", "data"];
        var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
        var defaultToConfig2Keys = [
          "baseURL",
          "transformRequest",
          "transformResponse",
          "paramsSerializer",
          "timeout",
          "timeoutMessage",
          "withCredentials",
          "adapter",
          "responseType",
          "xsrfCookieName",
          "xsrfHeaderName",
          "onUploadProgress",
          "onDownloadProgress",
          "decompress",
          "maxContentLength",
          "maxBodyLength",
          "maxRedirects",
          "transport",
          "httpAgent",
          "httpsAgent",
          "cancelToken",
          "socketPath",
          "responseEncoding",
        ];
        var directMergeKeys = ["validateStatus"];

        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }

        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(config1[prop], config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            config[prop] = getMergedValue(undefined, config1[prop]);
          }
        }

        utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(undefined, config2[prop]);
          }
        });

        utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

        utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(undefined, config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            config[prop] = getMergedValue(undefined, config1[prop]);
          }
        });

        utils.forEach(directMergeKeys, function merge(prop) {
          if (prop in config2) {
            config[prop] = getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            config[prop] = getMergedValue(undefined, config1[prop]);
          }
        });

        var axiosKeys = valueFromConfig2Keys
          .concat(mergeDeepPropertiesKeys)
          .concat(defaultToConfig2Keys)
          .concat(directMergeKeys);

        var otherKeys = Object.keys(config1)
          .concat(Object.keys(config2))
          .filter(function filterAxiosKeys(key) {
            return axiosKeys.indexOf(key) === -1;
          });

        utils.forEach(otherKeys, mergeDeepProperties);

        return config;
      };

      /***/
    },

    /***/ 6026: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var createError = __webpack_require__(5061);

      /**
       * Resolve or reject a Promise based on response status.
       *
       * @param {Function} resolve A function that resolves the promise.
       * @param {Function} reject A function that rejects the promise.
       * @param {object} response The response.
       */
      module.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (
          !response.status ||
          !validateStatus ||
          validateStatus(response.status)
        ) {
          resolve(response);
        } else {
          reject(
            createError(
              "Request failed with status code " + response.status,
              response.config,
              null,
              response.request,
              response
            )
          );
        }
      };

      /***/
    },

    /***/ 8527: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);

      /**
       * Transform the data for a request or a response
       *
       * @param {Object|String} data The data to be transformed
       * @param {Array} headers The headers for the request or response
       * @param {Array|Function} fns A single function or Array of functions
       * @returns {*} The resulting transformed data
       */
      module.exports = function transformData(data, headers, fns) {
        /*eslint no-param-reassign:0*/
        utils.forEach(fns, function transform(fn) {
          data = fn(data, headers);
        });

        return data;
      };

      /***/
    },

    /***/ 5655: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);
      var normalizeHeaderName = __webpack_require__(6016);

      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded",
      };

      function setContentTypeIfUnset(headers, value) {
        if (
          !utils.isUndefined(headers) &&
          utils.isUndefined(headers["Content-Type"])
        ) {
          headers["Content-Type"] = value;
        }
      }

      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          // For browsers use XHR adapter
          adapter = __webpack_require__(5448);
        } else if (
          typeof process !== "undefined" &&
          Object.prototype.toString.call(process) === "[object process]"
        ) {
          // For node use HTTP adapter
          adapter = __webpack_require__(5448);
        }
        return adapter;
      }

      var defaults = {
        adapter: getDefaultAdapter(),

        transformRequest: [
          function transformRequest(data, headers) {
            normalizeHeaderName(headers, "Accept");
            normalizeHeaderName(headers, "Content-Type");
            if (
              utils.isFormData(data) ||
              utils.isArrayBuffer(data) ||
              utils.isBuffer(data) ||
              utils.isStream(data) ||
              utils.isFile(data) ||
              utils.isBlob(data)
            ) {
              return data;
            }
            if (utils.isArrayBufferView(data)) {
              return data.buffer;
            }
            if (utils.isURLSearchParams(data)) {
              setContentTypeIfUnset(
                headers,
                "application/x-www-form-urlencoded;charset=utf-8"
              );
              return data.toString();
            }
            if (utils.isObject(data)) {
              setContentTypeIfUnset(headers, "application/json;charset=utf-8");
              return JSON.stringify(data);
            }
            return data;
          },
        ],

        transformResponse: [
          function transformResponse(data) {
            /*eslint no-param-reassign:0*/
            if (typeof data === "string") {
              try {
                data = JSON.parse(data);
              } catch (e) {
                /* Ignore */
              }
            }
            return data;
          },
        ],

        /**
         * A timeout in milliseconds to abort a request. If set to 0 (default) a
         * timeout is not created.
         */
        timeout: 0,

        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",

        maxContentLength: -1,
        maxBodyLength: -1,

        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
      };

      defaults.headers = {
        common: {
          Accept: "application/json, text/plain, */*",
        },
      };

      utils.forEach(
        ["delete", "get", "head"],
        function forEachMethodNoData(method) {
          defaults.headers[method] = {};
        }
      );

      utils.forEach(
        ["post", "put", "patch"],
        function forEachMethodWithData(method) {
          defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
        }
      );

      module.exports = defaults;

      /***/
    },

    /***/ 1849: /***/ (module) => {
      "use strict";

      module.exports = function bind(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          return fn.apply(thisArg, args);
        };
      };

      /***/
    },

    /***/ 5327: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);

      function encode(val) {
        return encodeURIComponent(val)
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",")
          .replace(/%20/g, "+")
          .replace(/%5B/gi, "[")
          .replace(/%5D/gi, "]");
      }

      /**
       * Build a URL by appending params to the end
       *
       * @param {string} url The base of the url (e.g., http://www.google.com)
       * @param {object} [params] The params to be appended
       * @returns {string} The formatted url
       */
      module.exports = function buildURL(url, params, paramsSerializer) {
        /*eslint no-param-reassign:0*/
        if (!params) {
          return url;
        }

        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];

          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }

            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }

            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode(key) + "=" + encode(v));
            });
          });

          serializedParams = parts.join("&");
        }

        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }

          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }

        return url;
      };

      /***/
    },

    /***/ 7303: /***/ (module) => {
      "use strict";

      /**
       * Creates a new URL by combining the specified URLs
       *
       * @param {string} baseURL The base URL
       * @param {string} relativeURL The relative URL
       * @returns {string} The combined URL
       */
      module.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL
          ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "")
          : baseURL;
      };

      /***/
    },

    /***/ 4372: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);

      module.exports = utils.isStandardBrowserEnv()
        ? // Standard browser envs support document.cookie
          (function standardBrowserEnv() {
            return {
              write: function write(
                name,
                value,
                expires,
                path,
                domain,
                secure
              ) {
                var cookie = [];
                cookie.push(name + "=" + encodeURIComponent(value));

                if (utils.isNumber(expires)) {
                  cookie.push("expires=" + new Date(expires).toGMTString());
                }

                if (utils.isString(path)) {
                  cookie.push("path=" + path);
                }

                if (utils.isString(domain)) {
                  cookie.push("domain=" + domain);
                }

                if (secure === true) {
                  cookie.push("secure");
                }

                document.cookie = cookie.join("; ");
              },

              read: function read(name) {
                var match = document.cookie.match(
                  new RegExp("(^|;\\s*)(" + name + ")=([^;]*)")
                );
                return match ? decodeURIComponent(match[3]) : null;
              },

              remove: function remove(name) {
                this.write(name, "", Date.now() - 86400000);
              },
            };
          })()
        : // Non standard browser env (web workers, react-native) lack needed support.
          (function nonStandardBrowserEnv() {
            return {
              write: function write() {},
              read: function read() {
                return null;
              },
              remove: function remove() {},
            };
          })();

      /***/
    },

    /***/ 1793: /***/ (module) => {
      "use strict";

      /**
       * Determines whether the specified URL is absolute
       *
       * @param {string} url The URL to test
       * @returns {boolean} True if the specified URL is absolute, otherwise false
       */
      module.exports = function isAbsoluteURL(url) {
        // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
        // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
        // by any combination of letters, digits, plus, period, or hyphen.
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
      };

      /***/
    },

    /***/ 6268: /***/ (module) => {
      "use strict";

      /**
       * Determines whether the payload is an error thrown by Axios
       *
       * @param {*} payload The value to test
       * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
       */
      module.exports = function isAxiosError(payload) {
        return typeof payload === "object" && payload.isAxiosError === true;
      };

      /***/
    },

    /***/ 7985: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);

      module.exports = utils.isStandardBrowserEnv()
        ? // Standard browser envs have full support of the APIs needed to test
          // whether the request URL is of the same origin as current location.
          (function standardBrowserEnv() {
            var msie = /(msie|trident)/i.test(navigator.userAgent);
            var urlParsingNode = document.createElement("a");
            var originURL;

            /**
             * Parse a URL to discover it's components
             *
             * @param {String} url The URL to be parsed
             * @returns {Object}
             */
            function resolveURL(url) {
              var href = url;

              if (msie) {
                // IE needs attribute set twice to normalize properties
                urlParsingNode.setAttribute("href", href);
                href = urlParsingNode.href;
              }

              urlParsingNode.setAttribute("href", href);

              // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
              return {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol
                  ? urlParsingNode.protocol.replace(/:$/, "")
                  : "",
                host: urlParsingNode.host,
                search: urlParsingNode.search
                  ? urlParsingNode.search.replace(/^\?/, "")
                  : "",
                hash: urlParsingNode.hash
                  ? urlParsingNode.hash.replace(/^#/, "")
                  : "",
                hostname: urlParsingNode.hostname,
                port: urlParsingNode.port,
                pathname:
                  urlParsingNode.pathname.charAt(0) === "/"
                    ? urlParsingNode.pathname
                    : "/" + urlParsingNode.pathname,
              };
            }

            originURL = resolveURL(window.location.href);

            /**
             * Determine if a URL shares the same origin as the current location
             *
             * @param {String} requestURL The URL to test
             * @returns {boolean} True if URL shares the same origin, otherwise false
             */
            return function isURLSameOrigin(requestURL) {
              var parsed = utils.isString(requestURL)
                ? resolveURL(requestURL)
                : requestURL;
              return (
                parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host
              );
            };
          })()
        : // Non standard browser envs (web workers, react-native) lack needed support.
          (function nonStandardBrowserEnv() {
            return function isURLSameOrigin() {
              return true;
            };
          })();

      /***/
    },

    /***/ 6016: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);

      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          if (
            name !== normalizedName &&
            name.toUpperCase() === normalizedName.toUpperCase()
          ) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };

      /***/
    },

    /***/ 4109: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var utils = __webpack_require__(4867);

      // Headers whose duplicates are ignored by node
      // c.f. https://nodejs.org/api/http.html#http_message_headers
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent",
      ];

      /**
       * Parse headers into an object
       *
       * ```
       * Date: Wed, 27 Aug 2014 08:58:49 GMT
       * Content-Type: application/json
       * Connection: keep-alive
       * Transfer-Encoding: chunked
       * ```
       *
       * @param {String} headers Headers needing to be parsed
       * @returns {Object} Headers parsed into an object
       */
      module.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;

        if (!headers) {
          return parsed;
        }

        utils.forEach(headers.split("\n"), function parser(line) {
          i = line.indexOf(":");
          key = utils.trim(line.substr(0, i)).toLowerCase();
          val = utils.trim(line.substr(i + 1));

          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });

        return parsed;
      };

      /***/
    },

    /***/ 8713: /***/ (module) => {
      "use strict";

      /**
       * Syntactic sugar for invoking a function and expanding an array for arguments.
       *
       * Common use case would be to use `Function.prototype.apply`.
       *
       *  ```js
       *  function f(x, y, z) {}
       *  var args = [1, 2, 3];
       *  f.apply(null, args);
       *  ```
       *
       * With `spread` this example can be re-written.
       *
       *  ```js
       *  spread(function(x, y, z) {})([1, 2, 3]);
       *  ```
       *
       * @param {Function} callback
       * @returns {Function}
       */
      module.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };

      /***/
    },

    /***/ 4867: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var bind = __webpack_require__(1849);

      /*global toString:true*/

      // utils is a library of generic helper functions non-specific to axios

      var toString = Object.prototype.toString;

      /**
       * Determine if a value is an Array
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an Array, otherwise false
       */
      function isArray(val) {
        return toString.call(val) === "[object Array]";
      }

      /**
       * Determine if a value is undefined
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if the value is undefined, otherwise false
       */
      function isUndefined(val) {
        return typeof val === "undefined";
      }

      /**
       * Determine if a value is a Buffer
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Buffer, otherwise false
       */
      function isBuffer(val) {
        return (
          val !== null &&
          !isUndefined(val) &&
          val.constructor !== null &&
          !isUndefined(val.constructor) &&
          typeof val.constructor.isBuffer === "function" &&
          val.constructor.isBuffer(val)
        );
      }

      /**
       * Determine if a value is an ArrayBuffer
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an ArrayBuffer, otherwise false
       */
      function isArrayBuffer(val) {
        return toString.call(val) === "[object ArrayBuffer]";
      }

      /**
       * Determine if a value is a FormData
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an FormData, otherwise false
       */
      function isFormData(val) {
        return typeof FormData !== "undefined" && val instanceof FormData;
      }

      /**
       * Determine if a value is a view on an ArrayBuffer
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
       */
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && val.buffer instanceof ArrayBuffer;
        }
        return result;
      }

      /**
       * Determine if a value is a String
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a String, otherwise false
       */
      function isString(val) {
        return typeof val === "string";
      }

      /**
       * Determine if a value is a Number
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Number, otherwise false
       */
      function isNumber(val) {
        return typeof val === "number";
      }

      /**
       * Determine if a value is an Object
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an Object, otherwise false
       */
      function isObject(val) {
        return val !== null && typeof val === "object";
      }

      /**
       * Determine if a value is a plain Object
       *
       * @param {Object} val The value to test
       * @return {boolean} True if value is a plain Object, otherwise false
       */
      function isPlainObject(val) {
        if (toString.call(val) !== "[object Object]") {
          return false;
        }

        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }

      /**
       * Determine if a value is a Date
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Date, otherwise false
       */
      function isDate(val) {
        return toString.call(val) === "[object Date]";
      }

      /**
       * Determine if a value is a File
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a File, otherwise false
       */
      function isFile(val) {
        return toString.call(val) === "[object File]";
      }

      /**
       * Determine if a value is a Blob
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Blob, otherwise false
       */
      function isBlob(val) {
        return toString.call(val) === "[object Blob]";
      }

      /**
       * Determine if a value is a Function
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Function, otherwise false
       */
      function isFunction(val) {
        return toString.call(val) === "[object Function]";
      }

      /**
       * Determine if a value is a Stream
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Stream, otherwise false
       */
      function isStream(val) {
        return isObject(val) && isFunction(val.pipe);
      }

      /**
       * Determine if a value is a URLSearchParams object
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a URLSearchParams object, otherwise false
       */
      function isURLSearchParams(val) {
        return (
          typeof URLSearchParams !== "undefined" &&
          val instanceof URLSearchParams
        );
      }

      /**
       * Trim excess whitespace off the beginning and end of a string
       *
       * @param {String} str The String to trim
       * @returns {String} The String freed of excess whitespace
       */
      function trim(str) {
        return str.replace(/^\s*/, "").replace(/\s*$/, "");
      }

      /**
       * Determine if we're running in a standard browser environment
       *
       * This allows axios to run in a web worker, and react-native.
       * Both environments support XMLHttpRequest, but not fully standard globals.
       *
       * web workers:
       *  typeof window -> undefined
       *  typeof document -> undefined
       *
       * react-native:
       *  navigator.product -> 'ReactNative'
       * nativescript
       *  navigator.product -> 'NativeScript' or 'NS'
       */
      function isStandardBrowserEnv() {
        if (
          typeof navigator !== "undefined" &&
          (navigator.product === "ReactNative" ||
            navigator.product === "NativeScript" ||
            navigator.product === "NS")
        ) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }

      /**
       * Iterate over an Array or an Object invoking a function for each item.
       *
       * If `obj` is an Array callback will be called passing
       * the value, index, and complete array for each item.
       *
       * If 'obj' is an Object callback will be called passing
       * the value, key, and complete object for each property.
       *
       * @param {Object|Array} obj The object to iterate
       * @param {Function} fn The callback to invoke for each item
       */
      function forEach(obj, fn) {
        // Don't bother if no value provided
        if (obj === null || typeof obj === "undefined") {
          return;
        }

        // Force an array if not already something iterable
        if (typeof obj !== "object") {
          /*eslint no-param-reassign:0*/
          obj = [obj];
        }

        if (isArray(obj)) {
          // Iterate over array values
          for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          // Iterate over object keys
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }

      /**
       * Accepts varargs expecting each argument to be an object, then
       * immutably merges the properties of each object and returns result.
       *
       * When multiple objects contain the same key the later object in
       * the arguments list will take precedence.
       *
       * Example:
       *
       * ```js
       * var result = merge({foo: 123}, {foo: 456});
       * console.log(result.foo); // outputs 456
       * ```
       *
       * @param {Object} obj1 Object to merge
       * @returns {Object} Result of all merge properties
       */
      function merge(/* obj1, obj2, obj3, ... */) {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject(result[key]) && isPlainObject(val)) {
            result[key] = merge(result[key], val);
          } else if (isPlainObject(val)) {
            result[key] = merge({}, val);
          } else if (isArray(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }

        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }

      /**
       * Extends object a by mutably adding to it the properties of object b.
       *
       * @param {Object} a The object to be extended
       * @param {Object} b The object to copy properties from
       * @param {Object} thisArg The object to bind function to
       * @return {Object} The resulting value of object a
       */
      function extend(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        });
        return a;
      }

      /**
       * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
       *
       * @param {string} content with BOM
       * @return {string} content value without BOM
       */
      function stripBOM(content) {
        if (content.charCodeAt(0) === 0xfeff) {
          content = content.slice(1);
        }
        return content;
      }

      module.exports = {
        isArray: isArray,
        isArrayBuffer: isArrayBuffer,
        isBuffer: isBuffer,
        isFormData: isFormData,
        isArrayBufferView: isArrayBufferView,
        isString: isString,
        isNumber: isNumber,
        isObject: isObject,
        isPlainObject: isPlainObject,
        isUndefined: isUndefined,
        isDate: isDate,
        isFile: isFile,
        isBlob: isBlob,
        isFunction: isFunction,
        isStream: isStream,
        isURLSearchParams: isURLSearchParams,
        isStandardBrowserEnv: isStandardBrowserEnv,
        forEach: forEach,
        merge: merge,
        extend: extend,
        trim: trim,
        stripBOM: stripBOM,
      };

      /***/
    },

    /***/ 556: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      const { encodeText } = __webpack_require__(2413);

      /** @typedef {import('./types').CodecFactory} CodecFactory */
      /** @typedef {import("./types").BaseName} BaseName */
      /** @typedef {import("./types").BaseCode} BaseCode */

      /**
       * Class to encode/decode in the supported Bases
       *
       */
      class Base {
        /**
         * @param {BaseName} name
         * @param {BaseCode} code
         * @param {CodecFactory} factory
         * @param {string} alphabet
         */
        constructor(name, code, factory, alphabet) {
          this.name = name;
          this.code = code;
          this.codeBuf = encodeText(this.code);
          this.alphabet = alphabet;
          this.codec = factory(alphabet);
        }

        /**
         * @param {Uint8Array} buf
         * @returns {string}
         */
        encode(buf) {
          return this.codec.encode(buf);
        }

        /**
         * @param {string} string
         * @returns {Uint8Array}
         */
        decode(string) {
          for (const char of string) {
            if (this.alphabet && this.alphabet.indexOf(char) < 0) {
              throw new Error(`invalid character '${char}' in '${string}'`);
            }
          }
          return this.codec.decode(string);
        }
      }

      module.exports = Base;

      /***/
    },

    /***/ 5077: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      const baseX = __webpack_require__(8820);
      const Base = __webpack_require__(556);
      const { rfc4648 } = __webpack_require__(6727);
      const { decodeText, encodeText } = __webpack_require__(2413);

      /** @typedef {import('./types').CodecFactory} CodecFactory */
      /** @typedef {import('./types').Codec} Codec */
      /** @typedef {import('./types').BaseName} BaseName */
      /** @typedef {import('./types').BaseCode} BaseCode */

      /** @type {CodecFactory} */
      const identity = () => {
        return {
          encode: decodeText,
          decode: encodeText,
        };
      };

      /**
       *
       * name, code, implementation, alphabet
       *
       * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
       */
      const constants = [
        ["identity", "\x00", identity, ""],
        ["base2", "0", rfc4648(1), "01"],
        ["base8", "7", rfc4648(3), "01234567"],
        ["base10", "9", baseX, "0123456789"],
        ["base16", "f", rfc4648(4), "0123456789abcdef"],
        ["base16upper", "F", rfc4648(4), "0123456789ABCDEF"],
        ["base32hex", "v", rfc4648(5), "0123456789abcdefghijklmnopqrstuv"],
        ["base32hexupper", "V", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
        ["base32hexpad", "t", rfc4648(5), "0123456789abcdefghijklmnopqrstuv="],
        [
          "base32hexpadupper",
          "T",
          rfc4648(5),
          "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        ],
        ["base32", "b", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567"],
        ["base32upper", "B", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
        ["base32pad", "c", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567="],
        [
          "base32padupper",
          "C",
          rfc4648(5),
          "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        ],
        ["base32z", "h", rfc4648(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
        ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
        ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
        [
          "base58btc",
          "z",
          baseX,
          "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        ],
        [
          "base58flickr",
          "Z",
          baseX,
          "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
        ],
        [
          "base64",
          "m",
          rfc4648(6),
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        ],
        [
          "base64pad",
          "M",
          rfc4648(6),
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        ],
        [
          "base64url",
          "u",
          rfc4648(6),
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        ],
        [
          "base64urlpad",
          "U",
          rfc4648(6),
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        ],
      ];

      /** @type {Record<BaseName,Base>} */
      const names = constants.reduce((prev, tupple) => {
        prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
        return prev;
      }, /** @type {Record<BaseName,Base>} */ ({}));

      /** @type {Record<BaseCode,Base>} */
      const codes = constants.reduce((prev, tupple) => {
        prev[tupple[1]] = names[tupple[0]];
        return prev;
      }, /** @type {Record<BaseCode,Base>} */ ({}));

      module.exports = {
        names,
        codes,
      };

      /***/
    },

    /***/ 6957: /***/ (module, exports, __webpack_require__) => {
      "use strict";
      /**
       * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
       *
       */

      const constants = __webpack_require__(5077);
      const { encodeText, decodeText, concat } = __webpack_require__(2413);

      /** @typedef {import('./base')} Base */
      /** @typedef {import("./types").BaseNameOrCode} BaseNameOrCode */
      /** @typedef {import("./types").BaseCode} BaseCode */
      /** @typedef {import("./types").BaseName} BaseName */

      /**
       * Create a new Uint8Array with the multibase varint+code.
       *
       * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
       * @param {Uint8Array} buf - The data to be prefixed with multibase.
       * @returns {Uint8Array}
       * @throws {Error} Will throw if the encoding is not supported
       */
      function multibase(nameOrCode, buf) {
        if (!buf) {
          throw new Error("requires an encoded Uint8Array");
        }
        const { name, codeBuf } = encoding(nameOrCode);
        validEncode(name, buf);

        return concat([codeBuf, buf], codeBuf.length + buf.length);
      }

      /**
       * Encode data with the specified base and add the multibase prefix.
       *
       * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
       * @param {Uint8Array} buf - The data to be encoded.
       * @returns {Uint8Array}
       * @throws {Error} Will throw if the encoding is not supported
       *
       */
      function encode(nameOrCode, buf) {
        const enc = encoding(nameOrCode);
        const data = encodeText(enc.encode(buf));

        return concat([enc.codeBuf, data], enc.codeBuf.length + data.length);
      }

      /**
       * Takes a Uint8Array or string encoded with multibase header, decodes it and
       * returns the decoded buffer
       *
       * @param {Uint8Array|string} data
       * @returns {Uint8Array}
       * @throws {Error} Will throw if the encoding is not supported
       *
       */
      function decode(data) {
        if (data instanceof Uint8Array) {
          data = decodeText(data);
        }
        const prefix = data[0];

        // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
        if (
          [
            "f",
            "F",
            "v",
            "V",
            "t",
            "T",
            "b",
            "B",
            "c",
            "C",
            "h",
            "k",
            "K",
          ].includes(prefix)
        ) {
          data = data.toLowerCase();
        }
        const enc = encoding(/** @type {BaseCode} */ (data[0]));
        return enc.decode(data.substring(1));
      }

      /**
       * Is the given data multibase encoded?
       *
       * @param {Uint8Array|string} data
       */
      function isEncoded(data) {
        if (data instanceof Uint8Array) {
          data = decodeText(data);
        }

        // Ensure bufOrString is a string
        if (Object.prototype.toString.call(data) !== "[object String]") {
          return false;
        }

        try {
          const enc = encoding(/** @type {BaseCode} */ (data[0]));
          return enc.name;
        } catch (err) {
          return false;
        }
      }

      /**
       * Validate encoded data
       *
       * @param {BaseNameOrCode} name
       * @param {Uint8Array} buf
       * @returns {void}
       * @throws {Error} Will throw if the encoding is not supported
       */
      function validEncode(name, buf) {
        const enc = encoding(name);
        enc.decode(decodeText(buf));
      }

      /**
       * Get the encoding by name or code
       *
       * @param {BaseNameOrCode} nameOrCode
       * @returns {Base}
       * @throws {Error} Will throw if the encoding is not supported
       */
      function encoding(nameOrCode) {
        if (
          Object.prototype.hasOwnProperty.call(
            constants.names,
            /** @type {BaseName} */ (nameOrCode)
          )
        ) {
          return constants.names[/** @type {BaseName} */ (nameOrCode)];
        } else if (
          Object.prototype.hasOwnProperty.call(
            constants.codes,
            /** @type {BaseCode} */ (nameOrCode)
          )
        ) {
          return constants.codes[/** @type {BaseCode} */ (nameOrCode)];
        } else {
          throw new Error(`Unsupported encoding: ${nameOrCode}`);
        }
      }

      /**
       * Get encoding from data
       *
       * @param {string|Uint8Array} data
       * @returns {Base}
       * @throws {Error} Will throw if the encoding is not supported
       */
      function encodingFromData(data) {
        if (data instanceof Uint8Array) {
          data = decodeText(data);
        }

        return encoding(/** @type {BaseCode} */ (data[0]));
      }

      exports = module.exports = multibase;
      exports.encode = encode;
      exports.decode = decode;
      exports.isEncoded = isEncoded;
      exports.encoding = encoding;
      exports.encodingFromData = encodingFromData;
      const names = Object.freeze(constants.names);
      const codes = Object.freeze(constants.codes);
      exports.names = names;
      exports.codes = codes;

      /***/
    },

    /***/ 6727: /***/ (module) => {
      "use strict";

      /** @typedef {import('./types').CodecFactory} CodecFactory */

      /**
       * @param {string} string
       * @param {string} alphabet
       * @param {number} bitsPerChar
       * @returns {Uint8Array}
       */
      const decode = (string, alphabet, bitsPerChar) => {
        // Build the character lookup table:
        /** @type {Record<string, number>} */
        const codes = {};
        for (let i = 0; i < alphabet.length; ++i) {
          codes[alphabet[i]] = i;
        }

        // Count the padding bytes:
        let end = string.length;
        while (string[end - 1] === "=") {
          --end;
        }

        // Allocate the output:
        const out = new Uint8Array(((end * bitsPerChar) / 8) | 0);

        // Parse the data:
        let bits = 0; // Number of bits currently in the buffer
        let buffer = 0; // Bits waiting to be written out, MSB first
        let written = 0; // Next byte to write
        for (let i = 0; i < end; ++i) {
          // Read one character from the string:
          const value = codes[string[i]];
          if (value === undefined) {
            throw new SyntaxError("Invalid character " + string[i]);
          }

          // Append the bits to the buffer:
          buffer = (buffer << bitsPerChar) | value;
          bits += bitsPerChar;

          // Write out some bits if the buffer has a byte's worth:
          if (bits >= 8) {
            bits -= 8;
            out[written++] = 0xff & (buffer >> bits);
          }
        }

        // Verify that we have received just enough bits:
        if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
          throw new SyntaxError("Unexpected end of data");
        }

        return out;
      };

      /**
       * @param {Uint8Array} data
       * @param {string} alphabet
       * @param {number} bitsPerChar
       * @returns {string}
       */
      const encode = (data, alphabet, bitsPerChar) => {
        const pad = alphabet[alphabet.length - 1] === "=";
        const mask = (1 << bitsPerChar) - 1;
        let out = "";

        let bits = 0; // Number of bits currently in the buffer
        let buffer = 0; // Bits waiting to be written out, MSB first
        for (let i = 0; i < data.length; ++i) {
          // Slurp data into the buffer:
          buffer = (buffer << 8) | data[i];
          bits += 8;

          // Write out as much as we can:
          while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet[mask & (buffer >> bits)];
          }
        }

        // Partial character:
        if (bits) {
          out += alphabet[mask & (buffer << (bitsPerChar - bits))];
        }

        // Add padding characters until we hit a byte boundary:
        if (pad) {
          while ((out.length * bitsPerChar) & 7) {
            out += "=";
          }
        }

        return out;
      };

      /**
       * RFC4648 Factory
       *
       * @param {number} bitsPerChar
       * @returns {CodecFactory}
       */
      const rfc4648 = (bitsPerChar) => (alphabet) => {
        return {
          /**
           * @param {Uint8Array} input
           * @returns {string}
           */
          encode(input) {
            return encode(input, alphabet, bitsPerChar);
          },
          /**
           * @param {string} input
           * @returns {Uint8Array}
           */
          decode(input) {
            return decode(input, alphabet, bitsPerChar);
          },
        };
      };

      module.exports = { rfc4648 };

      /***/
    },

    /***/ 2413: /***/ (module) => {
      "use strict";

      const textDecoder = new TextDecoder();
      /**
       * @param {ArrayBufferView|ArrayBuffer} bytes
       * @returns {string}
       */
      const decodeText = (bytes) => textDecoder.decode(bytes);

      const textEncoder = new TextEncoder();
      /**
       * @param {string} text
       * @returns {Uint8Array}
       */
      const encodeText = (text) => textEncoder.encode(text);

      /**
       * Returns a new Uint8Array created by concatenating the passed Arrays
       *
       * @param {Array<ArrayLike<number>>} arrs
       * @param {number} length
       * @returns {Uint8Array}
       */
      function concat(arrs, length) {
        const output = new Uint8Array(length);
        let offset = 0;

        for (const arr of arrs) {
          output.set(arr, offset);
          offset += arr.length;
        }

        return output;
      }

      module.exports = { decodeText, encodeText, concat };

      /***/
    },

    /***/ 4492: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";
      // light library entry point.

      module.exports = __webpack_require__(8836);

      /***/
    },

    /***/ 3996: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      /**
       * Runtime message from/to plain object converters.
       * @namespace
       */
      var converter = exports;

      var Enum = __webpack_require__(7025),
        util = __webpack_require__(9935);

      /**
       * Generates a partial value fromObject conveter.
       * @param {Codegen} gen Codegen instance
       * @param {Field} field Reflected field
       * @param {number} fieldIndex Field index
       * @param {string} prop Property reference
       * @returns {Codegen} Codegen instance
       * @ignore
       */
      function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
        /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
        if (field.resolvedType) {
          if (field.resolvedType instanceof Enum) {
            gen("switch(d%s){", prop);
            for (
              var values = field.resolvedType.values,
                keys = Object.keys(values),
                i = 0;
              i < keys.length;
              ++i
            ) {
              if (field.repeated && values[keys[i]] === field.typeDefault)
                gen("default:");
              gen("case%j:", keys[i])("case %i:", values[keys[i]])(
                "m%s=%j",
                prop,
                values[keys[i]]
              )("break");
            }
            gen("}");
          } else
            gen('if(typeof d%s!=="object")', prop)(
              "throw TypeError(%j)",
              field.fullName + ": object expected"
            )("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
        } else {
          var isUnsigned = false;
          switch (field.type) {
            case "double":
            case "float":
              gen("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
              break;
            case "uint32":
            case "fixed32":
              gen("m%s=d%s>>>0", prop, prop);
              break;
            case "int32":
            case "sint32":
            case "sfixed32":
              gen("m%s=d%s|0", prop, prop);
              break;
            case "uint64":
              isUnsigned = true;
            // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
              gen("if(util.Long)")(
                "(m%s=util.Long.fromValue(d%s)).unsigned=%j",
                prop,
                prop,
                isUnsigned
              )('else if(typeof d%s==="string")', prop)(
                "m%s=parseInt(d%s,10)",
                prop,
                prop
              )('else if(typeof d%s==="number")', prop)(
                "m%s=d%s",
                prop,
                prop
              )('else if(typeof d%s==="object")', prop)(
                "m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)",
                prop,
                prop,
                prop,
                isUnsigned ? "true" : ""
              );
              break;
            case "bytes":
              gen('if(typeof d%s==="string")', prop)(
                "util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)",
                prop,
                prop,
                prop
              )("else if(d%s.length)", prop)("m%s=d%s", prop, prop);
              break;
            case "string":
              gen("m%s=String(d%s)", prop, prop);
              break;
            case "bool":
              gen("m%s=Boolean(d%s)", prop, prop);
              break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
          }
        }
        return gen;
        /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
      }

      /**
       * Generates a plain object to runtime message converter specific to the specified message type.
       * @param {Type} mtype Message type
       * @returns {Codegen} Codegen instance
       */
      converter.fromObject = function fromObject(mtype) {
        /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
        var fields = mtype.fieldsArray;
        var gen = util.codegen(
          ["d"],
          mtype.name + "$fromObject"
        )("if(d instanceof this.ctor)")("return d");
        if (!fields.length) return gen("return new this.ctor");
        gen("var m=new this.ctor");
        for (var i = 0; i < fields.length; ++i) {
          var field = fields[i].resolve(),
            prop = util.safeProp(field.name);

          // Map fields
          if (field.map) {
            gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)(
              "throw TypeError(%j)",
              field.fullName + ": object expected"
            )("m%s={}", prop)(
              "for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){",
              prop
            );
            genValuePartial_fromObject(
              gen,
              field,
              /* not sorted */ i,
              prop + "[ks[i]]"
            )("}")("}");

            // Repeated fields
          } else if (field.repeated) {
            gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)(
              "throw TypeError(%j)",
              field.fullName + ": array expected"
            )("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(
              gen,
              field,
              /* not sorted */ i,
              prop + "[i]"
            )("}")("}");

            // Non-repeated fields
          } else {
            if (!(field.resolvedType instanceof Enum))
              gen(
                // no need to test for null/undefined if an enum (uses switch)
                "if(d%s!=null){",
                prop
              ); // !== undefined && !== null
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen("}");
          }
        }
        return gen("return m");
        /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
      };

      /**
       * Generates a partial value toObject converter.
       * @param {Codegen} gen Codegen instance
       * @param {Field} field Reflected field
       * @param {number} fieldIndex Field index
       * @param {string} prop Property reference
       * @returns {Codegen} Codegen instance
       * @ignore
       */
      function genValuePartial_toObject(gen, field, fieldIndex, prop) {
        /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
        if (field.resolvedType) {
          if (field.resolvedType instanceof Enum)
            gen(
              "d%s=o.enums===String?types[%i].values[m%s]:m%s",
              prop,
              fieldIndex,
              prop,
              prop
            );
          else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
        } else {
          var isUnsigned = false;
          switch (field.type) {
            case "double":
            case "float":
              gen(
                "d%s=o.json&&!isFinite(m%s)?String(m%s):m%s",
                prop,
                prop,
                prop,
                prop
              );
              break;
            case "uint64":
              isUnsigned = true;
            // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
              gen('if(typeof m%s==="number")', prop)(
                "d%s=o.longs===String?String(m%s):m%s",
                prop,
                prop,
                prop
              )("else")(
                // Long-like
                "d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s",
                prop,
                prop,
                prop,
                prop,
                isUnsigned ? "true" : "",
                prop
              );
              break;
            case "bytes":
              gen(
                "d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s",
                prop,
                prop,
                prop,
                prop,
                prop
              );
              break;
            default:
              gen("d%s=m%s", prop, prop);
              break;
          }
        }
        return gen;
        /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
      }

      /**
       * Generates a runtime message to plain object converter specific to the specified message type.
       * @param {Type} mtype Message type
       * @returns {Codegen} Codegen instance
       */
      converter.toObject = function toObject(mtype) {
        /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
        var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
        if (!fields.length) return util.codegen()("return {}");
        var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")(
          "o={}"
        )("var d={}");

        var repeatedFields = [],
          mapFields = [],
          normalFields = [],
          i = 0;
        for (; i < fields.length; ++i)
          if (!fields[i].partOf)
            (fields[i].resolve().repeated
              ? repeatedFields
              : fields[i].map
              ? mapFields
              : normalFields
            ).push(fields[i]);

        if (repeatedFields.length) {
          gen("if(o.arrays||o.defaults){");
          for (i = 0; i < repeatedFields.length; ++i)
            gen("d%s=[]", util.safeProp(repeatedFields[i].name));
          gen("}");
        }

        if (mapFields.length) {
          gen("if(o.objects||o.defaults){");
          for (i = 0; i < mapFields.length; ++i)
            gen("d%s={}", util.safeProp(mapFields[i].name));
          gen("}");
        }

        if (normalFields.length) {
          gen("if(o.defaults){");
          for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
              prop = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum)
              gen(
                "d%s=o.enums===String?%j:%j",
                prop,
                field.resolvedType.valuesById[field.typeDefault],
                field.typeDefault
              );
            else if (field.long)
              gen("if(util.Long){")(
                "var n=new util.Long(%i,%i,%j)",
                field.typeDefault.low,
                field.typeDefault.high,
                field.typeDefault.unsigned
              )(
                "d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n",
                prop
              )("}else")(
                "d%s=o.longs===String?%j:%i",
                prop,
                field.typeDefault.toString(),
                field.typeDefault.toNumber()
              );
            else if (field.bytes) {
              var arrayDefault =
                "[" +
                Array.prototype.slice.call(field.typeDefault).join(",") +
                "]";
              gen(
                "if(o.bytes===String)d%s=%j",
                prop,
                String.fromCharCode.apply(String, field.typeDefault)
              )("else{")("d%s=%s", prop, arrayDefault)(
                "if(o.bytes!==Array)d%s=util.newBuffer(d%s)",
                prop,
                prop
              )("}");
            } else gen("d%s=%j", prop, field.typeDefault); // also messages (=null)
          }
          gen("}");
        }
        var hasKs2 = false;
        for (i = 0; i < fields.length; ++i) {
          var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop = util.safeProp(field.name);
          if (field.map) {
            if (!hasKs2) {
              hasKs2 = true;
              gen("var ks2");
            }
            gen(
              "if(m%s&&(ks2=Object.keys(m%s)).length){",
              prop,
              prop
            )(
              "d%s={}",
              prop
            )("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(
              gen,
              field,
              /* sorted */ index,
              prop + "[ks2[j]]"
            )("}");
          } else if (field.repeated) {
            gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)(
              "for(var j=0;j<m%s.length;++j){",
              prop
            );
            genValuePartial_toObject(
              gen,
              field,
              /* sorted */ index,
              prop + "[j]"
            )("}");
          } else {
            gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
            genValuePartial_toObject(gen, field, /* sorted */ index, prop);
            if (field.partOf)
              gen("if(o.oneofs)")(
                "d%s=%j",
                util.safeProp(field.partOf.name),
                field.name
              );
          }
          gen("}");
        }
        return gen("return d");
        /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
      };

      /***/
    },

    /***/ 5305: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = decoder;

      var Enum = __webpack_require__(7025),
        types = __webpack_require__(7063),
        util = __webpack_require__(9935);

      function missing(field) {
        return "missing required '" + field.name + "'";
      }

      /**
       * Generates a decoder specific to the specified message type.
       * @param {Type} mtype Message type
       * @returns {Codegen} Codegen instance
       */
      function decoder(mtype) {
        /* eslint-disable no-unexpected-multiline */
        var gen = util.codegen(
          ["r", "l"],
          mtype.name + "$decode"
        )("if(!(r instanceof Reader))")("r=Reader.create(r)")(
          "var c=l===undefined?r.len:r.pos+l,m=new this.ctor" +
            (mtype.fieldsArray.filter(function (field) {
              return field.map;
            }).length
              ? ",k,value"
              : "")
        )("while(r.pos<c){")("var t=r.uint32()");
        if (mtype.group) gen("if((t&7)===4)")("break");
        gen("switch(t>>>3){");

        var i = 0;
        for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
          var field = mtype._fieldsArray[i].resolve(),
            type = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref = "m" + util.safeProp(field.name);
          gen("case %i:", field.id);

          // Map fields
          if (field.map) {
            gen("if(%s===util.emptyObject)", ref)("%s={}", ref)(
              "var c2 = r.uint32()+r.pos"
            );

            if (types.defaults[field.keyType] !== undefined)
              gen("k=%j", types.defaults[field.keyType]);
            else gen("k=null");

            if (types.defaults[type] !== undefined)
              gen("value=%j", types.defaults[type]);
            else gen("value=null");

            gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")(
              "case 1: k=r.%s(); break",
              field.keyType
            )("case 2:");

            if (types.basic[type] === undefined)
              gen("value=types[%i].decode(r,r.uint32())", i);
            // can't be groups
            else gen("value=r.%s()", type);

            gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");

            if (types.long[field.keyType] !== undefined)
              gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
            else gen("%s[k]=value", ref);

            // Repeated fields
          } else if (field.repeated) {
            gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined)
              gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")(
                "while(r.pos<c2)"
              )(
                "%s.push(r.%s())",
                ref,
                type
              )("}else");

            // Non-packed
            if (types.basic[type] === undefined)
              gen(
                field.resolvedType.group
                  ? "%s.push(types[%i].decode(r))"
                  : "%s.push(types[%i].decode(r,r.uint32()))",
                ref,
                i
              );
            else gen("%s.push(r.%s())", ref, type);

            // Non-repeated
          } else if (types.basic[type] === undefined)
            gen(
              field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())",
              ref,
              i
            );
          else gen("%s=r.%s()", ref, type);
          gen("break");
          // Unknown fields
        }
        gen("default:")("r.skipType(t&7)")("break")("}")("}");

        // Field presence
        for (i = 0; i < mtype._fieldsArray.length; ++i) {
          var rfield = mtype._fieldsArray[i];
          if (rfield.required)
            gen("if(!m.hasOwnProperty(%j))", rfield.name)(
              "throw util.ProtocolError(%j,{instance:m})",
              missing(rfield)
            );
        }

        return gen("return m");
        /* eslint-enable no-unexpected-multiline */
      }

      /***/
    },

    /***/ 4928: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = encoder;

      var Enum = __webpack_require__(7025),
        types = __webpack_require__(7063),
        util = __webpack_require__(9935);

      /**
       * Generates a partial message type encoder.
       * @param {Codegen} gen Codegen instance
       * @param {Field} field Reflected field
       * @param {number} fieldIndex Field index
       * @param {string} ref Variable reference
       * @returns {Codegen} Codegen instance
       * @ignore
       */
      function genTypePartial(gen, field, fieldIndex, ref) {
        return field.resolvedType.group
          ? gen(
              "types[%i].encode(%s,w.uint32(%i)).uint32(%i)",
              fieldIndex,
              ref,
              ((field.id << 3) | 3) >>> 0,
              ((field.id << 3) | 4) >>> 0
            )
          : gen(
              "types[%i].encode(%s,w.uint32(%i).fork()).ldelim()",
              fieldIndex,
              ref,
              ((field.id << 3) | 2) >>> 0
            );
      }

      /**
       * Generates an encoder specific to the specified message type.
       * @param {Type} mtype Message type
       * @returns {Codegen} Codegen instance
       */
      function encoder(mtype) {
        /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
        var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")(
          "w=Writer.create()"
        );

        var i, ref;

        // "when a message is serialized its known fields should be written sequentially by field number"
        var fields = /* initializes */ mtype.fieldsArray
          .slice()
          .sort(util.compareFieldsById);

        for (var i = 0; i < fields.length; ++i) {
          var field = fields[i].resolve(),
            index = mtype._fieldsArray.indexOf(field),
            type = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
          ref = "m" + util.safeProp(field.name);

          // Map fields
          if (field.map) {
            gen(
              "if(%s!=null&&Object.hasOwnProperty.call(m,%j)){",
              ref,
              field.name
            )(
              // !== undefined && !== null
              "for(var ks=Object.keys(%s),i=0;i<ks.length;++i){",
              ref
            )(
              "w.uint32(%i).fork().uint32(%i).%s(ks[i])",
              ((field.id << 3) | 2) >>> 0,
              8 | types.mapKey[field.keyType],
              field.keyType
            );
            if (wireType === undefined)
              gen(
                "types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()",
                index,
                ref
              );
            // can't be groups
            else
              gen(
                ".uint32(%i).%s(%s[ks[i]]).ldelim()",
                16 | wireType,
                type,
                ref
              );
            gen("}")("}");

            // Repeated fields
          } else if (field.repeated) {
            gen("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) {
              gen("w.uint32(%i).fork()", ((field.id << 3) | 2) >>> 0)(
                "for(var i=0;i<%s.length;++i)",
                ref
              )(
                "w.%s(%s[i])",
                type,
                ref
              )("w.ldelim()");

              // Non-packed
            } else {
              gen("for(var i=0;i<%s.length;++i)", ref);
              if (wireType === undefined)
                genTypePartial(gen, field, index, ref + "[i]");
              else
                gen(
                  "w.uint32(%i).%s(%s[i])",
                  ((field.id << 3) | wireType) >>> 0,
                  type,
                  ref
                );
            }
            gen("}");

            // Non-repeated
          } else {
            if (field.optional)
              gen(
                "if(%s!=null&&Object.hasOwnProperty.call(m,%j))",
                ref,
                field.name
              ); // !== undefined && !== null

            if (wireType === undefined) genTypePartial(gen, field, index, ref);
            else
              gen(
                "w.uint32(%i).%s(%s)",
                ((field.id << 3) | wireType) >>> 0,
                type,
                ref
              );
          }
        }

        return gen("return w");
        /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
      }

      /***/
    },

    /***/ 7025: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Enum;

      // extends ReflectionObject
      var ReflectionObject = __webpack_require__(3243);
      ((Enum.prototype = Object.create(
        ReflectionObject.prototype
      )).constructor = Enum).className = "Enum";

      var Namespace = __webpack_require__(9313),
        util = __webpack_require__(9935);

      /**
       * Constructs a new enum instance.
       * @classdesc Reflected enum.
       * @extends ReflectionObject
       * @constructor
       * @param {string} name Unique name within its namespace
       * @param {Object.<string,number>} [values] Enum values as an object, by name
       * @param {Object.<string,*>} [options] Declared options
       * @param {string} [comment] The comment for this enum
       * @param {Object.<string,string>} [comments] The value comments for this enum
       */
      function Enum(name, values, options, comment, comments) {
        ReflectionObject.call(this, name, options);

        if (values && typeof values !== "object")
          throw TypeError("values must be an object");

        /**
         * Enum values by id.
         * @type {Object.<number,string>}
         */
        this.valuesById = {};

        /**
         * Enum values by name.
         * @type {Object.<string,number>}
         */
        this.values = Object.create(this.valuesById); // toJSON, marker

        /**
         * Enum comment text.
         * @type {string|null}
         */
        this.comment = comment;

        /**
         * Value comment texts, if any.
         * @type {Object.<string,string>}
         */
        this.comments = comments || {};

        /**
         * Reserved ranges, if any.
         * @type {Array.<number[]|string>}
         */
        this.reserved = undefined; // toJSON

        // Note that values inherit valuesById on their prototype which makes them a TypeScript-
        // compatible enum. This is used by pbts to write actual enum definitions that work for
        // static and reflection code alike instead of emitting generic object definitions.

        if (values)
          for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number")
              // use forward entries only
              this.valuesById[(this.values[keys[i]] = values[keys[i]])] =
                keys[i];
      }

      /**
       * Enum descriptor.
       * @interface IEnum
       * @property {Object.<string,number>} values Enum values
       * @property {Object.<string,*>} [options] Enum options
       */

      /**
       * Constructs an enum from an enum descriptor.
       * @param {string} name Enum name
       * @param {IEnum} json Enum descriptor
       * @returns {Enum} Created enum
       * @throws {TypeError} If arguments are invalid
       */
      Enum.fromJSON = function fromJSON(name, json) {
        var enm = new Enum(
          name,
          json.values,
          json.options,
          json.comment,
          json.comments
        );
        enm.reserved = json.reserved;
        return enm;
      };

      /**
       * Converts this enum to an enum descriptor.
       * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
       * @returns {IEnum} Enum descriptor
       */
      Enum.prototype.toJSON = function toJSON(toJSONOptions) {
        var keepComments = toJSONOptions
          ? Boolean(toJSONOptions.keepComments)
          : false;
        return util.toObject([
          "options",
          this.options,
          "values",
          this.values,
          "reserved",
          this.reserved && this.reserved.length ? this.reserved : undefined,
          "comment",
          keepComments ? this.comment : undefined,
          "comments",
          keepComments ? this.comments : undefined,
        ]);
      };

      /**
       * Adds a value to this enum.
       * @param {string} name Value name
       * @param {number} id Value id
       * @param {string} [comment] Comment, if any
       * @returns {Enum} `this`
       * @throws {TypeError} If arguments are invalid
       * @throws {Error} If there is already a value with this name or id
       */
      Enum.prototype.add = function add(name, id, comment) {
        // utilized by the parser but not by .fromJSON

        if (!util.isString(name)) throw TypeError("name must be a string");

        if (!util.isInteger(id)) throw TypeError("id must be an integer");

        if (this.values[name] !== undefined)
          throw Error("duplicate name '" + name + "' in " + this);

        if (this.isReservedId(id))
          throw Error("id " + id + " is reserved in " + this);

        if (this.isReservedName(name))
          throw Error("name '" + name + "' is reserved in " + this);

        if (this.valuesById[id] !== undefined) {
          if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
          this.values[name] = id;
        } else this.valuesById[(this.values[name] = id)] = name;

        this.comments[name] = comment || null;
        return this;
      };

      /**
       * Removes a value from this enum
       * @param {string} name Value name
       * @returns {Enum} `this`
       * @throws {TypeError} If arguments are invalid
       * @throws {Error} If `name` is not a name of this enum
       */
      Enum.prototype.remove = function remove(name) {
        if (!util.isString(name)) throw TypeError("name must be a string");

        var val = this.values[name];
        if (val == null)
          throw Error("name '" + name + "' does not exist in " + this);

        delete this.valuesById[val];
        delete this.values[name];
        delete this.comments[name];

        return this;
      };

      /**
       * Tests if the specified id is reserved.
       * @param {number} id Id to test
       * @returns {boolean} `true` if reserved, otherwise `false`
       */
      Enum.prototype.isReservedId = function isReservedId(id) {
        return Namespace.isReservedId(this.reserved, id);
      };

      /**
       * Tests if the specified name is reserved.
       * @param {string} name Name to test
       * @returns {boolean} `true` if reserved, otherwise `false`
       */
      Enum.prototype.isReservedName = function isReservedName(name) {
        return Namespace.isReservedName(this.reserved, name);
      };

      /***/
    },

    /***/ 3548: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Field;

      // extends ReflectionObject
      var ReflectionObject = __webpack_require__(3243);
      ((Field.prototype = Object.create(
        ReflectionObject.prototype
      )).constructor = Field).className = "Field";

      var Enum = __webpack_require__(7025),
        types = __webpack_require__(7063),
        util = __webpack_require__(9935);

      var Type; // cyclic

      var ruleRe = /^required|optional|repeated$/;

      /**
       * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
       * @name Field
       * @classdesc Reflected message field.
       * @extends FieldBase
       * @constructor
       * @param {string} name Unique name within its namespace
       * @param {number} id Unique id within its namespace
       * @param {string} type Value type
       * @param {string|Object.<string,*>} [rule="optional"] Field rule
       * @param {string|Object.<string,*>} [extend] Extended type if different from parent
       * @param {Object.<string,*>} [options] Declared options
       */

      /**
       * Constructs a field from a field descriptor.
       * @param {string} name Field name
       * @param {IField} json Field descriptor
       * @returns {Field} Created field
       * @throws {TypeError} If arguments are invalid
       */
      Field.fromJSON = function fromJSON(name, json) {
        return new Field(
          name,
          json.id,
          json.type,
          json.rule,
          json.extend,
          json.options,
          json.comment
        );
      };

      /**
       * Not an actual constructor. Use {@link Field} instead.
       * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
       * @exports FieldBase
       * @extends ReflectionObject
       * @constructor
       * @param {string} name Unique name within its namespace
       * @param {number} id Unique id within its namespace
       * @param {string} type Value type
       * @param {string|Object.<string,*>} [rule="optional"] Field rule
       * @param {string|Object.<string,*>} [extend] Extended type if different from parent
       * @param {Object.<string,*>} [options] Declared options
       * @param {string} [comment] Comment associated with this field
       */
      function Field(name, id, type, rule, extend, options, comment) {
        if (util.isObject(rule)) {
          comment = extend;
          options = rule;
          rule = extend = undefined;
        } else if (util.isObject(extend)) {
          comment = options;
          options = extend;
          extend = undefined;
        }

        ReflectionObject.call(this, name, options);

        if (!util.isInteger(id) || id < 0)
          throw TypeError("id must be a non-negative integer");

        if (!util.isString(type)) throw TypeError("type must be a string");

        if (
          rule !== undefined &&
          !ruleRe.test((rule = rule.toString().toLowerCase()))
        )
          throw TypeError("rule must be a string rule");

        if (extend !== undefined && !util.isString(extend))
          throw TypeError("extend must be a string");

        if (rule === "proto3_optional") {
          rule = "optional";
        }
        /**
         * Field rule, if any.
         * @type {string|undefined}
         */
        this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

        /**
         * Field type.
         * @type {string}
         */
        this.type = type; // toJSON

        /**
         * Unique field id.
         * @type {number}
         */
        this.id = id; // toJSON, marker

        /**
         * Extended type if different from parent.
         * @type {string|undefined}
         */
        this.extend = extend || undefined; // toJSON

        /**
         * Whether this field is required.
         * @type {boolean}
         */
        this.required = rule === "required";

        /**
         * Whether this field is optional.
         * @type {boolean}
         */
        this.optional = !this.required;

        /**
         * Whether this field is repeated.
         * @type {boolean}
         */
        this.repeated = rule === "repeated";

        /**
         * Whether this field is a map or not.
         * @type {boolean}
         */
        this.map = false;

        /**
         * Message this field belongs to.
         * @type {Type|null}
         */
        this.message = null;

        /**
         * OneOf this field belongs to, if any,
         * @type {OneOf|null}
         */
        this.partOf = null;

        /**
         * The field type's default value.
         * @type {*}
         */
        this.typeDefault = null;

        /**
         * The field's default value on prototypes.
         * @type {*}
         */
        this.defaultValue = null;

        /**
         * Whether this field's value should be treated as a long.
         * @type {boolean}
         */
        this.long = util.Long
          ? types.long[type] !== undefined
          : /* istanbul ignore next */ false;

        /**
         * Whether this field's value is a buffer.
         * @type {boolean}
         */
        this.bytes = type === "bytes";

        /**
         * Resolved type if not a basic type.
         * @type {Type|Enum|null}
         */
        this.resolvedType = null;

        /**
         * Sister-field within the extended type if a declaring extension field.
         * @type {Field|null}
         */
        this.extensionField = null;

        /**
         * Sister-field within the declaring namespace if an extended field.
         * @type {Field|null}
         */
        this.declaringField = null;

        /**
         * Internally remembers whether this field is packed.
         * @type {boolean|null}
         * @private
         */
        this._packed = null;

        /**
         * Comment for this field.
         * @type {string|null}
         */
        this.comment = comment;
      }

      /**
       * Determines whether this field is packed. Only relevant when repeated and working with proto2.
       * @name Field#packed
       * @type {boolean}
       * @readonly
       */
      Object.defineProperty(Field.prototype, "packed", {
        get: function () {
          // defaults to packed=true if not explicity set to false
          if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
          return this._packed;
        },
      });

      /**
       * @override
       */
      Field.prototype.setOption = function setOption(name, value, ifNotSet) {
        if (name === "packed")
          // clear cached before setting
          this._packed = null;
        return ReflectionObject.prototype.setOption.call(
          this,
          name,
          value,
          ifNotSet
        );
      };

      /**
       * Field descriptor.
       * @interface IField
       * @property {string} [rule="optional"] Field rule
       * @property {string} type Field type
       * @property {number} id Field id
       * @property {Object.<string,*>} [options] Field options
       */

      /**
       * Extension field descriptor.
       * @interface IExtensionField
       * @extends IField
       * @property {string} extend Extended type
       */

      /**
       * Converts this field to a field descriptor.
       * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
       * @returns {IField} Field descriptor
       */
      Field.prototype.toJSON = function toJSON(toJSONOptions) {
        var keepComments = toJSONOptions
          ? Boolean(toJSONOptions.keepComments)
          : false;
        return util.toObject([
          "rule",
          (this.rule !== "optional" && this.rule) || undefined,
          "type",
          this.type,
          "id",
          this.id,
          "extend",
          this.extend,
          "options",
          this.options,
          "comment",
          keepComments ? this.comment : undefined,
        ]);
      };

      /**
       * Resolves this field's type references.
       * @returns {Field} `this`
       * @throws {Error} If any reference cannot be resolved
       */
      Field.prototype.resolve = function resolve() {
        if (this.resolved) return this;

        if ((this.typeDefault = types.defaults[this.type]) === undefined) {
          // if not a basic type, resolve it
          this.resolvedType = (
            this.declaringField ? this.declaringField.parent : this.parent
          ).lookupTypeOrEnum(this.type);
          if (this.resolvedType instanceof Type) this.typeDefault = null;
          // instanceof Enum
          else
            this.typeDefault =
              this.resolvedType.values[
                Object.keys(this.resolvedType.values)[0]
              ]; // first defined
        }

        // use explicitly set default value if present
        if (this.options && this.options["default"] != null) {
          this.typeDefault = this.options["default"];
          if (
            this.resolvedType instanceof Enum &&
            typeof this.typeDefault === "string"
          )
            this.typeDefault = this.resolvedType.values[this.typeDefault];
        }

        // remove unnecessary options
        if (this.options) {
          if (
            this.options.packed === true ||
            (this.options.packed !== undefined &&
              this.resolvedType &&
              !(this.resolvedType instanceof Enum))
          )
            delete this.options.packed;
          if (!Object.keys(this.options).length) this.options = undefined;
        }

        // convert to internal data type if necesssary
        if (this.long) {
          this.typeDefault = util.Long.fromNumber(
            this.typeDefault,
            this.type.charAt(0) === "u"
          );

          /* istanbul ignore else */
          if (Object.freeze) Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)
        } else if (this.bytes && typeof this.typeDefault === "string") {
          var buf;
          if (util.base64.test(this.typeDefault))
            util.base64.decode(
              this.typeDefault,
              (buf = util.newBuffer(util.base64.length(this.typeDefault))),
              0
            );
          else
            util.utf8.write(
              this.typeDefault,
              (buf = util.newBuffer(util.utf8.length(this.typeDefault))),
              0
            );
          this.typeDefault = buf;
        }

        // take special care of maps and repeated fields
        if (this.map) this.defaultValue = util.emptyObject;
        else if (this.repeated) this.defaultValue = util.emptyArray;
        else this.defaultValue = this.typeDefault;

        // ensure proper value on prototype
        if (this.parent instanceof Type)
          this.parent.ctor.prototype[this.name] = this.defaultValue;

        return ReflectionObject.prototype.resolve.call(this);
      };

      /**
       * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
       * @typedef FieldDecorator
       * @type {function}
       * @param {Object} prototype Target prototype
       * @param {string} fieldName Field name
       * @returns {undefined}
       */

      /**
       * Field decorator (TypeScript).
       * @name Field.d
       * @function
       * @param {number} fieldId Field id
       * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
       * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
       * @param {T} [defaultValue] Default value
       * @returns {FieldDecorator} Decorator function
       * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
       */
      Field.d = function decorateField(
        fieldId,
        fieldType,
        fieldRule,
        defaultValue
      ) {
        // submessage: decorate the submessage and use its name as the type
        if (typeof fieldType === "function")
          fieldType = util.decorateType(fieldType).name;
        // enum reference: create a reflected copy of the enum and keep reuseing it
        else if (fieldType && typeof fieldType === "object")
          fieldType = util.decorateEnum(fieldType).name;

        return function fieldDecorator(prototype, fieldName) {
          util
            .decorateType(prototype.constructor)
            .add(
              new Field(fieldName, fieldId, fieldType, fieldRule, {
                default: defaultValue,
              })
            );
        };
      };

      /**
       * Field decorator (TypeScript).
       * @name Field.d
       * @function
       * @param {number} fieldId Field id
       * @param {Constructor<T>|string} fieldType Field type
       * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
       * @returns {FieldDecorator} Decorator function
       * @template T extends Message<T>
       * @variation 2
       */
      // like Field.d but without a default value

      // Sets up cyclic dependencies (called in index-light)
      Field._configure = function configure(Type_) {
        Type = Type_;
      };

      /***/
    },

    /***/ 8836: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      var protobuf = (module.exports = __webpack_require__(9482));

      protobuf.build = "light";

      /**
       * A node-style callback as used by {@link load} and {@link Root#load}.
       * @typedef LoadCallback
       * @type {function}
       * @param {Error|null} error Error, if any, otherwise `null`
       * @param {Root} [root] Root, if there hasn't been an error
       * @returns {undefined}
       */

      /**
       * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
       * @param {string|string[]} filename One or multiple files to load
       * @param {Root} root Root namespace, defaults to create a new one if omitted.
       * @param {LoadCallback} callback Callback function
       * @returns {undefined}
       * @see {@link Root#load}
       */
      function load(filename, root, callback) {
        if (typeof root === "function") {
          callback = root;
          root = new protobuf.Root();
        } else if (!root) root = new protobuf.Root();
        return root.load(filename, callback);
      }

      /**
       * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
       * @name load
       * @function
       * @param {string|string[]} filename One or multiple files to load
       * @param {LoadCallback} callback Callback function
       * @returns {undefined}
       * @see {@link Root#load}
       * @variation 2
       */
      // function load(filename:string, callback:LoadCallback):undefined

      /**
       * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
       * @name load
       * @function
       * @param {string|string[]} filename One or multiple files to load
       * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
       * @returns {Promise<Root>} Promise
       * @see {@link Root#load}
       * @variation 3
       */
      // function load(filename:string, [root:Root]):Promise<Root>

      protobuf.load = load;

      /**
       * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
       * @param {string|string[]} filename One or multiple files to load
       * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
       * @returns {Root} Root namespace
       * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
       * @see {@link Root#loadSync}
       */
      function loadSync(filename, root) {
        if (!root) root = new protobuf.Root();
        return root.loadSync(filename);
      }

      protobuf.loadSync = loadSync;

      // Serialization
      protobuf.encoder = __webpack_require__(4928);
      protobuf.decoder = __webpack_require__(5305);
      protobuf.verifier = __webpack_require__(4497);
      protobuf.converter = __webpack_require__(3996);

      // Reflection
      protobuf.ReflectionObject = __webpack_require__(3243);
      protobuf.Namespace = __webpack_require__(9313);
      protobuf.Root = __webpack_require__(9424);
      protobuf.Enum = __webpack_require__(7025);
      protobuf.Type = __webpack_require__(7645);
      protobuf.Field = __webpack_require__(3548);
      protobuf.OneOf = __webpack_require__(7598);
      protobuf.MapField = __webpack_require__(6039);
      protobuf.Service = __webpack_require__(7513);
      protobuf.Method = __webpack_require__(4429);

      // Runtime
      protobuf.Message = __webpack_require__(8368);
      protobuf.wrappers = __webpack_require__(1667);

      // Utility
      protobuf.types = __webpack_require__(7063);
      protobuf.util = __webpack_require__(9935);

      // Set up possibly cyclic reflection dependencies
      protobuf.ReflectionObject._configure(protobuf.Root);
      protobuf.Namespace._configure(
        protobuf.Type,
        protobuf.Service,
        protobuf.Enum
      );
      protobuf.Root._configure(protobuf.Type);
      protobuf.Field._configure(protobuf.Type);

      /***/
    },

    /***/ 9482: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      var protobuf = exports;

      /**
       * Build type, one of `"full"`, `"light"` or `"minimal"`.
       * @name build
       * @type {string}
       * @const
       */
      protobuf.build = "minimal";

      // Serialization
      protobuf.Writer = __webpack_require__(1173);
      protobuf.BufferWriter = __webpack_require__(3155);
      protobuf.Reader = __webpack_require__(1408);
      protobuf.BufferReader = __webpack_require__(593);

      // Utility
      protobuf.util = __webpack_require__(9693);
      protobuf.rpc = __webpack_require__(5994);
      protobuf.roots = __webpack_require__(5054);
      protobuf.configure = configure;

      /* istanbul ignore next */
      /**
       * Reconfigures the library according to the environment.
       * @returns {undefined}
       */
      function configure() {
        protobuf.util._configure();
        protobuf.Writer._configure(protobuf.BufferWriter);
        protobuf.Reader._configure(protobuf.BufferReader);
      }

      // Set up buffer utility according to the environment
      configure();

      /***/
    },

    /***/ 6039: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = MapField;

      // extends Field
      var Field = __webpack_require__(3548);
      ((MapField.prototype = Object.create(Field.prototype)).constructor =
        MapField).className = "MapField";

      var types = __webpack_require__(7063),
        util = __webpack_require__(9935);

      /**
       * Constructs a new map field instance.
       * @classdesc Reflected map field.
       * @extends FieldBase
       * @constructor
       * @param {string} name Unique name within its namespace
       * @param {number} id Unique id within its namespace
       * @param {string} keyType Key type
       * @param {string} type Value type
       * @param {Object.<string,*>} [options] Declared options
       * @param {string} [comment] Comment associated with this field
       */
      function MapField(name, id, keyType, type, options, comment) {
        Field.call(
          this,
          name,
          id,
          type,
          undefined,
          undefined,
          options,
          comment
        );

        /* istanbul ignore if */
        if (!util.isString(keyType))
          throw TypeError("keyType must be a string");

        /**
         * Key type.
         * @type {string}
         */
        this.keyType = keyType; // toJSON, marker

        /**
         * Resolved key type if not a basic type.
         * @type {ReflectionObject|null}
         */
        this.resolvedKeyType = null;

        // Overrides Field#map
        this.map = true;
      }

      /**
       * Map field descriptor.
       * @interface IMapField
       * @extends {IField}
       * @property {string} keyType Key type
       */

      /**
       * Extension map field descriptor.
       * @interface IExtensionMapField
       * @extends IMapField
       * @property {string} extend Extended type
       */

      /**
       * Constructs a map field from a map field descriptor.
       * @param {string} name Field name
       * @param {IMapField} json Map field descriptor
       * @returns {MapField} Created map field
       * @throws {TypeError} If arguments are invalid
       */
      MapField.fromJSON = function fromJSON(name, json) {
        return new MapField(
          name,
          json.id,
          json.keyType,
          json.type,
          json.options,
          json.comment
        );
      };

      /**
       * Converts this map field to a map field descriptor.
       * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
       * @returns {IMapField} Map field descriptor
       */
      MapField.prototype.toJSON = function toJSON(toJSONOptions) {
        var keepComments = toJSONOptions
          ? Boolean(toJSONOptions.keepComments)
          : false;
        return util.toObject([
          "keyType",
          this.keyType,
          "type",
          this.type,
          "id",
          this.id,
          "extend",
          this.extend,
          "options",
          this.options,
          "comment",
          keepComments ? this.comment : undefined,
        ]);
      };

      /**
       * @override
       */
      MapField.prototype.resolve = function resolve() {
        if (this.resolved) return this;

        // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
        if (types.mapKey[this.keyType] === undefined)
          throw Error("invalid key type: " + this.keyType);

        return Field.prototype.resolve.call(this);
      };

      /**
       * Map field decorator (TypeScript).
       * @name MapField.d
       * @function
       * @param {number} fieldId Field id
       * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
       * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
       * @returns {FieldDecorator} Decorator function
       * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
       */
      MapField.d = function decorateMapField(
        fieldId,
        fieldKeyType,
        fieldValueType
      ) {
        // submessage value: decorate the submessage and use its name as the type
        if (typeof fieldValueType === "function")
          fieldValueType = util.decorateType(fieldValueType).name;
        // enum reference value: create a reflected copy of the enum and keep reuseing it
        else if (fieldValueType && typeof fieldValueType === "object")
          fieldValueType = util.decorateEnum(fieldValueType).name;

        return function mapFieldDecorator(prototype, fieldName) {
          util
            .decorateType(prototype.constructor)
            .add(
              new MapField(fieldName, fieldId, fieldKeyType, fieldValueType)
            );
        };
      };

      /***/
    },

    /***/ 8368: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Message;

      var util = __webpack_require__(9693);

      /**
       * Constructs a new message instance.
       * @classdesc Abstract runtime message.
       * @constructor
       * @param {Properties<T>} [properties] Properties to set
       * @template T extends object = object
       */
      function Message(properties) {
        // not used internally
        if (properties)
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
      }

      /**
       * Reference to the reflected type.
       * @name Message.$type
       * @type {Type}
       * @readonly
       */

      /**
       * Reference to the reflected type.
       * @name Message#$type
       * @type {Type}
       * @readonly
       */

      /*eslint-disable valid-jsdoc*/

      /**
       * Creates a new message of this type using the specified properties.
       * @param {Object.<string,*>} [properties] Properties to set
       * @returns {Message<T>} Message instance
       * @template T extends Message<T>
       * @this Constructor<T>
       */
      Message.create = function create(properties) {
        return this.$type.create(properties);
      };

      /**
       * Encodes a message of this type.
       * @param {T|Object.<string,*>} message Message to encode
       * @param {Writer} [writer] Writer to use
       * @returns {Writer} Writer
       * @template T extends Message<T>
       * @this Constructor<T>
       */
      Message.encode = function encode(message, writer) {
        return this.$type.encode(message, writer);
      };

      /**
       * Encodes a message of this type preceeded by its length as a varint.
       * @param {T|Object.<string,*>} message Message to encode
       * @param {Writer} [writer] Writer to use
       * @returns {Writer} Writer
       * @template T extends Message<T>
       * @this Constructor<T>
       */
      Message.encodeDelimited = function encodeDelimited(message, writer) {
        return this.$type.encodeDelimited(message, writer);
      };

      /**
       * Decodes a message of this type.
       * @name Message.decode
       * @function
       * @param {Reader|Uint8Array} reader Reader or buffer to decode
       * @returns {T} Decoded message
       * @template T extends Message<T>
       * @this Constructor<T>
       */
      Message.decode = function decode(reader) {
        return this.$type.decode(reader);
      };

      /**
       * Decodes a message of this type preceeded by its length as a varint.
       * @name Message.decodeDelimited
       * @function
       * @param {Reader|Uint8Array} reader Reader or buffer to decode
       * @returns {T} Decoded message
       * @template T extends Message<T>
       * @this Constructor<T>
       */
      Message.decodeDelimited = function decodeDelimited(reader) {
        return this.$type.decodeDelimited(reader);
      };

      /**
       * Verifies a message of this type.
       * @name Message.verify
       * @function
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Message.verify = function verify(message) {
        return this.$type.verify(message);
      };

      /**
       * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
       * @param {Object.<string,*>} object Plain object
       * @returns {T} Message instance
       * @template T extends Message<T>
       * @this Constructor<T>
       */
      Message.fromObject = function fromObject(object) {
        return this.$type.fromObject(object);
      };

      /**
       * Creates a plain object from a message of this type. Also converts values to other types if specified.
       * @param {T} message Message instance
       * @param {IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       * @template T extends Message<T>
       * @this Constructor<T>
       */
      Message.toObject = function toObject(message, options) {
        return this.$type.toObject(message, options);
      };

      /**
       * Converts this message to JSON.
       * @returns {Object.<string,*>} JSON object
       */
      Message.prototype.toJSON = function toJSON() {
        return this.$type.toObject(this, util.toJSONOptions);
      };

      /*eslint-enable valid-jsdoc*/

      /***/
    },

    /***/ 4429: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Method;

      // extends ReflectionObject
      var ReflectionObject = __webpack_require__(3243);
      ((Method.prototype = Object.create(
        ReflectionObject.prototype
      )).constructor = Method).className = "Method";

      var util = __webpack_require__(9935);

      /**
       * Constructs a new service method instance.
       * @classdesc Reflected service method.
       * @extends ReflectionObject
       * @constructor
       * @param {string} name Method name
       * @param {string|undefined} type Method type, usually `"rpc"`
       * @param {string} requestType Request message type
       * @param {string} responseType Response message type
       * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
       * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
       * @param {Object.<string,*>} [options] Declared options
       * @param {string} [comment] The comment for this method
       * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
       */
      function Method(
        name,
        type,
        requestType,
        responseType,
        requestStream,
        responseStream,
        options,
        comment,
        parsedOptions
      ) {
        /* istanbul ignore next */
        if (util.isObject(requestStream)) {
          options = requestStream;
          requestStream = responseStream = undefined;
        } else if (util.isObject(responseStream)) {
          options = responseStream;
          responseStream = undefined;
        }

        /* istanbul ignore if */
        if (!(type === undefined || util.isString(type)))
          throw TypeError("type must be a string");

        /* istanbul ignore if */
        if (!util.isString(requestType))
          throw TypeError("requestType must be a string");

        /* istanbul ignore if */
        if (!util.isString(responseType))
          throw TypeError("responseType must be a string");

        ReflectionObject.call(this, name, options);

        /**
         * Method type.
         * @type {string}
         */
        this.type = type || "rpc"; // toJSON

        /**
         * Request type.
         * @type {string}
         */
        this.requestType = requestType; // toJSON, marker

        /**
         * Whether requests are streamed or not.
         * @type {boolean|undefined}
         */
        this.requestStream = requestStream ? true : undefined; // toJSON

        /**
         * Response type.
         * @type {string}
         */
        this.responseType = responseType; // toJSON

        /**
         * Whether responses are streamed or not.
         * @type {boolean|undefined}
         */
        this.responseStream = responseStream ? true : undefined; // toJSON

        /**
         * Resolved request type.
         * @type {Type|null}
         */
        this.resolvedRequestType = null;

        /**
         * Resolved response type.
         * @type {Type|null}
         */
        this.resolvedResponseType = null;

        /**
         * Comment for this method
         * @type {string|null}
         */
        this.comment = comment;

        /**
         * Options properly parsed into an object
         */
        this.parsedOptions = parsedOptions;
      }

      /**
       * Method descriptor.
       * @interface IMethod
       * @property {string} [type="rpc"] Method type
       * @property {string} requestType Request type
       * @property {string} responseType Response type
       * @property {boolean} [requestStream=false] Whether requests are streamed
       * @property {boolean} [responseStream=false] Whether responses are streamed
       * @property {Object.<string,*>} [options] Method options
       * @property {string} comment Method comments
       * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
       */

      /**
       * Constructs a method from a method descriptor.
       * @param {string} name Method name
       * @param {IMethod} json Method descriptor
       * @returns {Method} Created method
       * @throws {TypeError} If arguments are invalid
       */
      Method.fromJSON = function fromJSON(name, json) {
        return new Method(
          name,
          json.type,
          json.requestType,
          json.responseType,
          json.requestStream,
          json.responseStream,
          json.options,
          json.comment,
          json.parsedOptions
        );
      };

      /**
       * Converts this method to a method descriptor.
       * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
       * @returns {IMethod} Method descriptor
       */
      Method.prototype.toJSON = function toJSON(toJSONOptions) {
        var keepComments = toJSONOptions
          ? Boolean(toJSONOptions.keepComments)
          : false;
        return util.toObject([
          "type",
          (this.type !== "rpc" && /* istanbul ignore next */ this.type) ||
            undefined,
          "requestType",
          this.requestType,
          "requestStream",
          this.requestStream,
          "responseType",
          this.responseType,
          "responseStream",
          this.responseStream,
          "options",
          this.options,
          "comment",
          keepComments ? this.comment : undefined,
          "parsedOptions",
          this.parsedOptions,
        ]);
      };

      /**
       * @override
       */
      Method.prototype.resolve = function resolve() {
        /* istanbul ignore if */
        if (this.resolved) return this;

        this.resolvedRequestType = this.parent.lookupType(this.requestType);
        this.resolvedResponseType = this.parent.lookupType(this.responseType);

        return ReflectionObject.prototype.resolve.call(this);
      };

      /***/
    },

    /***/ 9313: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Namespace;

      // extends ReflectionObject
      var ReflectionObject = __webpack_require__(3243);
      ((Namespace.prototype = Object.create(
        ReflectionObject.prototype
      )).constructor = Namespace).className = "Namespace";

      var Field = __webpack_require__(3548),
        OneOf = __webpack_require__(7598),
        util = __webpack_require__(9935);

      var Type, // cyclic
        Service,
        Enum;

      /**
       * Constructs a new namespace instance.
       * @name Namespace
       * @classdesc Reflected namespace.
       * @extends NamespaceBase
       * @constructor
       * @param {string} name Namespace name
       * @param {Object.<string,*>} [options] Declared options
       */

      /**
       * Constructs a namespace from JSON.
       * @memberof Namespace
       * @function
       * @param {string} name Namespace name
       * @param {Object.<string,*>} json JSON object
       * @returns {Namespace} Created namespace
       * @throws {TypeError} If arguments are invalid
       */
      Namespace.fromJSON = function fromJSON(name, json) {
        return new Namespace(name, json.options).addJSON(json.nested);
      };

      /**
       * Converts an array of reflection objects to JSON.
       * @memberof Namespace
       * @param {ReflectionObject[]} array Object array
       * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
       * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
       */
      function arrayToJSON(array, toJSONOptions) {
        if (!(array && array.length)) return undefined;
        var obj = {};
        for (var i = 0; i < array.length; ++i)
          obj[array[i].name] = array[i].toJSON(toJSONOptions);
        return obj;
      }

      Namespace.arrayToJSON = arrayToJSON;

      /**
       * Tests if the specified id is reserved.
       * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
       * @param {number} id Id to test
       * @returns {boolean} `true` if reserved, otherwise `false`
       */
      Namespace.isReservedId = function isReservedId(reserved, id) {
        if (reserved)
          for (var i = 0; i < reserved.length; ++i)
            if (
              typeof reserved[i] !== "string" &&
              reserved[i][0] <= id &&
              reserved[i][1] > id
            )
              return true;
        return false;
      };

      /**
       * Tests if the specified name is reserved.
       * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
       * @param {string} name Name to test
       * @returns {boolean} `true` if reserved, otherwise `false`
       */
      Namespace.isReservedName = function isReservedName(reserved, name) {
        if (reserved)
          for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name) return true;
        return false;
      };

      /**
       * Not an actual constructor. Use {@link Namespace} instead.
       * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
       * @exports NamespaceBase
       * @extends ReflectionObject
       * @abstract
       * @constructor
       * @param {string} name Namespace name
       * @param {Object.<string,*>} [options] Declared options
       * @see {@link Namespace}
       */
      function Namespace(name, options) {
        ReflectionObject.call(this, name, options);

        /**
         * Nested objects by name.
         * @type {Object.<string,ReflectionObject>|undefined}
         */
        this.nested = undefined; // toJSON

        /**
         * Cached nested objects as an array.
         * @type {ReflectionObject[]|null}
         * @private
         */
        this._nestedArray = null;
      }

      function clearCache(namespace) {
        namespace._nestedArray = null;
        return namespace;
      }

      /**
       * Nested objects of this namespace as an array for iteration.
       * @name NamespaceBase#nestedArray
       * @type {ReflectionObject[]}
       * @readonly
       */
      Object.defineProperty(Namespace.prototype, "nestedArray", {
        get: function () {
          return (
            this._nestedArray || (this._nestedArray = util.toArray(this.nested))
          );
        },
      });

      /**
       * Namespace descriptor.
       * @interface INamespace
       * @property {Object.<string,*>} [options] Namespace options
       * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
       */

      /**
       * Any extension field descriptor.
       * @typedef AnyExtensionField
       * @type {IExtensionField|IExtensionMapField}
       */

      /**
       * Any nested object descriptor.
       * @typedef AnyNestedObject
       * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
       */
      // ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

      /**
       * Converts this namespace to a namespace descriptor.
       * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
       * @returns {INamespace} Namespace descriptor
       */
      Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
        return util.toObject([
          "options",
          this.options,
          "nested",
          arrayToJSON(this.nestedArray, toJSONOptions),
        ]);
      };

      /**
       * Adds nested objects to this namespace from nested object descriptors.
       * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
       * @returns {Namespace} `this`
       */
      Namespace.prototype.addJSON = function addJSON(nestedJson) {
        var ns = this;
        /* istanbul ignore else */
        if (nestedJson) {
          for (
            var names = Object.keys(nestedJson), i = 0, nested;
            i < names.length;
            ++i
          ) {
            nested = nestedJson[names[i]];
            ns.add(
              // most to least likely
              (nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON)(names[i], nested)
            );
          }
        }
        return this;
      };

      /**
       * Gets the nested object of the specified name.
       * @param {string} name Nested object name
       * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
       */
      Namespace.prototype.get = function get(name) {
        return (this.nested && this.nested[name]) || null;
      };

      /**
       * Gets the values of the nested {@link Enum|enum} of the specified name.
       * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
       * @param {string} name Nested enum name
       * @returns {Object.<string,number>} Enum values
       * @throws {Error} If there is no such enum
       */
      Namespace.prototype.getEnum = function getEnum(name) {
        if (this.nested && this.nested[name] instanceof Enum)
          return this.nested[name].values;
        throw Error("no such enum: " + name);
      };

      /**
       * Adds a nested object to this namespace.
       * @param {ReflectionObject} object Nested object to add
       * @returns {Namespace} `this`
       * @throws {TypeError} If arguments are invalid
       * @throws {Error} If there is already a nested object with this name
       */
      Namespace.prototype.add = function add(object) {
        if (
          !(
            (object instanceof Field && object.extend !== undefined) ||
            object instanceof Type ||
            object instanceof Enum ||
            object instanceof Service ||
            object instanceof Namespace ||
            object instanceof OneOf
          )
        )
          throw TypeError("object must be a valid nested object");

        if (!this.nested) this.nested = {};
        else {
          var prev = this.get(object.name);
          if (prev) {
            if (
              prev instanceof Namespace &&
              object instanceof Namespace &&
              !(prev instanceof Type || prev instanceof Service)
            ) {
              // replace plain namespace but keep existing nested elements and options
              var nested = prev.nestedArray;
              for (var i = 0; i < nested.length; ++i) object.add(nested[i]);
              this.remove(prev);
              if (!this.nested) this.nested = {};
              object.setOptions(prev.options, true);
            } else
              throw Error("duplicate name '" + object.name + "' in " + this);
          }
        }
        this.nested[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      };

      /**
       * Removes a nested object from this namespace.
       * @param {ReflectionObject} object Nested object to remove
       * @returns {Namespace} `this`
       * @throws {TypeError} If arguments are invalid
       * @throws {Error} If `object` is not a member of this namespace
       */
      Namespace.prototype.remove = function remove(object) {
        if (!(object instanceof ReflectionObject))
          throw TypeError("object must be a ReflectionObject");
        if (object.parent !== this)
          throw Error(object + " is not a member of " + this);

        delete this.nested[object.name];
        if (!Object.keys(this.nested).length) this.nested = undefined;

        object.onRemove(this);
        return clearCache(this);
      };

      /**
       * Defines additial namespaces within this one if not yet existing.
       * @param {string|string[]} path Path to create
       * @param {*} [json] Nested types to create from JSON
       * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
       */
      Namespace.prototype.define = function define(path, json) {
        if (util.isString(path)) path = path.split(".");
        else if (!Array.isArray(path)) throw TypeError("illegal path");
        if (path && path.length && path[0] === "")
          throw Error("path must be relative");

        var ptr = this;
        while (path.length > 0) {
          var part = path.shift();
          if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
              throw Error("path conflicts with non-namespace objects");
          } else ptr.add((ptr = new Namespace(part)));
        }
        if (json) ptr.addJSON(json);
        return ptr;
      };

      /**
       * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
       * @returns {Namespace} `this`
       */
      Namespace.prototype.resolveAll = function resolveAll() {
        var nested = this.nestedArray,
          i = 0;
        while (i < nested.length)
          if (nested[i] instanceof Namespace) nested[i++].resolveAll();
          else nested[i++].resolve();
        return this.resolve();
      };

      /**
       * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
       * @param {string|string[]} path Path to look up
       * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
       * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
       * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
       */
      Namespace.prototype.lookup = function lookup(
        path,
        filterTypes,
        parentAlreadyChecked
      ) {
        /* istanbul ignore next */
        if (typeof filterTypes === "boolean") {
          parentAlreadyChecked = filterTypes;
          filterTypes = undefined;
        } else if (filterTypes && !Array.isArray(filterTypes))
          filterTypes = [filterTypes];

        if (util.isString(path) && path.length) {
          if (path === ".") return this.root;
          path = path.split(".");
        } else if (!path.length) return this;

        // Start at root if path is absolute
        if (path[0] === "") return this.root.lookup(path.slice(1), filterTypes);

        // Test if the first part matches any nested object, and if so, traverse if path contains more
        var found = this.get(path[0]);
        if (found) {
          if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
              return found;
          } else if (
            found instanceof Namespace &&
            (found = found.lookup(path.slice(1), filterTypes, true))
          )
            return found;

          // Otherwise try each nested namespace
        } else
          for (var i = 0; i < this.nestedArray.length; ++i)
            if (
              this._nestedArray[i] instanceof Namespace &&
              (found = this._nestedArray[i].lookup(path, filterTypes, true))
            )
              return found;

        // If there hasn't been a match, try again at the parent
        if (this.parent === null || parentAlreadyChecked) return null;
        return this.parent.lookup(path, filterTypes);
      };

      /**
       * Looks up the reflection object at the specified path, relative to this namespace.
       * @name NamespaceBase#lookup
       * @function
       * @param {string|string[]} path Path to look up
       * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
       * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
       * @variation 2
       */
      // lookup(path: string, [parentAlreadyChecked: boolean])

      /**
       * Looks up the {@link Type|type} at the specified path, relative to this namespace.
       * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
       * @param {string|string[]} path Path to look up
       * @returns {Type} Looked up type
       * @throws {Error} If `path` does not point to a type
       */
      Namespace.prototype.lookupType = function lookupType(path) {
        var found = this.lookup(path, [Type]);
        if (!found) throw Error("no such type: " + path);
        return found;
      };

      /**
       * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
       * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
       * @param {string|string[]} path Path to look up
       * @returns {Enum} Looked up enum
       * @throws {Error} If `path` does not point to an enum
       */
      Namespace.prototype.lookupEnum = function lookupEnum(path) {
        var found = this.lookup(path, [Enum]);
        if (!found) throw Error("no such Enum '" + path + "' in " + this);
        return found;
      };

      /**
       * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
       * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
       * @param {string|string[]} path Path to look up
       * @returns {Type} Looked up type or enum
       * @throws {Error} If `path` does not point to a type or enum
       */
      Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
        var found = this.lookup(path, [Type, Enum]);
        if (!found)
          throw Error("no such Type or Enum '" + path + "' in " + this);
        return found;
      };

      /**
       * Looks up the {@link Service|service} at the specified path, relative to this namespace.
       * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
       * @param {string|string[]} path Path to look up
       * @returns {Service} Looked up service
       * @throws {Error} If `path` does not point to a service
       */
      Namespace.prototype.lookupService = function lookupService(path) {
        var found = this.lookup(path, [Service]);
        if (!found) throw Error("no such Service '" + path + "' in " + this);
        return found;
      };

      // Sets up cyclic dependencies (called in index-light)
      Namespace._configure = function (Type_, Service_, Enum_) {
        Type = Type_;
        Service = Service_;
        Enum = Enum_;
      };

      /***/
    },

    /***/ 3243: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = ReflectionObject;

      ReflectionObject.className = "ReflectionObject";

      var util = __webpack_require__(9935);

      var Root; // cyclic

      /**
       * Constructs a new reflection object instance.
       * @classdesc Base class of all reflection objects.
       * @constructor
       * @param {string} name Object name
       * @param {Object.<string,*>} [options] Declared options
       * @abstract
       */
      function ReflectionObject(name, options) {
        if (!util.isString(name)) throw TypeError("name must be a string");

        if (options && !util.isObject(options))
          throw TypeError("options must be an object");

        /**
         * Options.
         * @type {Object.<string,*>|undefined}
         */
        this.options = options; // toJSON

        /**
         * Parsed Options.
         * @type {Array.<Object.<string,*>>|undefined}
         */
        this.parsedOptions = null;

        /**
         * Unique name within its namespace.
         * @type {string}
         */
        this.name = name;

        /**
         * Parent namespace.
         * @type {Namespace|null}
         */
        this.parent = null;

        /**
         * Whether already resolved or not.
         * @type {boolean}
         */
        this.resolved = false;

        /**
         * Comment text, if any.
         * @type {string|null}
         */
        this.comment = null;

        /**
         * Defining file name.
         * @type {string|null}
         */
        this.filename = null;
      }

      Object.defineProperties(ReflectionObject.prototype, {
        /**
         * Reference to the root namespace.
         * @name ReflectionObject#root
         * @type {Root}
         * @readonly
         */
        root: {
          get: function () {
            var ptr = this;
            while (ptr.parent !== null) ptr = ptr.parent;
            return ptr;
          },
        },

        /**
         * Full name including leading dot.
         * @name ReflectionObject#fullName
         * @type {string}
         * @readonly
         */
        fullName: {
          get: function () {
            var path = [this.name],
              ptr = this.parent;
            while (ptr) {
              path.unshift(ptr.name);
              ptr = ptr.parent;
            }
            return path.join(".");
          },
        },
      });

      /**
       * Converts this reflection object to its descriptor representation.
       * @returns {Object.<string,*>} Descriptor
       * @abstract
       */
      ReflectionObject.prototype.toJSON =
        /* istanbul ignore next */ function toJSON() {
          throw Error(); // not implemented, shouldn't happen
        };

      /**
       * Called when this object is added to a parent.
       * @param {ReflectionObject} parent Parent added to
       * @returns {undefined}
       */
      ReflectionObject.prototype.onAdd = function onAdd(parent) {
        if (this.parent && this.parent !== parent) this.parent.remove(this);
        this.parent = parent;
        this.resolved = false;
        var root = parent.root;
        if (root instanceof Root) root._handleAdd(this);
      };

      /**
       * Called when this object is removed from a parent.
       * @param {ReflectionObject} parent Parent removed from
       * @returns {undefined}
       */
      ReflectionObject.prototype.onRemove = function onRemove(parent) {
        var root = parent.root;
        if (root instanceof Root) root._handleRemove(this);
        this.parent = null;
        this.resolved = false;
      };

      /**
       * Resolves this objects type references.
       * @returns {ReflectionObject} `this`
       */
      ReflectionObject.prototype.resolve = function resolve() {
        if (this.resolved) return this;
        if (this.root instanceof Root) this.resolved = true; // only if part of a root
        return this;
      };

      /**
       * Gets an option value.
       * @param {string} name Option name
       * @returns {*} Option value or `undefined` if not set
       */
      ReflectionObject.prototype.getOption = function getOption(name) {
        if (this.options) return this.options[name];
        return undefined;
      };

      /**
       * Sets an option.
       * @param {string} name Option name
       * @param {*} value Option value
       * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
       * @returns {ReflectionObject} `this`
       */
      ReflectionObject.prototype.setOption = function setOption(
        name,
        value,
        ifNotSet
      ) {
        if (!ifNotSet || !this.options || this.options[name] === undefined)
          (this.options || (this.options = {}))[name] = value;
        return this;
      };

      /**
       * Sets a parsed option.
       * @param {string} name parsed Option name
       * @param {*} value Option value
       * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
       * @returns {ReflectionObject} `this`
       */
      ReflectionObject.prototype.setParsedOption = function setParsedOption(
        name,
        value,
        propName
      ) {
        if (!this.parsedOptions) {
          this.parsedOptions = [];
        }
        var parsedOptions = this.parsedOptions;
        if (propName) {
          // If setting a sub property of an option then try to merge it
          // with an existing option
          var opt = parsedOptions.find(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, name);
          });
          if (opt) {
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
          } else {
            // otherwise, create a new option, set it's property and add it to the list
            opt = {};
            opt[name] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
          }
        } else {
          // Always create a new option when setting the value of the option itself
          var newOpt = {};
          newOpt[name] = value;
          parsedOptions.push(newOpt);
        }
        return this;
      };

      /**
       * Sets multiple options.
       * @param {Object.<string,*>} options Options to set
       * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
       * @returns {ReflectionObject} `this`
       */
      ReflectionObject.prototype.setOptions = function setOptions(
        options,
        ifNotSet
      ) {
        if (options)
          for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
        return this;
      };

      /**
       * Converts this instance to its string representation.
       * @returns {string} Class name[, space, full name]
       */
      ReflectionObject.prototype.toString = function toString() {
        var className = this.constructor.className,
          fullName = this.fullName;
        if (fullName.length) return className + " " + fullName;
        return className;
      };

      // Sets up cyclic dependencies (called in index-light)
      ReflectionObject._configure = function (Root_) {
        Root = Root_;
      };

      /***/
    },

    /***/ 7598: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = OneOf;

      // extends ReflectionObject
      var ReflectionObject = __webpack_require__(3243);
      ((OneOf.prototype = Object.create(
        ReflectionObject.prototype
      )).constructor = OneOf).className = "OneOf";

      var Field = __webpack_require__(3548),
        util = __webpack_require__(9935);

      /**
       * Constructs a new oneof instance.
       * @classdesc Reflected oneof.
       * @extends ReflectionObject
       * @constructor
       * @param {string} name Oneof name
       * @param {string[]|Object.<string,*>} [fieldNames] Field names
       * @param {Object.<string,*>} [options] Declared options
       * @param {string} [comment] Comment associated with this field
       */
      function OneOf(name, fieldNames, options, comment) {
        if (!Array.isArray(fieldNames)) {
          options = fieldNames;
          fieldNames = undefined;
        }
        ReflectionObject.call(this, name, options);

        /* istanbul ignore if */
        if (!(fieldNames === undefined || Array.isArray(fieldNames)))
          throw TypeError("fieldNames must be an Array");

        /**
         * Field names that belong to this oneof.
         * @type {string[]}
         */
        this.oneof = fieldNames || []; // toJSON, marker

        /**
         * Fields that belong to this oneof as an array for iteration.
         * @type {Field[]}
         * @readonly
         */
        this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

        /**
         * Comment for this field.
         * @type {string|null}
         */
        this.comment = comment;
      }

      /**
       * Oneof descriptor.
       * @interface IOneOf
       * @property {Array.<string>} oneof Oneof field names
       * @property {Object.<string,*>} [options] Oneof options
       */

      /**
       * Constructs a oneof from a oneof descriptor.
       * @param {string} name Oneof name
       * @param {IOneOf} json Oneof descriptor
       * @returns {OneOf} Created oneof
       * @throws {TypeError} If arguments are invalid
       */
      OneOf.fromJSON = function fromJSON(name, json) {
        return new OneOf(name, json.oneof, json.options, json.comment);
      };

      /**
       * Converts this oneof to a oneof descriptor.
       * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
       * @returns {IOneOf} Oneof descriptor
       */
      OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
        var keepComments = toJSONOptions
          ? Boolean(toJSONOptions.keepComments)
          : false;
        return util.toObject([
          "options",
          this.options,
          "oneof",
          this.oneof,
          "comment",
          keepComments ? this.comment : undefined,
        ]);
      };

      /**
       * Adds the fields of the specified oneof to the parent if not already done so.
       * @param {OneOf} oneof The oneof
       * @returns {undefined}
       * @inner
       * @ignore
       */
      function addFieldsToParent(oneof) {
        if (oneof.parent)
          for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
              oneof.parent.add(oneof.fieldsArray[i]);
      }

      /**
       * Adds a field to this oneof and removes it from its current parent, if any.
       * @param {Field} field Field to add
       * @returns {OneOf} `this`
       */
      OneOf.prototype.add = function add(field) {
        /* istanbul ignore if */
        if (!(field instanceof Field)) throw TypeError("field must be a Field");

        if (field.parent && field.parent !== this.parent)
          field.parent.remove(field);
        this.oneof.push(field.name);
        this.fieldsArray.push(field);
        field.partOf = this; // field.parent remains null
        addFieldsToParent(this);
        return this;
      };

      /**
       * Removes a field from this oneof and puts it back to the oneof's parent.
       * @param {Field} field Field to remove
       * @returns {OneOf} `this`
       */
      OneOf.prototype.remove = function remove(field) {
        /* istanbul ignore if */
        if (!(field instanceof Field)) throw TypeError("field must be a Field");

        var index = this.fieldsArray.indexOf(field);

        /* istanbul ignore if */
        if (index < 0) throw Error(field + " is not a member of " + this);

        this.fieldsArray.splice(index, 1);
        index = this.oneof.indexOf(field.name);

        /* istanbul ignore else */
        if (index > -1)
          // theoretical
          this.oneof.splice(index, 1);

        field.partOf = null;
        return this;
      };

      /**
       * @override
       */
      OneOf.prototype.onAdd = function onAdd(parent) {
        ReflectionObject.prototype.onAdd.call(this, parent);
        var self = this;
        // Collect present fields
        for (var i = 0; i < this.oneof.length; ++i) {
          var field = parent.get(this.oneof[i]);
          if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
          }
        }
        // Add not yet present fields
        addFieldsToParent(this);
      };

      /**
       * @override
       */
      OneOf.prototype.onRemove = function onRemove(parent) {
        for (var i = 0, field; i < this.fieldsArray.length; ++i)
          if ((field = this.fieldsArray[i]).parent) field.parent.remove(field);
        ReflectionObject.prototype.onRemove.call(this, parent);
      };

      /**
       * Decorator function as returned by {@link OneOf.d} (TypeScript).
       * @typedef OneOfDecorator
       * @type {function}
       * @param {Object} prototype Target prototype
       * @param {string} oneofName OneOf name
       * @returns {undefined}
       */

      /**
       * OneOf decorator (TypeScript).
       * @function
       * @param {...string} fieldNames Field names
       * @returns {OneOfDecorator} Decorator function
       * @template T extends string
       */
      OneOf.d = function decorateOneOf() {
        var fieldNames = new Array(arguments.length),
          index = 0;
        while (index < arguments.length) fieldNames[index] = arguments[index++];
        return function oneOfDecorator(prototype, oneofName) {
          util
            .decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
          Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames),
          });
        };
      };

      /***/
    },

    /***/ 1408: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Reader;

      var util = __webpack_require__(9693);

      var BufferReader; // cyclic

      var LongBits = util.LongBits,
        utf8 = util.utf8;

      /* istanbul ignore next */
      function indexOutOfRange(reader, writeLength) {
        return RangeError(
          "index out of range: " +
            reader.pos +
            " + " +
            (writeLength || 1) +
            " > " +
            reader.len
        );
      }

      /**
       * Constructs a new reader instance using the specified buffer.
       * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
       * @constructor
       * @param {Uint8Array} buffer Buffer to read from
       */
      function Reader(buffer) {
        /**
         * Read buffer.
         * @type {Uint8Array}
         */
        this.buf = buffer;

        /**
         * Read buffer position.
         * @type {number}
         */
        this.pos = 0;

        /**
         * Read buffer length.
         * @type {number}
         */
        this.len = buffer.length;
      }

      var create_array =
        typeof Uint8Array !== "undefined"
          ? function create_typed_array(buffer) {
              if (buffer instanceof Uint8Array || Array.isArray(buffer))
                return new Reader(buffer);
              throw Error("illegal buffer");
            }
          : /* istanbul ignore next */
            function create_array(buffer) {
              if (Array.isArray(buffer)) return new Reader(buffer);
              throw Error("illegal buffer");
            };

      var create = function create() {
        return util.Buffer
          ? function create_buffer_setup(buffer) {
              return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                  ? new BufferReader(buffer)
                  : /* istanbul ignore next */
                    create_array(buffer);
              })(buffer);
            }
          : /* istanbul ignore next */
            create_array;
      };

      /**
       * Creates a new reader using the specified buffer.
       * @function
       * @param {Uint8Array|Buffer} buffer Buffer to read from
       * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
       * @throws {Error} If `buffer` is not a valid buffer
       */
      Reader.create = create();

      Reader.prototype._slice =
        util.Array.prototype.subarray ||
        /* istanbul ignore next */ util.Array.prototype.slice;

      /**
       * Reads a varint as an unsigned 32 bit value.
       * @function
       * @returns {number} Value read
       */
      Reader.prototype.uint32 = (function read_uint32_setup() {
        var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
        return function read_uint32() {
          value = (this.buf[this.pos] & 127) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | ((this.buf[this.pos] & 127) << 7)) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | ((this.buf[this.pos] & 127) << 14)) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | ((this.buf[this.pos] & 127) << 21)) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | ((this.buf[this.pos] & 15) << 28)) >>> 0;
          if (this.buf[this.pos++] < 128) return value;

          /* istanbul ignore if */
          if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
          }
          return value;
        };
      })();

      /**
       * Reads a varint as a signed 32 bit value.
       * @returns {number} Value read
       */
      Reader.prototype.int32 = function read_int32() {
        return this.uint32() | 0;
      };

      /**
       * Reads a zig-zag encoded varint as a signed 32 bit value.
       * @returns {number} Value read
       */
      Reader.prototype.sint32 = function read_sint32() {
        var value = this.uint32();
        return ((value >>> 1) ^ -(value & 1)) | 0;
      };

      /* eslint-disable no-invalid-this */

      function readLongVarint() {
        // tends to deopt with local vars for octet etc.
        var bits = new LongBits(0, 0);
        var i = 0;
        if (this.len - this.pos > 4) {
          // fast route (lo)
          for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | ((this.buf[this.pos] & 127) << (i * 7))) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
          }
          // 5th
          bits.lo = (bits.lo | ((this.buf[this.pos] & 127) << 28)) >>> 0;
          bits.hi = (bits.hi | ((this.buf[this.pos] & 127) >> 4)) >>> 0;
          if (this.buf[this.pos++] < 128) return bits;
          i = 0;
        } else {
          for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len) throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | ((this.buf[this.pos] & 127) << (i * 7))) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
          }
          // 4th
          bits.lo = (bits.lo | ((this.buf[this.pos++] & 127) << (i * 7))) >>> 0;
          return bits;
        }
        if (this.len - this.pos > 4) {
          // fast route (hi)
          for (; i < 5; ++i) {
            // 6th..10th
            bits.hi =
              (bits.hi | ((this.buf[this.pos] & 127) << (i * 7 + 3))) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
          }
        } else {
          for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len) throw indexOutOfRange(this);
            // 6th..10th
            bits.hi =
              (bits.hi | ((this.buf[this.pos] & 127) << (i * 7 + 3))) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
          }
        }
        /* istanbul ignore next */
        throw Error("invalid varint encoding");
      }

      /* eslint-enable no-invalid-this */

      /**
       * Reads a varint as a signed 64 bit value.
       * @name Reader#int64
       * @function
       * @returns {Long} Value read
       */

      /**
       * Reads a varint as an unsigned 64 bit value.
       * @name Reader#uint64
       * @function
       * @returns {Long} Value read
       */

      /**
       * Reads a zig-zag encoded varint as a signed 64 bit value.
       * @name Reader#sint64
       * @function
       * @returns {Long} Value read
       */

      /**
       * Reads a varint as a boolean.
       * @returns {boolean} Value read
       */
      Reader.prototype.bool = function read_bool() {
        return this.uint32() !== 0;
      };

      function readFixed32_end(buf, end) {
        // note that this uses `end`, not `pos`
        return (
          (buf[end - 4] |
            (buf[end - 3] << 8) |
            (buf[end - 2] << 16) |
            (buf[end - 1] << 24)) >>>
          0
        );
      }

      /**
       * Reads fixed 32 bits as an unsigned 32 bit integer.
       * @returns {number} Value read
       */
      Reader.prototype.fixed32 = function read_fixed32() {
        /* istanbul ignore if */
        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);

        return readFixed32_end(this.buf, (this.pos += 4));
      };

      /**
       * Reads fixed 32 bits as a signed 32 bit integer.
       * @returns {number} Value read
       */
      Reader.prototype.sfixed32 = function read_sfixed32() {
        /* istanbul ignore if */
        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);

        return readFixed32_end(this.buf, (this.pos += 4)) | 0;
      };

      /* eslint-disable no-invalid-this */

      function readFixed64(/* this: Reader */) {
        /* istanbul ignore if */
        if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);

        return new LongBits(
          readFixed32_end(this.buf, (this.pos += 4)),
          readFixed32_end(this.buf, (this.pos += 4))
        );
      }

      /* eslint-enable no-invalid-this */

      /**
       * Reads fixed 64 bits.
       * @name Reader#fixed64
       * @function
       * @returns {Long} Value read
       */

      /**
       * Reads zig-zag encoded fixed 64 bits.
       * @name Reader#sfixed64
       * @function
       * @returns {Long} Value read
       */

      /**
       * Reads a float (32 bit) as a number.
       * @function
       * @returns {number} Value read
       */
      Reader.prototype.float = function read_float() {
        /* istanbul ignore if */
        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);

        var value = util.float.readFloatLE(this.buf, this.pos);
        this.pos += 4;
        return value;
      };

      /**
       * Reads a double (64 bit float) as a number.
       * @function
       * @returns {number} Value read
       */
      Reader.prototype.double = function read_double() {
        /* istanbul ignore if */
        if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);

        var value = util.float.readDoubleLE(this.buf, this.pos);
        this.pos += 8;
        return value;
      };

      /**
       * Reads a sequence of bytes preceeded by its length as a varint.
       * @returns {Uint8Array} Value read
       */
      Reader.prototype.bytes = function read_bytes() {
        var length = this.uint32(),
          start = this.pos,
          end = this.pos + length;

        /* istanbul ignore if */
        if (end > this.len) throw indexOutOfRange(this, length);

        this.pos += length;
        if (Array.isArray(this.buf))
          // plain array
          return this.buf.slice(start, end);
        return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
          ? new this.buf.constructor(0)
          : this._slice.call(this.buf, start, end);
      };

      /**
       * Reads a string preceeded by its byte length as a varint.
       * @returns {string} Value read
       */
      Reader.prototype.string = function read_string() {
        var bytes = this.bytes();
        return utf8.read(bytes, 0, bytes.length);
      };

      /**
       * Skips the specified number of bytes if specified, otherwise skips a varint.
       * @param {number} [length] Length if known, otherwise a varint is assumed
       * @returns {Reader} `this`
       */
      Reader.prototype.skip = function skip(length) {
        if (typeof length === "number") {
          /* istanbul ignore if */
          if (this.pos + length > this.len) throw indexOutOfRange(this, length);
          this.pos += length;
        } else {
          do {
            /* istanbul ignore if */
            if (this.pos >= this.len) throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      };

      /**
       * Skips the next element of the specified wire type.
       * @param {number} wireType Wire type received
       * @returns {Reader} `this`
       */
      Reader.prototype.skipType = function (wireType) {
        switch (wireType) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case 5:
            this.skip(4);
            break;

          /* istanbul ignore next */
          default:
            throw Error(
              "invalid wire type " + wireType + " at offset " + this.pos
            );
        }
        return this;
      };

      Reader._configure = function (BufferReader_) {
        BufferReader = BufferReader_;
        Reader.create = create();
        BufferReader._configure();

        var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
        util.merge(Reader.prototype, {
          int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
          },

          uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
          },

          sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
          },

          fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
          },

          sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
          },
        });
      };

      /***/
    },

    /***/ 593: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = BufferReader;

      // extends Reader
      var Reader = __webpack_require__(1408);
      (BufferReader.prototype = Object.create(Reader.prototype)).constructor =
        BufferReader;

      var util = __webpack_require__(9693);

      /**
       * Constructs a new buffer reader instance.
       * @classdesc Wire format reader using node buffers.
       * @extends Reader
       * @constructor
       * @param {Buffer} buffer Buffer to read from
       */
      function BufferReader(buffer) {
        Reader.call(this, buffer);

        /**
         * Read buffer.
         * @name BufferReader#buf
         * @type {Buffer}
         */
      }

      BufferReader._configure = function () {
        /* istanbul ignore else */
        if (util.Buffer)
          BufferReader.prototype._slice = util.Buffer.prototype.slice;
      };

      /**
       * @override
       */
      BufferReader.prototype.string = function read_string_buffer() {
        var len = this.uint32(); // modifies pos
        return this.buf.utf8Slice
          ? this.buf.utf8Slice(
              this.pos,
              (this.pos = Math.min(this.pos + len, this.len))
            )
          : this.buf.toString(
              "utf-8",
              this.pos,
              (this.pos = Math.min(this.pos + len, this.len))
            );
      };

      /**
       * Reads a sequence of bytes preceeded by its length as a varint.
       * @name BufferReader#bytes
       * @function
       * @returns {Buffer} Value read
       */

      BufferReader._configure();

      /***/
    },

    /***/ 9424: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Root;

      // extends Namespace
      var Namespace = __webpack_require__(9313);
      ((Root.prototype = Object.create(Namespace.prototype)).constructor =
        Root).className = "Root";

      var Field = __webpack_require__(3548),
        Enum = __webpack_require__(7025),
        OneOf = __webpack_require__(7598),
        util = __webpack_require__(9935);

      var Type, // cyclic
        parse, // might be excluded
        common; // "

      /**
       * Constructs a new root namespace instance.
       * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
       * @extends NamespaceBase
       * @constructor
       * @param {Object.<string,*>} [options] Top level options
       */
      function Root(options) {
        Namespace.call(this, "", options);

        /**
         * Deferred extension fields.
         * @type {Field[]}
         */
        this.deferred = [];

        /**
         * Resolved file names of loaded files.
         * @type {string[]}
         */
        this.files = [];
      }

      /**
       * Loads a namespace descriptor into a root namespace.
       * @param {INamespace} json Nameespace descriptor
       * @param {Root} [root] Root namespace, defaults to create a new one if omitted
       * @returns {Root} Root namespace
       */
      Root.fromJSON = function fromJSON(json, root) {
        if (!root) root = new Root();
        if (json.options) root.setOptions(json.options);
        return root.addJSON(json.nested);
      };

      /**
       * Resolves the path of an imported file, relative to the importing origin.
       * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
       * @function
       * @param {string} origin The file name of the importing file
       * @param {string} target The file name being imported
       * @returns {string|null} Resolved path to `target` or `null` to skip the file
       */
      Root.prototype.resolvePath = util.path.resolve;

      /**
       * Fetch content from file path or url
       * This method exists so you can override it with your own logic.
       * @function
       * @param {string} path File path or url
       * @param {FetchCallback} callback Callback function
       * @returns {undefined}
       */
      Root.prototype.fetch = util.fetch;

      // A symbol-like function to safely signal synchronous loading
      /* istanbul ignore next */
      function SYNC() {} // eslint-disable-line no-empty-function

      /**
       * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
       * @param {string|string[]} filename Names of one or multiple files to load
       * @param {IParseOptions} options Parse options
       * @param {LoadCallback} callback Callback function
       * @returns {undefined}
       */
      Root.prototype.load = function load(filename, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = undefined;
        }
        var self = this;
        if (!callback) return util.asPromise(load, self, filename, options);

        var sync = callback === SYNC; // undocumented

        // Finishes loading by calling the callback (exactly once)
        function finish(err, root) {
          /* istanbul ignore if */
          if (!callback) return;
          var cb = callback;
          callback = null;
          if (sync) throw err;
          cb(err, root);
        }

        // Bundled definition existence checking
        function getBundledFileName(filename) {
          var idx = filename.lastIndexOf("google/protobuf/");
          if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common) return altname;
          }
          return null;
        }

        // Processes a single file
        function process(filename, source) {
          try {
            if (util.isString(source) && source.charAt(0) === "{")
              source = JSON.parse(source);
            if (!util.isString(source))
              self.setOptions(source.options).addJSON(source.nested);
            else {
              parse.filename = filename;
              var parsed = parse(source, self, options),
                resolved,
                i = 0;
              if (parsed.imports)
                for (; i < parsed.imports.length; ++i)
                  if (
                    (resolved =
                      getBundledFileName(parsed.imports[i]) ||
                      self.resolvePath(filename, parsed.imports[i]))
                  )
                    fetch(resolved);
              if (parsed.weakImports)
                for (i = 0; i < parsed.weakImports.length; ++i)
                  if (
                    (resolved =
                      getBundledFileName(parsed.weakImports[i]) ||
                      self.resolvePath(filename, parsed.weakImports[i]))
                  )
                    fetch(resolved, true);
            }
          } catch (err) {
            finish(err);
          }
          if (!sync && !queued) finish(null, self); // only once anyway
        }

        // Fetches a single file
        function fetch(filename, weak) {
          // Skip if already loaded / attempted
          if (self.files.indexOf(filename) > -1) return;
          self.files.push(filename);

          // Shortcut bundled definitions
          if (filename in common) {
            if (sync) process(filename, common[filename]);
            else {
              ++queued;
              setTimeout(function () {
                --queued;
                process(filename, common[filename]);
              });
            }
            return;
          }

          // Otherwise fetch from disk or network
          if (sync) {
            var source;
            try {
              source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
              if (!weak) finish(err);
              return;
            }
            process(filename, source);
          } else {
            ++queued;
            self.fetch(filename, function (err, source) {
              --queued;
              /* istanbul ignore if */
              if (!callback) return; // terminated meanwhile
              if (err) {
                /* istanbul ignore else */
                if (!weak) finish(err);
                else if (!queued)
                  // can't be covered reliably
                  finish(null, self);
                return;
              }
              process(filename, source);
            });
          }
        }
        var queued = 0;

        // Assembling the root namespace doesn't require working type
        // references anymore, so we can load everything in parallel
        if (util.isString(filename)) filename = [filename];
        for (var i = 0, resolved; i < filename.length; ++i)
          if ((resolved = self.resolvePath("", filename[i]))) fetch(resolved);

        if (sync) return self;
        if (!queued) finish(null, self);
        return undefined;
      };
      // function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

      /**
       * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
       * @function Root#load
       * @param {string|string[]} filename Names of one or multiple files to load
       * @param {LoadCallback} callback Callback function
       * @returns {undefined}
       * @variation 2
       */
      // function load(filename:string, callback:LoadCallback):undefined

      /**
       * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
       * @function Root#load
       * @param {string|string[]} filename Names of one or multiple files to load
       * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
       * @returns {Promise<Root>} Promise
       * @variation 3
       */
      // function load(filename:string, [options:IParseOptions]):Promise<Root>

      /**
       * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
       * @function Root#loadSync
       * @param {string|string[]} filename Names of one or multiple files to load
       * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
       * @returns {Root} Root namespace
       * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
       */
      Root.prototype.loadSync = function loadSync(filename, options) {
        if (!util.isNode) throw Error("not supported");
        return this.load(filename, options, SYNC);
      };

      /**
       * @override
       */
      Root.prototype.resolveAll = function resolveAll() {
        if (this.deferred.length)
          throw Error(
            "unresolvable extensions: " +
              this.deferred
                .map(function (field) {
                  return (
                    "'extend " + field.extend + "' in " + field.parent.fullName
                  );
                })
                .join(", ")
          );
        return Namespace.prototype.resolveAll.call(this);
      };

      // only uppercased (and thus conflict-free) children are exposed, see below
      var exposeRe = /^[A-Z]/;

      /**
       * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
       * @param {Root} root Root instance
       * @param {Field} field Declaring extension field witin the declaring type
       * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
       * @inner
       * @ignore
       */
      function tryHandleExtension(root, field) {
        var extendedType = field.parent.lookup(field.extend);
        if (extendedType) {
          var sisterField = new Field(
            field.fullName,
            field.id,
            field.type,
            field.rule,
            undefined,
            field.options
          );
          sisterField.declaringField = field;
          field.extensionField = sisterField;
          extendedType.add(sisterField);
          return true;
        }
        return false;
      }

      /**
       * Called when any object is added to this root or its sub-namespaces.
       * @param {ReflectionObject} object Object added
       * @returns {undefined}
       * @private
       */
      Root.prototype._handleAdd = function _handleAdd(object) {
        if (object instanceof Field) {
          if (
            /* an extension field (implies not part of a oneof) */ object.extend !==
              undefined &&
            /* not already handled */ !object.extensionField
          )
            if (!tryHandleExtension(this, object)) this.deferred.push(object);
        } else if (object instanceof Enum) {
          if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent
        } else if (!(object instanceof OneOf)) {
          /* everything else is a namespace */ if (object instanceof Type)
            // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length; )
              if (tryHandleExtension(this, this.deferred[i]))
                this.deferred.splice(i, 1);
              else ++i;
          for (
            var j = 0;
            j < /* initializes */ object.nestedArray.length;
            ++j // recurse into the namespace
          )
            this._handleAdd(object._nestedArray[j]);
          if (exposeRe.test(object.name)) object.parent[object.name] = object; // expose namespace as property of its parent
        }

        // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
        // properties of namespaces just like static code does. This allows using a .d.ts generated for
        // a static module with reflection-based solutions where the condition is met.
      };

      /**
       * Called when any object is removed from this root or its sub-namespaces.
       * @param {ReflectionObject} object Object removed
       * @returns {undefined}
       * @private
       */
      Root.prototype._handleRemove = function _handleRemove(object) {
        if (object instanceof Field) {
          if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) {
              // remove its sister field
              object.extensionField.parent.remove(object.extensionField);
              object.extensionField = null;
            } else {
              // cancel the extension
              var index = this.deferred.indexOf(object);
              /* istanbul ignore else */
              if (index > -1) this.deferred.splice(index, 1);
            }
          }
        } else if (object instanceof Enum) {
          if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose enum values
        } else if (object instanceof Namespace) {
          for (
            var i = 0;
            i < /* initializes */ object.nestedArray.length;
            ++i // recurse into the namespace
          )
            this._handleRemove(object._nestedArray[i]);

          if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose namespaces
        }
      };

      // Sets up cyclic dependencies (called in index-light)
      Root._configure = function (Type_, parse_, common_) {
        Type = Type_;
        parse = parse_;
        common = common_;
      };

      /***/
    },

    /***/ 5054: /***/ (module) => {
      "use strict";

      module.exports = {};

      /**
       * Named roots.
       * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
       * Can also be used manually to make roots available accross modules.
       * @name roots
       * @type {Object.<string,Root>}
       * @example
       * // pbjs -r myroot -o compiled.js ...
       *
       * // in another module:
       * require("./compiled.js");
       *
       * // in any subsequent module:
       * var root = protobuf.roots["myroot"];
       */

      /***/
    },

    /***/ 5994: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      /**
       * Streaming RPC helpers.
       * @namespace
       */
      var rpc = exports;

      /**
       * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
       * @typedef RPCImpl
       * @type {function}
       * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
       * @param {Uint8Array} requestData Request data
       * @param {RPCImplCallback} callback Callback function
       * @returns {undefined}
       * @example
       * function rpcImpl(method, requestData, callback) {
       *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
       *         throw Error("no such method");
       *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
       *         callback(err, responseData);
       *     });
       * }
       */

      /**
       * Node-style callback as used by {@link RPCImpl}.
       * @typedef RPCImplCallback
       * @type {function}
       * @param {Error|null} error Error, if any, otherwise `null`
       * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
       * @returns {undefined}
       */

      rpc.Service = __webpack_require__(7948);

      /***/
    },

    /***/ 7948: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Service;

      var util = __webpack_require__(9693);

      // Extends EventEmitter
      (Service.prototype = Object.create(
        util.EventEmitter.prototype
      )).constructor = Service;

      /**
       * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
       *
       * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
       * @typedef rpc.ServiceMethodCallback
       * @template TRes extends Message<TRes>
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {TRes} [response] Response message
       * @returns {undefined}
       */

      /**
       * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
       * @typedef rpc.ServiceMethod
       * @template TReq extends Message<TReq>
       * @template TRes extends Message<TRes>
       * @type {function}
       * @param {TReq|Properties<TReq>} request Request message or plain object
       * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
       * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
       */

      /**
       * Constructs a new RPC service instance.
       * @classdesc An RPC service as returned by {@link Service#create}.
       * @exports rpc.Service
       * @extends util.EventEmitter
       * @constructor
       * @param {RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Service(rpcImpl, requestDelimited, responseDelimited) {
        if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");

        util.EventEmitter.call(this);

        /**
         * RPC implementation. Becomes `null` once the service is ended.
         * @type {RPCImpl|null}
         */
        this.rpcImpl = rpcImpl;

        /**
         * Whether requests are length-delimited.
         * @type {boolean}
         */
        this.requestDelimited = Boolean(requestDelimited);

        /**
         * Whether responses are length-delimited.
         * @type {boolean}
         */
        this.responseDelimited = Boolean(responseDelimited);
      }

      /**
       * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
       * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
       * @param {Constructor<TReq>} requestCtor Request constructor
       * @param {Constructor<TRes>} responseCtor Response constructor
       * @param {TReq|Properties<TReq>} request Request message or plain object
       * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
       * @returns {undefined}
       * @template TReq extends Message<TReq>
       * @template TRes extends Message<TRes>
       */
      Service.prototype.rpcCall = function rpcCall(
        method,
        requestCtor,
        responseCtor,
        request,
        callback
      ) {
        if (!request) throw TypeError("request must be specified");

        var self = this;
        if (!callback)
          return util.asPromise(
            rpcCall,
            self,
            method,
            requestCtor,
            responseCtor,
            request
          );

        if (!self.rpcImpl) {
          setTimeout(function () {
            callback(Error("already ended"));
          }, 0);
          return undefined;
        }

        try {
          return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](
              request
            ).finish(),
            function rpcCallback(err, response) {
              if (err) {
                self.emit("error", err, method);
                return callback(err);
              }

              if (response === null) {
                self.end(/* endedByRPC */ true);
                return undefined;
              }

              if (!(response instanceof responseCtor)) {
                try {
                  response =
                    responseCtor[
                      self.responseDelimited ? "decodeDelimited" : "decode"
                    ](response);
                } catch (err) {
                  self.emit("error", err, method);
                  return callback(err);
                }
              }

              self.emit("data", response, method);
              return callback(null, response);
            }
          );
        } catch (err) {
          self.emit("error", err, method);
          setTimeout(function () {
            callback(err);
          }, 0);
          return undefined;
        }
      };

      /**
       * Ends this service and emits the `end` event.
       * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
       * @returns {rpc.Service} `this`
       */
      Service.prototype.end = function end(endedByRPC) {
        if (this.rpcImpl) {
          if (!endedByRPC)
            // signal end to rpcImpl
            this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
        }
        return this;
      };

      /***/
    },

    /***/ 7513: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Service;

      // extends Namespace
      var Namespace = __webpack_require__(9313);
      ((Service.prototype = Object.create(Namespace.prototype)).constructor =
        Service).className = "Service";

      var Method = __webpack_require__(4429),
        util = __webpack_require__(9935),
        rpc = __webpack_require__(5994);

      /**
       * Constructs a new service instance.
       * @classdesc Reflected service.
       * @extends NamespaceBase
       * @constructor
       * @param {string} name Service name
       * @param {Object.<string,*>} [options] Service options
       * @throws {TypeError} If arguments are invalid
       */
      function Service(name, options) {
        Namespace.call(this, name, options);

        /**
         * Service methods.
         * @type {Object.<string,Method>}
         */
        this.methods = {}; // toJSON, marker

        /**
         * Cached methods as an array.
         * @type {Method[]|null}
         * @private
         */
        this._methodsArray = null;
      }

      /**
       * Service descriptor.
       * @interface IService
       * @extends INamespace
       * @property {Object.<string,IMethod>} methods Method descriptors
       */

      /**
       * Constructs a service from a service descriptor.
       * @param {string} name Service name
       * @param {IService} json Service descriptor
       * @returns {Service} Created service
       * @throws {TypeError} If arguments are invalid
       */
      Service.fromJSON = function fromJSON(name, json) {
        var service = new Service(name, json.options);
        /* istanbul ignore else */
        if (json.methods)
          for (
            var names = Object.keys(json.methods), i = 0;
            i < names.length;
            ++i
          )
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
        if (json.nested) service.addJSON(json.nested);
        service.comment = json.comment;
        return service;
      };

      /**
       * Converts this service to a service descriptor.
       * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
       * @returns {IService} Service descriptor
       */
      Service.prototype.toJSON = function toJSON(toJSONOptions) {
        var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
        var keepComments = toJSONOptions
          ? Boolean(toJSONOptions.keepComments)
          : false;
        return util.toObject([
          "options",
          (inherited && inherited.options) || undefined,
          "methods",
          Namespace.arrayToJSON(this.methodsArray, toJSONOptions) ||
            /* istanbul ignore next */ {},
          "nested",
          (inherited && inherited.nested) || undefined,
          "comment",
          keepComments ? this.comment : undefined,
        ]);
      };

      /**
       * Methods of this service as an array for iteration.
       * @name Service#methodsArray
       * @type {Method[]}
       * @readonly
       */
      Object.defineProperty(Service.prototype, "methodsArray", {
        get: function () {
          return (
            this._methodsArray ||
            (this._methodsArray = util.toArray(this.methods))
          );
        },
      });

      function clearCache(service) {
        service._methodsArray = null;
        return service;
      }

      /**
       * @override
       */
      Service.prototype.get = function get(name) {
        return this.methods[name] || Namespace.prototype.get.call(this, name);
      };

      /**
       * @override
       */
      Service.prototype.resolveAll = function resolveAll() {
        var methods = this.methodsArray;
        for (var i = 0; i < methods.length; ++i) methods[i].resolve();
        return Namespace.prototype.resolve.call(this);
      };

      /**
       * @override
       */
      Service.prototype.add = function add(object) {
        /* istanbul ignore if */
        if (this.get(object.name))
          throw Error("duplicate name '" + object.name + "' in " + this);

        if (object instanceof Method) {
          this.methods[object.name] = object;
          object.parent = this;
          return clearCache(this);
        }
        return Namespace.prototype.add.call(this, object);
      };

      /**
       * @override
       */
      Service.prototype.remove = function remove(object) {
        if (object instanceof Method) {
          /* istanbul ignore if */
          if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

          delete this.methods[object.name];
          object.parent = null;
          return clearCache(this);
        }
        return Namespace.prototype.remove.call(this, object);
      };

      /**
       * Creates a runtime service using the specified rpc implementation.
       * @param {RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
       */
      Service.prototype.create = function create(
        rpcImpl,
        requestDelimited,
        responseDelimited
      ) {
        var rpcService = new rpc.Service(
          rpcImpl,
          requestDelimited,
          responseDelimited
        );
        for (
          var i = 0, method;
          i < /* initializes */ this.methodsArray.length;
          ++i
        ) {
          var methodName = util
            .lcFirst((method = this._methodsArray[i]).resolve().name)
            .replace(/[^$\w_]/g, "");
          rpcService[methodName] = util.codegen(
            ["r", "c"],
            util.isReserved(methodName) ? methodName + "_" : methodName
          )("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor,
          });
        }
        return rpcService;
      };

      /***/
    },

    /***/ 7645: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Type;

      // extends Namespace
      var Namespace = __webpack_require__(9313);
      ((Type.prototype = Object.create(Namespace.prototype)).constructor =
        Type).className = "Type";

      var Enum = __webpack_require__(7025),
        OneOf = __webpack_require__(7598),
        Field = __webpack_require__(3548),
        MapField = __webpack_require__(6039),
        Service = __webpack_require__(7513),
        Message = __webpack_require__(8368),
        Reader = __webpack_require__(1408),
        Writer = __webpack_require__(1173),
        util = __webpack_require__(9935),
        encoder = __webpack_require__(4928),
        decoder = __webpack_require__(5305),
        verifier = __webpack_require__(4497),
        converter = __webpack_require__(3996),
        wrappers = __webpack_require__(1667);

      /**
       * Constructs a new reflected message type instance.
       * @classdesc Reflected message type.
       * @extends NamespaceBase
       * @constructor
       * @param {string} name Message name
       * @param {Object.<string,*>} [options] Declared options
       */
      function Type(name, options) {
        Namespace.call(this, name, options);

        /**
         * Message fields.
         * @type {Object.<string,Field>}
         */
        this.fields = {}; // toJSON, marker

        /**
         * Oneofs declared within this namespace, if any.
         * @type {Object.<string,OneOf>}
         */
        this.oneofs = undefined; // toJSON

        /**
         * Extension ranges, if any.
         * @type {number[][]}
         */
        this.extensions = undefined; // toJSON

        /**
         * Reserved ranges, if any.
         * @type {Array.<number[]|string>}
         */
        this.reserved = undefined; // toJSON

        /*?
         * Whether this type is a legacy group.
         * @type {boolean|undefined}
         */
        this.group = undefined; // toJSON

        /**
         * Cached fields by id.
         * @type {Object.<number,Field>|null}
         * @private
         */
        this._fieldsById = null;

        /**
         * Cached fields as an array.
         * @type {Field[]|null}
         * @private
         */
        this._fieldsArray = null;

        /**
         * Cached oneofs as an array.
         * @type {OneOf[]|null}
         * @private
         */
        this._oneofsArray = null;

        /**
         * Cached constructor.
         * @type {Constructor<{}>}
         * @private
         */
        this._ctor = null;
      }

      Object.defineProperties(Type.prototype, {
        /**
         * Message fields by id.
         * @name Type#fieldsById
         * @type {Object.<number,Field>}
         * @readonly
         */
        fieldsById: {
          get: function () {
            /* istanbul ignore if */
            if (this._fieldsById) return this._fieldsById;

            this._fieldsById = {};
            for (
              var names = Object.keys(this.fields), i = 0;
              i < names.length;
              ++i
            ) {
              var field = this.fields[names[i]],
                id = field.id;

              /* istanbul ignore if */
              if (this._fieldsById[id])
                throw Error("duplicate id " + id + " in " + this);

              this._fieldsById[id] = field;
            }
            return this._fieldsById;
          },
        },

        /**
         * Fields of this message as an array for iteration.
         * @name Type#fieldsArray
         * @type {Field[]}
         * @readonly
         */
        fieldsArray: {
          get: function () {
            return (
              this._fieldsArray ||
              (this._fieldsArray = util.toArray(this.fields))
            );
          },
        },

        /**
         * Oneofs of this message as an array for iteration.
         * @name Type#oneofsArray
         * @type {OneOf[]}
         * @readonly
         */
        oneofsArray: {
          get: function () {
            return (
              this._oneofsArray ||
              (this._oneofsArray = util.toArray(this.oneofs))
            );
          },
        },

        /**
         * The registered constructor, if any registered, otherwise a generic constructor.
         * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
         * @name Type#ctor
         * @type {Constructor<{}>}
         */
        ctor: {
          get: function () {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
          },
          set: function (ctor) {
            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
              (ctor.prototype = new Message()).constructor = ctor;
              util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
              this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
              ctorProperties[this._oneofsArray[i].resolve().name] = {
                get: util.oneOfGetter(this._oneofsArray[i].oneof),
                set: util.oneOfSetter(this._oneofsArray[i].oneof),
              };
            if (i) Object.defineProperties(ctor.prototype, ctorProperties);
          },
        },
      });

      /**
       * Generates a constructor function for the specified type.
       * @param {Type} mtype Message type
       * @returns {Codegen} Codegen instance
       */
      Type.generateConstructor = function generateConstructor(mtype) {
        /* eslint-disable no-unexpected-multiline */
        var gen = util.codegen(["p"], mtype.name);
        // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
        for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
          if ((field = mtype._fieldsArray[i]).map)
            gen("this%s={}", util.safeProp(field.name));
          else if (field.repeated) gen("this%s=[]", util.safeProp(field.name));
        return gen(
          "if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)"
        )(
          // omit undefined or null
          "this[ks[i]]=p[ks[i]]"
        );
        /* eslint-enable no-unexpected-multiline */
      };

      function clearCache(type) {
        type._fieldsById = type._fieldsArray = type._oneofsArray = null;
        delete type.encode;
        delete type.decode;
        delete type.verify;
        return type;
      }

      /**
       * Message type descriptor.
       * @interface IType
       * @extends INamespace
       * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
       * @property {Object.<string,IField>} fields Field descriptors
       * @property {number[][]} [extensions] Extension ranges
       * @property {number[][]} [reserved] Reserved ranges
       * @property {boolean} [group=false] Whether a legacy group or not
       */

      /**
       * Creates a message type from a message type descriptor.
       * @param {string} name Message name
       * @param {IType} json Message type descriptor
       * @returns {Type} Created message type
       */
      Type.fromJSON = function fromJSON(name, json) {
        var type = new Type(name, json.options);
        type.extensions = json.extensions;
        type.reserved = json.reserved;
        var names = Object.keys(json.fields),
          i = 0;
        for (; i < names.length; ++i)
          type.add(
            (typeof json.fields[names[i]].keyType !== "undefined"
              ? MapField.fromJSON
              : Field.fromJSON)(names[i], json.fields[names[i]])
          );
        if (json.oneofs)
          for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
        if (json.nested)
          for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add(
              // most to least likely
              (nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON)(names[i], nested)
            );
          }
        if (json.extensions && json.extensions.length)
          type.extensions = json.extensions;
        if (json.reserved && json.reserved.length)
          type.reserved = json.reserved;
        if (json.group) type.group = true;
        if (json.comment) type.comment = json.comment;
        return type;
      };

      /**
       * Converts this message type to a message type descriptor.
       * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
       * @returns {IType} Message type descriptor
       */
      Type.prototype.toJSON = function toJSON(toJSONOptions) {
        var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
        var keepComments = toJSONOptions
          ? Boolean(toJSONOptions.keepComments)
          : false;
        return util.toObject([
          "options",
          (inherited && inherited.options) || undefined,
          "oneofs",
          Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
          "fields",
          Namespace.arrayToJSON(
            this.fieldsArray.filter(function (obj) {
              return !obj.declaringField;
            }),
            toJSONOptions
          ) || {},
          "extensions",
          this.extensions && this.extensions.length
            ? this.extensions
            : undefined,
          "reserved",
          this.reserved && this.reserved.length ? this.reserved : undefined,
          "group",
          this.group || undefined,
          "nested",
          (inherited && inherited.nested) || undefined,
          "comment",
          keepComments ? this.comment : undefined,
        ]);
      };

      /**
       * @override
       */
      Type.prototype.resolveAll = function resolveAll() {
        var fields = this.fieldsArray,
          i = 0;
        while (i < fields.length) fields[i++].resolve();
        var oneofs = this.oneofsArray;
        i = 0;
        while (i < oneofs.length) oneofs[i++].resolve();
        return Namespace.prototype.resolveAll.call(this);
      };

      /**
       * @override
       */
      Type.prototype.get = function get(name) {
        return (
          this.fields[name] ||
          (this.oneofs && this.oneofs[name]) ||
          (this.nested && this.nested[name]) ||
          null
        );
      };

      /**
       * Adds a nested object to this type.
       * @param {ReflectionObject} object Nested object to add
       * @returns {Type} `this`
       * @throws {TypeError} If arguments are invalid
       * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
       */
      Type.prototype.add = function add(object) {
        if (this.get(object.name))
          throw Error("duplicate name '" + object.name + "' in " + this);

        if (object instanceof Field && object.extend === undefined) {
          // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
          // The root object takes care of adding distinct sister-fields to the respective extended
          // type instead.

          // avoids calling the getter if not absolutely necessary because it's called quite frequently
          if (
            this._fieldsById
              ? /* istanbul ignore next */ this._fieldsById[object.id]
              : this.fieldsById[object.id]
          )
            throw Error("duplicate id " + object.id + " in " + this);
          if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
          if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

          if (object.parent) object.parent.remove(object);
          this.fields[object.name] = object;
          object.message = this;
          object.onAdd(this);
          return clearCache(this);
        }
        if (object instanceof OneOf) {
          if (!this.oneofs) this.oneofs = {};
          this.oneofs[object.name] = object;
          object.onAdd(this);
          return clearCache(this);
        }
        return Namespace.prototype.add.call(this, object);
      };

      /**
       * Removes a nested object from this type.
       * @param {ReflectionObject} object Nested object to remove
       * @returns {Type} `this`
       * @throws {TypeError} If arguments are invalid
       * @throws {Error} If `object` is not a member of this type
       */
      Type.prototype.remove = function remove(object) {
        if (object instanceof Field && object.extend === undefined) {
          // See Type#add for the reason why extension fields are excluded here.

          /* istanbul ignore if */
          if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

          delete this.fields[object.name];
          object.parent = null;
          object.onRemove(this);
          return clearCache(this);
        }
        if (object instanceof OneOf) {
          /* istanbul ignore if */
          if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

          delete this.oneofs[object.name];
          object.parent = null;
          object.onRemove(this);
          return clearCache(this);
        }
        return Namespace.prototype.remove.call(this, object);
      };

      /**
       * Tests if the specified id is reserved.
       * @param {number} id Id to test
       * @returns {boolean} `true` if reserved, otherwise `false`
       */
      Type.prototype.isReservedId = function isReservedId(id) {
        return Namespace.isReservedId(this.reserved, id);
      };

      /**
       * Tests if the specified name is reserved.
       * @param {string} name Name to test
       * @returns {boolean} `true` if reserved, otherwise `false`
       */
      Type.prototype.isReservedName = function isReservedName(name) {
        return Namespace.isReservedName(this.reserved, name);
      };

      /**
       * Creates a new message of this type using the specified properties.
       * @param {Object.<string,*>} [properties] Properties to set
       * @returns {Message<{}>} Message instance
       */
      Type.prototype.create = function create(properties) {
        return new this.ctor(properties);
      };

      /**
       * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
       * @returns {Type} `this`
       */
      Type.prototype.setup = function setup() {
        // Sets up everything at once so that the prototype chain does not have to be re-evaluated
        // multiple times (V8, soft-deopt prototype-check).

        var fullName = this.fullName,
          types = [];
        for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
          types.push(this._fieldsArray[i].resolve().resolvedType);

        // Replace setup methods with type-specific generated functions
        this.encode = encoder(this)({
          Writer: Writer,
          types: types,
          util: util,
        });
        this.decode = decoder(this)({
          Reader: Reader,
          types: types,
          util: util,
        });
        this.verify = verifier(this)({
          types: types,
          util: util,
        });
        this.fromObject = converter.fromObject(this)({
          types: types,
          util: util,
        });
        this.toObject = converter.toObject(this)({
          types: types,
          util: util,
        });

        // Inject custom wrappers for common types
        var wrapper = wrappers[fullName];
        if (wrapper) {
          var originalThis = Object.create(this);
          // if (wrapper.fromObject) {
          originalThis.fromObject = this.fromObject;
          this.fromObject = wrapper.fromObject.bind(originalThis);
          // }
          // if (wrapper.toObject) {
          originalThis.toObject = this.toObject;
          this.toObject = wrapper.toObject.bind(originalThis);
          // }
        }

        return this;
      };

      /**
       * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
       * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
       * @param {Writer} [writer] Writer to encode to
       * @returns {Writer} writer
       */
      Type.prototype.encode = function encode_setup(message, writer) {
        return this.setup().encode(message, writer); // overrides this method
      };

      /**
       * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
       * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
       * @param {Writer} [writer] Writer to encode to
       * @returns {Writer} writer
       */
      Type.prototype.encodeDelimited = function encodeDelimited(
        message,
        writer
      ) {
        return this.encode(
          message,
          writer && writer.len ? writer.fork() : writer
        ).ldelim();
      };

      /**
       * Decodes a message of this type.
       * @param {Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Length of the message, if known beforehand
       * @returns {Message<{}>} Decoded message
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {util.ProtocolError<{}>} If required fields are missing
       */
      Type.prototype.decode = function decode_setup(reader, length) {
        return this.setup().decode(reader, length); // overrides this method
      };

      /**
       * Decodes a message of this type preceeded by its byte length as a varint.
       * @param {Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Message<{}>} Decoded message
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {util.ProtocolError} If required fields are missing
       */
      Type.prototype.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof Reader)) reader = Reader.create(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies that field values are valid and that required fields are present.
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {null|string} `null` if valid, otherwise the reason why it is not
       */
      Type.prototype.verify = function verify_setup(message) {
        return this.setup().verify(message); // overrides this method
      };

      /**
       * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
       * @param {Object.<string,*>} object Plain object to convert
       * @returns {Message<{}>} Message instance
       */
      Type.prototype.fromObject = function fromObject(object) {
        return this.setup().fromObject(object);
      };

      /**
       * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
       * @interface IConversionOptions
       * @property {Function} [longs] Long conversion type.
       * Valid values are `String` and `Number` (the global types).
       * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
       * @property {Function} [enums] Enum value conversion type.
       * Only valid value is `String` (the global type).
       * Defaults to copy the present value, which is the numeric id.
       * @property {Function} [bytes] Bytes value conversion type.
       * Valid values are `Array` and (a base64 encoded) `String` (the global types).
       * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
       * @property {boolean} [defaults=false] Also sets default values on the resulting object
       * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
       * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
       * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
       * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
       */

      /**
       * Creates a plain object from a message of this type. Also converts values to other types if specified.
       * @param {Message<{}>} message Message instance
       * @param {IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Type.prototype.toObject = function toObject(message, options) {
        return this.setup().toObject(message, options);
      };

      /**
       * Decorator function as returned by {@link Type.d} (TypeScript).
       * @typedef TypeDecorator
       * @type {function}
       * @param {Constructor<T>} target Target constructor
       * @returns {undefined}
       * @template T extends Message<T>
       */

      /**
       * Type decorator (TypeScript).
       * @param {string} [typeName] Type name, defaults to the constructor's name
       * @returns {TypeDecorator<T>} Decorator function
       * @template T extends Message<T>
       */
      Type.d = function decorateType(typeName) {
        return function typeDecorator(target) {
          util.decorateType(target, typeName);
        };
      };

      /***/
    },

    /***/ 7063: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      /**
       * Common type constants.
       * @namespace
       */
      var types = exports;

      var util = __webpack_require__(9935);

      var s = [
        "double", // 0
        "float", // 1
        "int32", // 2
        "uint32", // 3
        "sint32", // 4
        "fixed32", // 5
        "sfixed32", // 6
        "int64", // 7
        "uint64", // 8
        "sint64", // 9
        "fixed64", // 10
        "sfixed64", // 11
        "bool", // 12
        "string", // 13
        "bytes", // 14
      ];

      function bake(values, offset) {
        var i = 0,
          o = {};
        offset |= 0;
        while (i < values.length) o[s[i + offset]] = values[i++];
        return o;
      }

      /**
       * Basic type wire types.
       * @type {Object.<string,number>}
       * @const
       * @property {number} double=1 Fixed64 wire type
       * @property {number} float=5 Fixed32 wire type
       * @property {number} int32=0 Varint wire type
       * @property {number} uint32=0 Varint wire type
       * @property {number} sint32=0 Varint wire type
       * @property {number} fixed32=5 Fixed32 wire type
       * @property {number} sfixed32=5 Fixed32 wire type
       * @property {number} int64=0 Varint wire type
       * @property {number} uint64=0 Varint wire type
       * @property {number} sint64=0 Varint wire type
       * @property {number} fixed64=1 Fixed64 wire type
       * @property {number} sfixed64=1 Fixed64 wire type
       * @property {number} bool=0 Varint wire type
       * @property {number} string=2 Ldelim wire type
       * @property {number} bytes=2 Ldelim wire type
       */
      types.basic = bake([
        /* double   */ 1, /* float    */ 5, /* int32    */ 0, /* uint32   */ 0,
        /* sint32   */ 0, /* fixed32  */ 5, /* sfixed32 */ 5, /* int64    */ 0,
        /* uint64   */ 0, /* sint64   */ 0, /* fixed64  */ 1, /* sfixed64 */ 1,
        /* bool     */ 0, /* string   */ 2, /* bytes    */ 2,
      ]);

      /**
       * Basic type defaults.
       * @type {Object.<string,*>}
       * @const
       * @property {number} double=0 Double default
       * @property {number} float=0 Float default
       * @property {number} int32=0 Int32 default
       * @property {number} uint32=0 Uint32 default
       * @property {number} sint32=0 Sint32 default
       * @property {number} fixed32=0 Fixed32 default
       * @property {number} sfixed32=0 Sfixed32 default
       * @property {number} int64=0 Int64 default
       * @property {number} uint64=0 Uint64 default
       * @property {number} sint64=0 Sint32 default
       * @property {number} fixed64=0 Fixed64 default
       * @property {number} sfixed64=0 Sfixed64 default
       * @property {boolean} bool=false Bool default
       * @property {string} string="" String default
       * @property {Array.<number>} bytes=Array(0) Bytes default
       * @property {null} message=null Message default
       */
      types.defaults = bake([
        /* double   */ 0,
        /* float    */ 0,
        /* int32    */ 0,
        /* uint32   */ 0,
        /* sint32   */ 0,
        /* fixed32  */ 0,
        /* sfixed32 */ 0,
        /* int64    */ 0,
        /* uint64   */ 0,
        /* sint64   */ 0,
        /* fixed64  */ 0,
        /* sfixed64 */ 0,
        /* bool     */ false,
        /* string   */ "",
        /* bytes    */ util.emptyArray,
        /* message  */ null,
      ]);

      /**
       * Basic long type wire types.
       * @type {Object.<string,number>}
       * @const
       * @property {number} int64=0 Varint wire type
       * @property {number} uint64=0 Varint wire type
       * @property {number} sint64=0 Varint wire type
       * @property {number} fixed64=1 Fixed64 wire type
       * @property {number} sfixed64=1 Fixed64 wire type
       */
      types.long = bake(
        [
          /* int64    */ 0, /* uint64   */ 0, /* sint64   */ 0,
          /* fixed64  */ 1, /* sfixed64 */ 1,
        ],
        7
      );

      /**
       * Allowed types for map keys with their associated wire type.
       * @type {Object.<string,number>}
       * @const
       * @property {number} int32=0 Varint wire type
       * @property {number} uint32=0 Varint wire type
       * @property {number} sint32=0 Varint wire type
       * @property {number} fixed32=5 Fixed32 wire type
       * @property {number} sfixed32=5 Fixed32 wire type
       * @property {number} int64=0 Varint wire type
       * @property {number} uint64=0 Varint wire type
       * @property {number} sint64=0 Varint wire type
       * @property {number} fixed64=1 Fixed64 wire type
       * @property {number} sfixed64=1 Fixed64 wire type
       * @property {number} bool=0 Varint wire type
       * @property {number} string=2 Ldelim wire type
       */
      types.mapKey = bake(
        [
          /* int32    */ 0, /* uint32   */ 0, /* sint32   */ 0,
          /* fixed32  */ 5, /* sfixed32 */ 5, /* int64    */ 0,
          /* uint64   */ 0, /* sint64   */ 0, /* fixed64  */ 1,
          /* sfixed64 */ 1, /* bool     */ 0, /* string   */ 2,
        ],
        2
      );

      /**
       * Allowed types for packed repeated fields with their associated wire type.
       * @type {Object.<string,number>}
       * @const
       * @property {number} double=1 Fixed64 wire type
       * @property {number} float=5 Fixed32 wire type
       * @property {number} int32=0 Varint wire type
       * @property {number} uint32=0 Varint wire type
       * @property {number} sint32=0 Varint wire type
       * @property {number} fixed32=5 Fixed32 wire type
       * @property {number} sfixed32=5 Fixed32 wire type
       * @property {number} int64=0 Varint wire type
       * @property {number} uint64=0 Varint wire type
       * @property {number} sint64=0 Varint wire type
       * @property {number} fixed64=1 Fixed64 wire type
       * @property {number} sfixed64=1 Fixed64 wire type
       * @property {number} bool=0 Varint wire type
       */
      types.packed = bake([
        /* double   */ 1, /* float    */ 5, /* int32    */ 0, /* uint32   */ 0,
        /* sint32   */ 0, /* fixed32  */ 5, /* sfixed32 */ 5, /* int64    */ 0,
        /* uint64   */ 0, /* sint64   */ 0, /* fixed64  */ 1, /* sfixed64 */ 1,
        /* bool     */ 0,
      ]);

      /***/
    },

    /***/ 9935: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      /**
       * Various utility functions.
       * @namespace
       */
      var util = (module.exports = __webpack_require__(9693));

      var roots = __webpack_require__(5054);

      var Type, // cyclic
        Enum;

      util.codegen = __webpack_require__(5124);
      util.fetch = __webpack_require__(9054);
      util.path = __webpack_require__(8626);

      /**
       * Node's fs module if available.
       * @type {Object.<string,*>}
       */
      util.fs = util.inquire("fs");

      /**
       * Converts an object's values to an array.
       * @param {Object.<string,*>} object Object to convert
       * @returns {Array.<*>} Converted array
       */
      util.toArray = function toArray(object) {
        if (object) {
          var keys = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
          while (index < keys.length) array[index] = object[keys[index++]];
          return array;
        }
        return [];
      };

      /**
       * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
       * @param {Array.<*>} array Array to convert
       * @returns {Object.<string,*>} Converted object
       */
      util.toObject = function toObject(array) {
        var object = {},
          index = 0;
        while (index < array.length) {
          var key = array[index++],
            val = array[index++];
          if (val !== undefined) object[key] = val;
        }
        return object;
      };

      var safePropBackslashRe = /\\/g,
        safePropQuoteRe = /"/g;

      /**
       * Tests whether the specified name is a reserved word in JS.
       * @param {string} name Name to test
       * @returns {boolean} `true` if reserved, otherwise `false`
       */
      util.isReserved = function isReserved(name) {
        return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(
          name
        );
      };

      /**
       * Returns a safe property accessor for the specified property name.
       * @param {string} prop Property name
       * @returns {string} Safe accessor
       */
      util.safeProp = function safeProp(prop) {
        if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
          return (
            '["' +
            prop
              .replace(safePropBackslashRe, "\\\\")
              .replace(safePropQuoteRe, '\\"') +
            '"]'
          );
        return "." + prop;
      };

      /**
       * Converts the first character of a string to upper case.
       * @param {string} str String to convert
       * @returns {string} Converted string
       */
      util.ucFirst = function ucFirst(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
      };

      var camelCaseRe = /_([a-z])/g;

      /**
       * Converts a string to camel case.
       * @param {string} str String to convert
       * @returns {string} Converted string
       */
      util.camelCase = function camelCase(str) {
        return (
          str.substring(0, 1) +
          str.substring(1).replace(camelCaseRe, function ($0, $1) {
            return $1.toUpperCase();
          })
        );
      };

      /**
       * Compares reflected fields by id.
       * @param {Field} a First field
       * @param {Field} b Second field
       * @returns {number} Comparison value
       */
      util.compareFieldsById = function compareFieldsById(a, b) {
        return a.id - b.id;
      };

      /**
       * Decorator helper for types (TypeScript).
       * @param {Constructor<T>} ctor Constructor function
       * @param {string} [typeName] Type name, defaults to the constructor's name
       * @returns {Type} Reflected type
       * @template T extends Message<T>
       * @property {Root} root Decorators root
       */
      util.decorateType = function decorateType(ctor, typeName) {
        /* istanbul ignore if */
        if (ctor.$type) {
          if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
          }
          return ctor.$type;
        }

        /* istanbul ignore next */
        if (!Type) Type = __webpack_require__(7645);

        var type = new Type(typeName || ctor.name);
        util.decorateRoot.add(type);
        type.ctor = ctor; // sets up .encode, .decode etc.
        Object.defineProperty(ctor, "$type", {
          value: type,
          enumerable: false,
        });
        Object.defineProperty(ctor.prototype, "$type", {
          value: type,
          enumerable: false,
        });
        return type;
      };

      var decorateEnumIndex = 0;

      /**
       * Decorator helper for enums (TypeScript).
       * @param {Object} object Enum object
       * @returns {Enum} Reflected enum
       */
      util.decorateEnum = function decorateEnum(object) {
        /* istanbul ignore if */
        if (object.$type) return object.$type;

        /* istanbul ignore next */
        if (!Enum) Enum = __webpack_require__(7025);

        var enm = new Enum("Enum" + decorateEnumIndex++, object);
        util.decorateRoot.add(enm);
        Object.defineProperty(object, "$type", {
          value: enm,
          enumerable: false,
        });
        return enm;
      };

      /**
       * Sets the value of a property by property path. If a value already exists, it is turned to an array
       * @param {Object.<string,*>} dst Destination object
       * @param {string} path dot '.' delimited path of the property to set
       * @param {Object} value the value to set
       * @returns {Object.<string,*>} Destination object
       */
      util.setProperty = function setProperty(dst, path, value) {
        function setProp(dst, path, value) {
          var part = path.shift();
          if (path.length > 0) {
            dst[part] = setProp(dst[part] || {}, path, value);
          } else {
            var prevValue = dst[part];
            if (prevValue) value = [].concat(prevValue).concat(value);
            dst[part] = value;
          }
          return dst;
        }

        if (typeof dst !== "object") throw TypeError("dst must be an object");
        if (!path) throw TypeError("path must be specified");

        path = path.split(".");
        return setProp(dst, path, value);
      };

      /**
       * Decorator root (TypeScript).
       * @name util.decorateRoot
       * @type {Root}
       * @readonly
       */
      Object.defineProperty(util, "decorateRoot", {
        get: function () {
          return (
            roots["decorated"] ||
            (roots["decorated"] = new (__webpack_require__(9424))())
          );
        },
      });

      /***/
    },

    /***/ 1945: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = LongBits;

      var util = __webpack_require__(9693);

      /**
       * Constructs new long bits.
       * @classdesc Helper class for working with the low and high bits of a 64 bit value.
       * @memberof util
       * @constructor
       * @param {number} lo Low 32 bits, unsigned
       * @param {number} hi High 32 bits, unsigned
       */
      function LongBits(lo, hi) {
        // note that the casts below are theoretically unnecessary as of today, but older statically
        // generated converter code might still call the ctor with signed 32bits. kept for compat.

        /**
         * Low bits.
         * @type {number}
         */
        this.lo = lo >>> 0;

        /**
         * High bits.
         * @type {number}
         */
        this.hi = hi >>> 0;
      }

      /**
       * Zero bits.
       * @memberof util.LongBits
       * @type {util.LongBits}
       */
      var zero = (LongBits.zero = new LongBits(0, 0));

      zero.toNumber = function () {
        return 0;
      };
      zero.zzEncode = zero.zzDecode = function () {
        return this;
      };
      zero.length = function () {
        return 1;
      };

      /**
       * Zero hash.
       * @memberof util.LongBits
       * @type {string}
       */
      var zeroHash = (LongBits.zeroHash = "\0\0\0\0\0\0\0\0");

      /**
       * Constructs new long bits from the specified number.
       * @param {number} value Value
       * @returns {util.LongBits} Instance
       */
      LongBits.fromNumber = function fromNumber(value) {
        if (value === 0) return zero;
        var sign = value < 0;
        if (sign) value = -value;
        var lo = value >>> 0,
          hi = ((value - lo) / 4294967296) >>> 0;
        if (sign) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295) hi = 0;
          }
        }
        return new LongBits(lo, hi);
      };

      /**
       * Constructs new long bits from a number, long or string.
       * @param {Long|number|string} value Value
       * @returns {util.LongBits} Instance
       */
      LongBits.from = function from(value) {
        if (typeof value === "number") return LongBits.fromNumber(value);
        if (util.isString(value)) {
          /* istanbul ignore else */
          if (util.Long) value = util.Long.fromString(value);
          else return LongBits.fromNumber(parseInt(value, 10));
        }
        return value.low || value.high
          ? new LongBits(value.low >>> 0, value.high >>> 0)
          : zero;
      };

      /**
       * Converts this long bits to a possibly unsafe JavaScript number.
       * @param {boolean} [unsigned=false] Whether unsigned or not
       * @returns {number} Possibly unsafe number
       */
      LongBits.prototype.toNumber = function toNumber(unsigned) {
        if (!unsigned && this.hi >>> 31) {
          var lo = (~this.lo + 1) >>> 0,
            hi = ~this.hi >>> 0;
          if (!lo) hi = (hi + 1) >>> 0;
          return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      };

      /**
       * Converts this long bits to a long.
       * @param {boolean} [unsigned=false] Whether unsigned or not
       * @returns {Long} Long
       */
      LongBits.prototype.toLong = function toLong(unsigned) {
        return util.Long
          ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
          : /* istanbul ignore next */
            {
              low: this.lo | 0,
              high: this.hi | 0,
              unsigned: Boolean(unsigned),
            };
      };

      var charCodeAt = String.prototype.charCodeAt;

      /**
       * Constructs new long bits from the specified 8 characters long hash.
       * @param {string} hash Hash
       * @returns {util.LongBits} Bits
       */
      LongBits.fromHash = function fromHash(hash) {
        if (hash === zeroHash) return zero;
        return new LongBits(
          (charCodeAt.call(hash, 0) |
            (charCodeAt.call(hash, 1) << 8) |
            (charCodeAt.call(hash, 2) << 16) |
            (charCodeAt.call(hash, 3) << 24)) >>>
            0,
          (charCodeAt.call(hash, 4) |
            (charCodeAt.call(hash, 5) << 8) |
            (charCodeAt.call(hash, 6) << 16) |
            (charCodeAt.call(hash, 7) << 24)) >>>
            0
        );
      };

      /**
       * Converts this long bits to a 8 characters long hash.
       * @returns {string} Hash
       */
      LongBits.prototype.toHash = function toHash() {
        return String.fromCharCode(
          this.lo & 255,
          (this.lo >>> 8) & 255,
          (this.lo >>> 16) & 255,
          this.lo >>> 24,
          this.hi & 255,
          (this.hi >>> 8) & 255,
          (this.hi >>> 16) & 255,
          this.hi >>> 24
        );
      };

      /**
       * Zig-zag encodes this long bits.
       * @returns {util.LongBits} `this`
       */
      LongBits.prototype.zzEncode = function zzEncode() {
        var mask = this.hi >> 31;
        this.hi = (((this.hi << 1) | (this.lo >>> 31)) ^ mask) >>> 0;
        this.lo = ((this.lo << 1) ^ mask) >>> 0;
        return this;
      };

      /**
       * Zig-zag decodes this long bits.
       * @returns {util.LongBits} `this`
       */
      LongBits.prototype.zzDecode = function zzDecode() {
        var mask = -(this.lo & 1);
        this.lo = (((this.lo >>> 1) | (this.hi << 31)) ^ mask) >>> 0;
        this.hi = ((this.hi >>> 1) ^ mask) >>> 0;
        return this;
      };

      /**
       * Calculates the length of this longbits when encoded as a varint.
       * @returns {number} Length
       */
      LongBits.prototype.length = function length() {
        var part0 = this.lo,
          part1 = ((this.lo >>> 28) | (this.hi << 4)) >>> 0,
          part2 = this.hi >>> 24;
        return part2 === 0
          ? part1 === 0
            ? part0 < 16384
              ? part0 < 128
                ? 1
                : 2
              : part0 < 2097152
              ? 3
              : 4
            : part1 < 16384
            ? part1 < 128
              ? 5
              : 6
            : part1 < 2097152
            ? 7
            : 8
          : part2 < 128
          ? 9
          : 10;
      };

      /***/
    },

    /***/ 9693: /***/ function (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      "use strict";

      var util = exports;

      // used to return a Promise where callback is omitted
      util.asPromise = __webpack_require__(4537);

      // converts to / from base64 encoded strings
      util.base64 = __webpack_require__(7419);

      // base class of rpc.Service
      util.EventEmitter = __webpack_require__(9211);

      // float handling accross browsers
      util.float = __webpack_require__(945);

      // requires modules optionally and hides the call from bundlers
      util.inquire = __webpack_require__(7199);

      // converts to / from utf8 encoded strings
      util.utf8 = __webpack_require__(4997);

      // provides a node-like buffer pool in the browser
      util.pool = __webpack_require__(6662);

      // utility to work with the low and high bits of a 64 bit value
      util.LongBits = __webpack_require__(1945);

      /**
       * Whether running within node or not.
       * @memberof util
       * @type {boolean}
       */
      util.isNode = Boolean(
        typeof __webpack_require__.g !== "undefined" &&
          __webpack_require__.g &&
          __webpack_require__.g.process &&
          __webpack_require__.g.process.versions &&
          __webpack_require__.g.process.versions.node
      );

      /**
       * Global object reference.
       * @memberof util
       * @type {Object}
       */
      util.global =
        (util.isNode && __webpack_require__.g) ||
        (typeof window !== "undefined" && window) ||
        (typeof self !== "undefined" && self) ||
        this; // eslint-disable-line no-invalid-this

      /**
       * An immuable empty array.
       * @memberof util
       * @type {Array.<*>}
       * @const
       */
      util.emptyArray = Object.freeze
        ? Object.freeze([])
        : /* istanbul ignore next */ []; // used on prototypes

      /**
       * An immutable empty object.
       * @type {Object}
       * @const
       */
      util.emptyObject = Object.freeze
        ? Object.freeze({})
        : /* istanbul ignore next */ {}; // used on prototypes

      /**
       * Tests if the specified value is an integer.
       * @function
       * @param {*} value Value to test
       * @returns {boolean} `true` if the value is an integer
       */
      util.isInteger =
        Number.isInteger ||
        /* istanbul ignore next */ function isInteger(value) {
          return (
            typeof value === "number" &&
            isFinite(value) &&
            Math.floor(value) === value
          );
        };

      /**
       * Tests if the specified value is a string.
       * @param {*} value Value to test
       * @returns {boolean} `true` if the value is a string
       */
      util.isString = function isString(value) {
        return typeof value === "string" || value instanceof String;
      };

      /**
       * Tests if the specified value is a non-null object.
       * @param {*} value Value to test
       * @returns {boolean} `true` if the value is a non-null object
       */
      util.isObject = function isObject(value) {
        return value && typeof value === "object";
      };

      /**
       * Checks if a property on a message is considered to be present.
       * This is an alias of {@link util.isSet}.
       * @function
       * @param {Object} obj Plain object or message instance
       * @param {string} prop Property name
       * @returns {boolean} `true` if considered to be present, otherwise `false`
       */
      util.isset =
        /**
         * Checks if a property on a message is considered to be present.
         * @param {Object} obj Plain object or message instance
         * @param {string} prop Property name
         * @returns {boolean} `true` if considered to be present, otherwise `false`
         */
        util.isSet = function isSet(obj, prop) {
          var value = obj[prop];
          if (value != null && obj.hasOwnProperty(prop))
            // eslint-disable-line eqeqeq, no-prototype-builtins
            return (
              typeof value !== "object" ||
              (Array.isArray(value)
                ? value.length
                : Object.keys(value).length) > 0
            );
          return false;
        };

      /**
       * Any compatible Buffer instance.
       * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
       * @interface Buffer
       * @extends Uint8Array
       */

      /**
       * Node's Buffer class if available.
       * @type {Constructor<Buffer>}
       */
      util.Buffer = (function () {
        try {
          var Buffer = util.inquire("buffer").Buffer;
          // refuse to use non-node buffers if not explicitly assigned (perf reasons):
          return Buffer.prototype.utf8Write
            ? Buffer
            : /* istanbul ignore next */ null;
        } catch (e) {
          /* istanbul ignore next */
          return null;
        }
      })();

      // Internal alias of or polyfull for Buffer.from.
      util._Buffer_from = null;

      // Internal alias of or polyfill for Buffer.allocUnsafe.
      util._Buffer_allocUnsafe = null;

      /**
       * Creates a new buffer of whatever type supported by the environment.
       * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
       * @returns {Uint8Array|Buffer} Buffer
       */
      util.newBuffer = function newBuffer(sizeOrArray) {
        /* istanbul ignore next */
        return typeof sizeOrArray === "number"
          ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
          : util.Buffer
          ? util._Buffer_from(sizeOrArray)
          : typeof Uint8Array === "undefined"
          ? sizeOrArray
          : new Uint8Array(sizeOrArray);
      };

      /**
       * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
       * @type {Constructor<Uint8Array>}
       */
      util.Array =
        typeof Uint8Array !== "undefined"
          ? Uint8Array /* istanbul ignore next */
          : Array;

      /**
       * Any compatible Long instance.
       * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
       * @interface Long
       * @property {number} low Low bits
       * @property {number} high High bits
       * @property {boolean} unsigned Whether unsigned or not
       */

      /**
       * Long.js's Long class if available.
       * @type {Constructor<Long>}
       */
      util.Long =
        /* istanbul ignore next */ (util.global.dcodeIO &&
          /* istanbul ignore next */ util.global.dcodeIO.Long) ||
        /* istanbul ignore next */ util.global.Long ||
        util.inquire("long");

      /**
       * Regular expression used to verify 2 bit (`bool`) map keys.
       * @type {RegExp}
       * @const
       */
      util.key2Re = /^true|false|0|1$/;

      /**
       * Regular expression used to verify 32 bit (`int32` etc.) map keys.
       * @type {RegExp}
       * @const
       */
      util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

      /**
       * Regular expression used to verify 64 bit (`int64` etc.) map keys.
       * @type {RegExp}
       * @const
       */
      util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

      /**
       * Converts a number or long to an 8 characters long hash string.
       * @param {Long|number} value Value to convert
       * @returns {string} Hash
       */
      util.longToHash = function longToHash(value) {
        return value
          ? util.LongBits.from(value).toHash()
          : util.LongBits.zeroHash;
      };

      /**
       * Converts an 8 characters long hash string to a long or number.
       * @param {string} hash Hash
       * @param {boolean} [unsigned=false] Whether unsigned or not
       * @returns {Long|number} Original value
       */
      util.longFromHash = function longFromHash(hash, unsigned) {
        var bits = util.LongBits.fromHash(hash);
        if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
        return bits.toNumber(Boolean(unsigned));
      };

      /**
       * Merges the properties of the source object into the destination object.
       * @memberof util
       * @param {Object.<string,*>} dst Destination object
       * @param {Object.<string,*>} src Source object
       * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
       * @returns {Object.<string,*>} Destination object
       */
      function merge(dst, src, ifNotSet) {
        // used by converters
        for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
          if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
        return dst;
      }

      util.merge = merge;

      /**
       * Converts the first character of a string to lower case.
       * @param {string} str String to convert
       * @returns {string} Converted string
       */
      util.lcFirst = function lcFirst(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
      };

      /**
       * Creates a custom error constructor.
       * @memberof util
       * @param {string} name Error name
       * @returns {Constructor<Error>} Custom error constructor
       */
      function newError(name) {
        function CustomError(message, properties) {
          if (!(this instanceof CustomError))
            return new CustomError(message, properties);

          // Error.call(this, message);
          // ^ just returns a new error instance because the ctor can be called as a function

          Object.defineProperty(this, "message", {
            get: function () {
              return message;
            },
          });

          /* istanbul ignore next */
          if (Error.captureStackTrace)
            // node
            Error.captureStackTrace(this, CustomError);
          else
            Object.defineProperty(this, "stack", {
              value: new Error().stack || "",
            });

          if (properties) merge(this, properties);
        }

        (CustomError.prototype = Object.create(Error.prototype)).constructor =
          CustomError;

        Object.defineProperty(CustomError.prototype, "name", {
          get: function () {
            return name;
          },
        });

        CustomError.prototype.toString = function toString() {
          return this.name + ": " + this.message;
        };

        return CustomError;
      }

      util.newError = newError;

      /**
       * Constructs a new protocol error.
       * @classdesc Error subclass indicating a protocol specifc error.
       * @memberof util
       * @extends Error
       * @template T extends Message<T>
       * @constructor
       * @param {string} message Error message
       * @param {Object.<string,*>} [properties] Additional properties
       * @example
       * try {
       *     MyMessage.decode(someBuffer); // throws if required fields are missing
       * } catch (e) {
       *     if (e instanceof ProtocolError && e.instance)
       *         console.log("decoded so far: " + JSON.stringify(e.instance));
       * }
       */
      util.ProtocolError = newError("ProtocolError");

      /**
       * So far decoded message instance.
       * @name util.ProtocolError#instance
       * @type {Message<T>}
       */

      /**
       * A OneOf getter as returned by {@link util.oneOfGetter}.
       * @typedef OneOfGetter
       * @type {function}
       * @returns {string|undefined} Set field name, if any
       */

      /**
       * Builds a getter for a oneof's present field name.
       * @param {string[]} fieldNames Field names
       * @returns {OneOfGetter} Unbound getter
       */
      util.oneOfGetter = function getOneOf(fieldNames) {
        var fieldMap = {};
        for (var i = 0; i < fieldNames.length; ++i) fieldMap[fieldNames[i]] = 1;

        /**
         * @returns {string|undefined} Set field name, if any
         * @this Object
         * @ignore
         */
        return function () {
          // eslint-disable-line consistent-return
          for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (
              fieldMap[keys[i]] === 1 &&
              this[keys[i]] !== undefined &&
              this[keys[i]] !== null
            )
              return keys[i];
        };
      };

      /**
       * A OneOf setter as returned by {@link util.oneOfSetter}.
       * @typedef OneOfSetter
       * @type {function}
       * @param {string|undefined} value Field name
       * @returns {undefined}
       */

      /**
       * Builds a setter for a oneof's present field name.
       * @param {string[]} fieldNames Field names
       * @returns {OneOfSetter} Unbound setter
       */
      util.oneOfSetter = function setOneOf(fieldNames) {
        /**
         * @param {string} name Field name
         * @returns {undefined}
         * @this Object
         * @ignore
         */
        return function (name) {
          for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name) delete this[fieldNames[i]];
        };
      };

      /**
       * Default conversion options used for {@link Message#toJSON} implementations.
       *
       * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
       *
       * - Longs become strings
       * - Enums become string keys
       * - Bytes become base64 encoded strings
       * - (Sub-)Messages become plain objects
       * - Maps become plain objects with all string keys
       * - Repeated fields become arrays
       * - NaN and Infinity for float and double fields become strings
       *
       * @type {IConversionOptions}
       * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
       */
      util.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: true,
      };

      // Sets up buffer utility according to the environment (called in index-minimal)
      util._configure = function () {
        var Buffer = util.Buffer;
        /* istanbul ignore if */
        if (!Buffer) {
          util._Buffer_from = util._Buffer_allocUnsafe = null;
          return;
        }
        // because node 4.x buffers are incompatible & immutable
        // see: https://github.com/dcodeIO/protobuf.js/pull/665
        util._Buffer_from =
          (Buffer.from !== Uint8Array.from && Buffer.from) ||
          /* istanbul ignore next */
          function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
          };
        util._Buffer_allocUnsafe =
          Buffer.allocUnsafe ||
          /* istanbul ignore next */
          function Buffer_allocUnsafe(size) {
            return new Buffer(size);
          };
      };

      /***/
    },

    /***/ 4497: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = verifier;

      var Enum = __webpack_require__(7025),
        util = __webpack_require__(9935);

      function invalid(field, expected) {
        return (
          field.name +
          ": " +
          expected +
          (field.repeated && expected !== "array"
            ? "[]"
            : field.map && expected !== "object"
            ? "{k:" + field.keyType + "}"
            : "") +
          " expected"
        );
      }

      /**
       * Generates a partial value verifier.
       * @param {Codegen} gen Codegen instance
       * @param {Field} field Reflected field
       * @param {number} fieldIndex Field index
       * @param {string} ref Variable reference
       * @returns {Codegen} Codegen instance
       * @ignore
       */
      function genVerifyValue(gen, field, fieldIndex, ref) {
        /* eslint-disable no-unexpected-multiline */
        if (field.resolvedType) {
          if (field.resolvedType instanceof Enum) {
            gen("switch(%s){", ref)("default:")(
              "return%j",
              invalid(field, "enum value")
            );
            for (
              var keys = Object.keys(field.resolvedType.values), j = 0;
              j < keys.length;
              ++j
            )
              gen("case %i:", field.resolvedType.values[keys[j]]);
            gen("break")("}");
          } else {
            gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")(
              "return%j+e",
              field.name + "."
            )("}");
          }
        } else {
          switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32":
              gen("if(!util.isInteger(%s))", ref)(
                "return%j",
                invalid(field, "integer")
              );
              break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
              gen(
                "if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))",
                ref,
                ref,
                ref,
                ref
              )("return%j", invalid(field, "integer|Long"));
              break;
            case "float":
            case "double":
              gen('if(typeof %s!=="number")', ref)(
                "return%j",
                invalid(field, "number")
              );
              break;
            case "bool":
              gen('if(typeof %s!=="boolean")', ref)(
                "return%j",
                invalid(field, "boolean")
              );
              break;
            case "string":
              gen("if(!util.isString(%s))", ref)(
                "return%j",
                invalid(field, "string")
              );
              break;
            case "bytes":
              gen(
                'if(!(%s&&typeof %s.length==="number"||util.isString(%s)))',
                ref,
                ref,
                ref
              )("return%j", invalid(field, "buffer"));
              break;
          }
        }
        return gen;
        /* eslint-enable no-unexpected-multiline */
      }

      /**
       * Generates a partial key verifier.
       * @param {Codegen} gen Codegen instance
       * @param {Field} field Reflected field
       * @param {string} ref Variable reference
       * @returns {Codegen} Codegen instance
       * @ignore
       */
      function genVerifyKey(gen, field, ref) {
        /* eslint-disable no-unexpected-multiline */
        switch (field.keyType) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.key32Re.test(%s))", ref)(
              "return%j",
              invalid(field, "integer key")
            );
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.key64Re.test(%s))", ref)(
              // see comment above: x is ok, d is not
              "return%j",
              invalid(field, "integer|Long key")
            );
            break;
          case "bool":
            gen("if(!util.key2Re.test(%s))", ref)(
              "return%j",
              invalid(field, "boolean key")
            );
            break;
        }
        return gen;
        /* eslint-enable no-unexpected-multiline */
      }

      /**
       * Generates a verifier specific to the specified message type.
       * @param {Type} mtype Message type
       * @returns {Codegen} Codegen instance
       */
      function verifier(mtype) {
        /* eslint-disable no-unexpected-multiline */

        var gen = util.codegen(
          ["m"],
          mtype.name + "$verify"
        )('if(typeof m!=="object"||m===null)')("return%j", "object expected");
        var oneofs = mtype.oneofsArray,
          seenFirstField = {};
        if (oneofs.length) gen("var p={}");

        for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
          var field = mtype._fieldsArray[i].resolve(),
            ref = "m" + util.safeProp(field.name);

          if (field.optional)
            gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

          // map fields
          if (field.map) {
            gen("if(!util.isObject(%s))", ref)(
              "return%j",
              invalid(field, "object")
            )(
              "var k=Object.keys(%s)",
              ref
            )("for(var i=0;i<k.length;++i){");
            genVerifyKey(gen, field, "k[i]");
            genVerifyValue(gen, field, i, ref + "[k[i]]")("}");

            // repeated fields
          } else if (field.repeated) {
            gen("if(!Array.isArray(%s))", ref)(
              "return%j",
              invalid(field, "array")
            )("for(var i=0;i<%s.length;++i){", ref);
            genVerifyValue(gen, field, i, ref + "[i]")("}");

            // required or present fields
          } else {
            if (field.partOf) {
              var oneofProp = util.safeProp(field.partOf.name);
              if (seenFirstField[field.partOf.name] === 1)
                gen("if(p%s===1)", oneofProp)(
                  "return%j",
                  field.partOf.name + ": multiple values"
                );
              seenFirstField[field.partOf.name] = 1;
              gen("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
          }
          if (field.optional) gen("}");
        }
        return gen("return null");
        /* eslint-enable no-unexpected-multiline */
      }

      /***/
    },

    /***/ 1667: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      /**
       * Wrappers for common types.
       * @type {Object.<string,IWrapper>}
       * @const
       */
      var wrappers = exports;

      var Message = __webpack_require__(8368);

      /**
       * From object converter part of an {@link IWrapper}.
       * @typedef WrapperFromObjectConverter
       * @type {function}
       * @param {Object.<string,*>} object Plain object
       * @returns {Message<{}>} Message instance
       * @this Type
       */

      /**
       * To object converter part of an {@link IWrapper}.
       * @typedef WrapperToObjectConverter
       * @type {function}
       * @param {Message<{}>} message Message instance
       * @param {IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       * @this Type
       */

      /**
       * Common type wrapper part of {@link wrappers}.
       * @interface IWrapper
       * @property {WrapperFromObjectConverter} [fromObject] From object converter
       * @property {WrapperToObjectConverter} [toObject] To object converter
       */

      // Custom wrapper for Any
      wrappers[".google.protobuf.Any"] = {
        fromObject: function (object) {
          // unwrap value type if mapped
          if (object && object["@type"]) {
            // Only use fully qualified type name after the last '/'
            var name = object["@type"].substring(
              object["@type"].lastIndexOf("/") + 1
            );
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) {
              // type_url does not accept leading "."
              var type_url =
                object["@type"].charAt(0) === "."
                  ? object["@type"].substr(1)
                  : object["@type"];
              // type_url prefix is optional, but path seperator is required
              if (type_url.indexOf("/") === -1) {
                type_url = "/" + type_url;
              }
              return this.create({
                type_url: type_url,
                value: type.encode(type.fromObject(object)).finish(),
              });
            }
          }

          return this.fromObject(object);
        },

        toObject: function (message, options) {
          // Default prefix
          var googleApi = "type.googleapis.com/";
          var prefix = "";
          var name = "";

          // decode value if requested and unmapped
          if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            name = message.type_url.substring(
              message.type_url.lastIndexOf("/") + 1
            );
            // Separate the prefix used
            prefix = message.type_url.substring(
              0,
              message.type_url.lastIndexOf("/") + 1
            );
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) message = type.decode(message.value);
          }

          // wrap value if unmapped
          if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            var messageName =
              message.$type.fullName[0] === "."
                ? message.$type.fullName.substr(1)
                : message.$type.fullName;
            // Default to type.googleapis.com prefix if no prefix is used
            if (prefix === "") {
              prefix = googleApi;
            }
            name = prefix + messageName;
            object["@type"] = name;
            return object;
          }

          return this.toObject(message, options);
        },
      };

      /***/
    },

    /***/ 1173: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = Writer;

      var util = __webpack_require__(9693);

      var BufferWriter; // cyclic

      var LongBits = util.LongBits,
        base64 = util.base64,
        utf8 = util.utf8;

      /**
       * Constructs a new writer operation instance.
       * @classdesc Scheduled writer operation.
       * @constructor
       * @param {function(*, Uint8Array, number)} fn Function to call
       * @param {number} len Value byte length
       * @param {*} val Value to write
       * @ignore
       */
      function Op(fn, len, val) {
        /**
         * Function to call.
         * @type {function(Uint8Array, number, *)}
         */
        this.fn = fn;

        /**
         * Value byte length.
         * @type {number}
         */
        this.len = len;

        /**
         * Next operation.
         * @type {Writer.Op|undefined}
         */
        this.next = undefined;

        /**
         * Value to write.
         * @type {*}
         */
        this.val = val; // type varies
      }

      /* istanbul ignore next */
      function noop() {} // eslint-disable-line no-empty-function

      /**
       * Constructs a new writer state instance.
       * @classdesc Copied writer state.
       * @memberof Writer
       * @constructor
       * @param {Writer} writer Writer to copy state from
       * @ignore
       */
      function State(writer) {
        /**
         * Current head.
         * @type {Writer.Op}
         */
        this.head = writer.head;

        /**
         * Current tail.
         * @type {Writer.Op}
         */
        this.tail = writer.tail;

        /**
         * Current buffer length.
         * @type {number}
         */
        this.len = writer.len;

        /**
         * Next state.
         * @type {State|null}
         */
        this.next = writer.states;
      }

      /**
       * Constructs a new writer instance.
       * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
       * @constructor
       */
      function Writer() {
        /**
         * Current length.
         * @type {number}
         */
        this.len = 0;

        /**
         * Operations head.
         * @type {Object}
         */
        this.head = new Op(noop, 0, 0);

        /**
         * Operations tail
         * @type {Object}
         */
        this.tail = this.head;

        /**
         * Linked forked states.
         * @type {Object|null}
         */
        this.states = null;

        // When a value is written, the writer calculates its byte length and puts it into a linked
        // list of operations to perform when finish() is called. This both allows us to allocate
        // buffers of the exact required size and reduces the amount of work we have to do compared
        // to first calculating over objects and then encoding over objects. In our case, the encoding
        // part is just a linked list walk calling operations with already prepared values.
      }

      var create = function create() {
        return util.Buffer
          ? function create_buffer_setup() {
              return (Writer.create = function create_buffer() {
                return new BufferWriter();
              })();
            }
          : /* istanbul ignore next */
            function create_array() {
              return new Writer();
            };
      };

      /**
       * Creates a new writer.
       * @function
       * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
       */
      Writer.create = create();

      /**
       * Allocates a buffer of the specified size.
       * @param {number} size Buffer size
       * @returns {Uint8Array} Buffer
       */
      Writer.alloc = function alloc(size) {
        return new util.Array(size);
      };

      // Use Uint8Array buffer pool in the browser, just like node does with buffers
      /* istanbul ignore else */
      if (util.Array !== Array)
        Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

      /**
       * Pushes a new operation to the queue.
       * @param {function(Uint8Array, number, *)} fn Function to call
       * @param {number} len Value byte length
       * @param {number} val Value to write
       * @returns {Writer} `this`
       * @private
       */
      Writer.prototype._push = function push(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
      };

      function writeByte(val, buf, pos) {
        buf[pos] = val & 255;
      }

      function writeVarint32(val, buf, pos) {
        while (val > 127) {
          buf[pos++] = (val & 127) | 128;
          val >>>= 7;
        }
        buf[pos] = val;
      }

      /**
       * Constructs a new varint writer operation instance.
       * @classdesc Scheduled varint writer operation.
       * @extends Op
       * @constructor
       * @param {number} len Value byte length
       * @param {number} val Value to write
       * @ignore
       */
      function VarintOp(len, val) {
        this.len = len;
        this.next = undefined;
        this.val = val;
      }

      VarintOp.prototype = Object.create(Op.prototype);
      VarintOp.prototype.fn = writeVarint32;

      /**
       * Writes an unsigned 32 bit value as a varint.
       * @param {number} value Value to write
       * @returns {Writer} `this`
       */
      Writer.prototype.uint32 = function write_uint32(value) {
        // here, the call to this.push has been inlined and a varint specific Op subclass is used.
        // uint32 is by far the most frequently used operation and benefits significantly from this.
        this.len += (this.tail = this.tail.next =
          new VarintOp(
            (value = value >>> 0) < 128
              ? 1
              : value < 16384
              ? 2
              : value < 2097152
              ? 3
              : value < 268435456
              ? 4
              : 5,
            value
          )).len;
        return this;
      };

      /**
       * Writes a signed 32 bit value as a varint.
       * @function
       * @param {number} value Value to write
       * @returns {Writer} `this`
       */
      Writer.prototype.int32 = function write_int32(value) {
        return value < 0
          ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
          : this.uint32(value);
      };

      /**
       * Writes a 32 bit value as a varint, zig-zag encoded.
       * @param {number} value Value to write
       * @returns {Writer} `this`
       */
      Writer.prototype.sint32 = function write_sint32(value) {
        return this.uint32(((value << 1) ^ (value >> 31)) >>> 0);
      };

      function writeVarint64(val, buf, pos) {
        while (val.hi) {
          buf[pos++] = (val.lo & 127) | 128;
          val.lo = ((val.lo >>> 7) | (val.hi << 25)) >>> 0;
          val.hi >>>= 7;
        }
        while (val.lo > 127) {
          buf[pos++] = (val.lo & 127) | 128;
          val.lo = val.lo >>> 7;
        }
        buf[pos++] = val.lo;
      }

      /**
       * Writes an unsigned 64 bit value as a varint.
       * @param {Long|number|string} value Value to write
       * @returns {Writer} `this`
       * @throws {TypeError} If `value` is a string and no long library is present.
       */
      Writer.prototype.uint64 = function write_uint64(value) {
        var bits = LongBits.from(value);
        return this._push(writeVarint64, bits.length(), bits);
      };

      /**
       * Writes a signed 64 bit value as a varint.
       * @function
       * @param {Long|number|string} value Value to write
       * @returns {Writer} `this`
       * @throws {TypeError} If `value` is a string and no long library is present.
       */
      Writer.prototype.int64 = Writer.prototype.uint64;

      /**
       * Writes a signed 64 bit value as a varint, zig-zag encoded.
       * @param {Long|number|string} value Value to write
       * @returns {Writer} `this`
       * @throws {TypeError} If `value` is a string and no long library is present.
       */
      Writer.prototype.sint64 = function write_sint64(value) {
        var bits = LongBits.from(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
      };

      /**
       * Writes a boolish value as a varint.
       * @param {boolean} value Value to write
       * @returns {Writer} `this`
       */
      Writer.prototype.bool = function write_bool(value) {
        return this._push(writeByte, 1, value ? 1 : 0);
      };

      function writeFixed32(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = (val >>> 8) & 255;
        buf[pos + 2] = (val >>> 16) & 255;
        buf[pos + 3] = val >>> 24;
      }

      /**
       * Writes an unsigned 32 bit value as fixed 32 bits.
       * @param {number} value Value to write
       * @returns {Writer} `this`
       */
      Writer.prototype.fixed32 = function write_fixed32(value) {
        return this._push(writeFixed32, 4, value >>> 0);
      };

      /**
       * Writes a signed 32 bit value as fixed 32 bits.
       * @function
       * @param {number} value Value to write
       * @returns {Writer} `this`
       */
      Writer.prototype.sfixed32 = Writer.prototype.fixed32;

      /**
       * Writes an unsigned 64 bit value as fixed 64 bits.
       * @param {Long|number|string} value Value to write
       * @returns {Writer} `this`
       * @throws {TypeError} If `value` is a string and no long library is present.
       */
      Writer.prototype.fixed64 = function write_fixed64(value) {
        var bits = LongBits.from(value);
        return this._push(writeFixed32, 4, bits.lo)._push(
          writeFixed32,
          4,
          bits.hi
        );
      };

      /**
       * Writes a signed 64 bit value as fixed 64 bits.
       * @function
       * @param {Long|number|string} value Value to write
       * @returns {Writer} `this`
       * @throws {TypeError} If `value` is a string and no long library is present.
       */
      Writer.prototype.sfixed64 = Writer.prototype.fixed64;

      /**
       * Writes a float (32 bit).
       * @function
       * @param {number} value Value to write
       * @returns {Writer} `this`
       */
      Writer.prototype.float = function write_float(value) {
        return this._push(util.float.writeFloatLE, 4, value);
      };

      /**
       * Writes a double (64 bit float).
       * @function
       * @param {number} value Value to write
       * @returns {Writer} `this`
       */
      Writer.prototype.double = function write_double(value) {
        return this._push(util.float.writeDoubleLE, 8, value);
      };

      var writeBytes = util.Array.prototype.set
        ? function writeBytes_set(val, buf, pos) {
            buf.set(val, pos); // also works for plain array values
          }
        : /* istanbul ignore next */
          function writeBytes_for(val, buf, pos) {
            for (var i = 0; i < val.length; ++i) buf[pos + i] = val[i];
          };

      /**
       * Writes a sequence of bytes.
       * @param {Uint8Array|string} value Buffer or base64 encoded string to write
       * @returns {Writer} `this`
       */
      Writer.prototype.bytes = function write_bytes(value) {
        var len = value.length >>> 0;
        if (!len) return this._push(writeByte, 1, 0);
        if (util.isString(value)) {
          var buf = Writer.alloc((len = base64.length(value)));
          base64.decode(value, buf, 0);
          value = buf;
        }
        return this.uint32(len)._push(writeBytes, len, value);
      };

      /**
       * Writes a string.
       * @param {string} value Value to write
       * @returns {Writer} `this`
       */
      Writer.prototype.string = function write_string(value) {
        var len = utf8.length(value);
        return len
          ? this.uint32(len)._push(utf8.write, len, value)
          : this._push(writeByte, 1, 0);
      };

      /**
       * Forks this writer's state by pushing it to a stack.
       * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
       * @returns {Writer} `this`
       */
      Writer.prototype.fork = function fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
        return this;
      };

      /**
       * Resets this instance to the last state.
       * @returns {Writer} `this`
       */
      Writer.prototype.reset = function reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op(noop, 0, 0);
          this.len = 0;
        }
        return this;
      };

      /**
       * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
       * @returns {Writer} `this`
       */
      Writer.prototype.ldelim = function ldelim() {
        var head = this.head,
          tail = this.tail,
          len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next; // skip noop
          this.tail = tail;
          this.len += len;
        }
        return this;
      };

      /**
       * Finishes the write operation.
       * @returns {Uint8Array} Finished buffer
       */
      Writer.prototype.finish = function finish() {
        var head = this.head.next, // skip noop
          buf = this.constructor.alloc(this.len),
          pos = 0;
        while (head) {
          head.fn(head.val, buf, pos);
          pos += head.len;
          head = head.next;
        }
        // this.head = this.tail = null;
        return buf;
      };

      Writer._configure = function (BufferWriter_) {
        BufferWriter = BufferWriter_;
        Writer.create = create();
        BufferWriter._configure();
      };

      /***/
    },

    /***/ 3155: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      "use strict";

      module.exports = BufferWriter;

      // extends Writer
      var Writer = __webpack_require__(1173);
      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor =
        BufferWriter;

      var util = __webpack_require__(9693);

      /**
       * Constructs a new buffer writer instance.
       * @classdesc Wire format writer using node buffers.
       * @extends Writer
       * @constructor
       */
      function BufferWriter() {
        Writer.call(this);
      }

      BufferWriter._configure = function () {
        /**
         * Allocates a buffer of the specified size.
         * @function
         * @param {number} size Buffer size
         * @returns {Buffer} Buffer
         */
        BufferWriter.alloc = util._Buffer_allocUnsafe;

        BufferWriter.writeBytesBuffer =
          util.Buffer &&
          util.Buffer.prototype instanceof Uint8Array &&
          util.Buffer.prototype.set.name === "set"
            ? function writeBytesBuffer_set(val, buf, pos) {
                buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                // also works for plain array values
              }
            : /* istanbul ignore next */
              function writeBytesBuffer_copy(val, buf, pos) {
                if (val.copy)
                  // Buffer values
                  val.copy(buf, pos, 0, val.length);
                else
                  for (
                    var i = 0;
                    i < val.length; // plain array values

                  )
                    buf[pos++] = val[i++];
              };
      };

      /**
       * @override
       */
      BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
        if (util.isString(value)) value = util._Buffer_from(value, "base64");
        var len = value.length >>> 0;
        this.uint32(len);
        if (len) this._push(BufferWriter.writeBytesBuffer, len, value);
        return this;
      };

      function writeStringBuffer(val, buf, pos) {
        if (val.length < 40)
          // plain js is faster for short strings (probably due to redundant assertions)
          util.utf8.write(val, buf, pos);
        else if (buf.utf8Write) buf.utf8Write(val, pos);
        else buf.write(val, pos);
      }

      /**
       * @override
       */
      BufferWriter.prototype.string = function write_string_buffer(value) {
        var len = util.Buffer.byteLength(value);
        this.uint32(len);
        if (len) this._push(writeStringBuffer, len, value);
        return this;
      };

      /**
       * Finishes the write operation.
       * @name BufferWriter#finish
       * @function
       * @returns {Buffer} Finished buffer
       */

      BufferWriter._configure();

      /***/
    },

    /***/ 9822: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Contract = void 0;
      const Serializer_1 = __webpack_require__(7187);
      const utils_1 = __webpack_require__(8593);
      /**
       * The contract class contains the contract ID and contract entries
       * definition needed to encode/decode operations during the
       * interaction with the user and the communication with the RPC node.
       *
       * @example
       *
       * ```ts
       * const { Contract, Provider, Signer, utils } = require("koilib");
       * const rpcNodes = ["http://api.koinos.io:8080"];
       * const privateKey = "f186a5de49797bfd52dc42505c33d75a46822ed5b60046e09d7c336242e20200";
       * const provider = new Provider(rpcNodes);
       * const signer = new Signer({ privateKey, provider });
       * const koinContract = new Contract({
       *   id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
       *   abi: utils.Krc20Abi,
       *   provider,
       *   signer,
       * });
       * const koin = koinContract.functions;
       *
       * // optional: preformat input/output
       * koinContract.abi.methods.balanceOf.preformatInput = (owner) =>
       *   ({ owner });
       * koinContract.abi.methods.balanceOf.preformatOutput = (res) =>
       *   utils.formatUnits(res.value, 8);
       * koinContract.abi.methods.transfer.preformatInput = (input) => ({
       *   from: signer.getAddress(),
       *   to: input.to,
       *   value: utils.parseUnits(input.value, 8),
       * });
       *
       * async funtion main() {
       *   // Get balance
       *   const { result } = await koin.balanceOf("12fN2CQnuJM8cMnWZ1hPtM4knjLME8E4PD");
       *   console.log(result)
       *
       *   // Transfer
       *   const { transaction, transactionResponse } = await koin.transfer({
       *     to: "172AB1FgCsYrRAW5cwQ8KjadgxofvgPFd6",
       *     value: "10.0001",
       *   });
       *   console.log(`Transaction id ${transaction.id} submitted`);
       *
       *   // wait to be mined
       *   const blockId = await transactionResponse.wait();
       *   console.log(`Transaction mined. Block id: ${blockId}`);
       * }
       *
       * main();
       * ```
       */
      class Contract {
        constructor(c) {
          var _a;
          if (c.id) this.id = utils_1.decodeBase58(c.id);
          this.signer = c.signer;
          this.provider =
            c.provider ||
            ((_a = c.signer) === null || _a === void 0 ? void 0 : _a.provider);
          this.abi = c.abi;
          this.bytecode = c.bytecode;
          if (c.serializer) {
            this.serializer = c.serializer;
          } else if (c.abi && c.abi.types) {
            this.serializer = new Serializer_1.Serializer(c.abi.types);
          }
          this.options = {
            rc_limit: 1e8,
            sendTransaction: true,
            sendAbis: true,
            ...c.options,
          };
          this.functions = {};
          if (
            this.signer &&
            this.provider &&
            this.abi &&
            this.abi.methods &&
            this.serializer
          ) {
            Object.keys(this.abi.methods).forEach((name) => {
              this.functions[name] = async (argu = {}, options) => {
                if (!this.provider) throw new Error("provider not found");
                if (!this.abi || !this.abi.methods)
                  throw new Error("Methods are not defined");
                if (!this.abi.methods[name])
                  throw new Error(`Method ${name} not defined in the ABI`);
                const opts = {
                  ...this.options,
                  ...options,
                };
                const {
                  readOnly,
                  output,
                  defaultOutput,
                  preformatInput,
                  preformatOutput,
                } = this.abi.methods[name];
                let args;
                if (typeof preformatInput === "function") {
                  args = preformatInput(argu);
                } else {
                  args = argu;
                }
                const operation = await this.encodeOperation({ name, args });
                if (readOnly) {
                  if (!output) throw new Error(`No output defined for ${name}`);
                  // read contract
                  const { result: resultEncoded } =
                    await this.provider.readContract({
                      contract_id: utils_1.encodeBase58(
                        operation.call_contract.contract_id
                      ),
                      entry_point: operation.call_contract.entry_point,
                      args: utils_1.encodeBase64(operation.call_contract.args),
                    });
                  let result = defaultOutput;
                  if (resultEncoded) {
                    result = await this.serializer.deserialize(
                      resultEncoded,
                      output
                    );
                  }
                  if (typeof preformatOutput === "function") {
                    result = preformatOutput(result);
                  }
                  return { operation, result };
                }
                // return operation if send is false
                if (
                  !(opts === null || opts === void 0
                    ? void 0
                    : opts.sendTransaction)
                )
                  return { operation };
                // write contract (sign and send)
                if (!this.signer) throw new Error("signer not found");
                const transaction = await this.signer.encodeTransaction({
                  ...opts,
                  operations: [operation],
                });
                const abis = {};
                if (opts === null || opts === void 0 ? void 0 : opts.sendAbis) {
                  const contractId = utils_1.encodeBase58(this.id);
                  abis[contractId] = this.abi;
                }
                const transactionResponse = await this.signer.sendTransaction(
                  transaction,
                  abis
                );
                return { operation, transaction, transactionResponse };
              };
            });
          }
        }
        /**
         * Compute contract Id
         */
        static computeContractId(address) {
          return utils_1.decodeBase58(address);
        }
        /**
         * Get contract Id
         */
        getId() {
          if (!this.id) throw new Error("id is not defined");
          return utils_1.encodeBase58(this.id);
        }
        /**
         * Function to deploy a new smart contract.
         * The Bytecode must be defined in the constructor of the class
         * @example
         * ```ts
         * const privateKey = "f186a5de49797bfd52dc42505c33d75a46822ed5b60046e09d7c336242e20200";
         * const provider = new Provider(["http://api.koinos.io:8080"]);
         * const signer = new Signer({ privateKey, provider });
         * const bytecode = new Uint8Array([1, 2, 3, 4]);
         * const contract = new Contract({ signer, provider, bytecode });
         * const { transactionResponse } = await contract.deploy();
         * // wait to be mined
         * const blockId = await transactionResponse.wait();
         * console.log(`Contract uploaded in block id ${blockId}`);
         * ```
         */
        async deploy(options) {
          if (!this.signer) throw new Error("signer not found");
          if (!this.bytecode) throw new Error("bytecode not found");
          const opts = {
            ...this.options,
            ...options,
          };
          const operation = {
            upload_contract: {
              contract_id: Contract.computeContractId(this.signer.getAddress()),
              bytecode: this.bytecode,
            },
          };
          // return operation if send is false
          if (
            !(opts === null || opts === void 0 ? void 0 : opts.sendTransaction)
          )
            return { operation };
          const transaction = await this.signer.encodeTransaction({
            ...opts,
            operations: [operation],
          });
          const transactionResponse = await this.signer.sendTransaction(
            transaction
          );
          return { operation, transaction, transactionResponse };
        }
        /**
         * Encondes a contract operation using Koinos serialization
         * and taking the contract entries as reference to build it
         * @param op - Operation to encode
         * @returns Operation encoded
         * @example
         * ```ts
         * const opEncoded = contract.encodeOperation({
         *   name: "transfer",
         *   args: {
         *     from: "12fN2CQnuJM8cMnWZ1hPtM4knjLME8E4PD",
         *     to: "172AB1FgCsYrRAW5cwQ8KjadgxofvgPFd6",
         *     value: "1000",
         *   }
         * });
         *
         * console.log(opEncoded);
         * // {
         * //   call_contract: {
         * //     contract_id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
         * //     entry_point: 0x62efa292,
         * //     args: "MBWFsaWNlA2JvYgAAAAAAAAPo",
         * //   }
         * // }
         * ```
         */
        async encodeOperation(op) {
          if (!this.abi || !this.abi.methods || !this.abi.methods[op.name])
            throw new Error(`Operation ${op.name} unknown`);
          if (!this.serializer) throw new Error("Serializer is not defined");
          if (!this.id) throw new Error("Contract id is not defined");
          const method = this.abi.methods[op.name];
          let bufferInputs = new Uint8Array(0);
          if (method.input) {
            if (!op.args)
              throw new Error(
                `No arguments defined for type '${method.input}'`
              );
            bufferInputs = await this.serializer.serialize(
              op.args,
              method.input
            );
          }
          return {
            call_contract: {
              contract_id: this.id,
              entry_point: method.entryPoint,
              args: bufferInputs,
            },
          };
        }
        /**
         * Decodes a contract operation to be human readable
         * @example
         * ```ts
         * const opDecoded = contract.decodeOperation({
         *   call_contract: {
         *     contract_id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
         *     entry_point: 0x62efa292,
         *     args: "MBWFsaWNlA2JvYgAAAAAAAAPo",
         *   }
         * });
         * console.log(opDecoded);
         * // {
         * //   name: "transfer",
         * //   args: {
         * //     from: "12fN2CQnuJM8cMnWZ1hPtM4knjLME8E4PD",
         * //     to: "172AB1FgCsYrRAW5cwQ8KjadgxofvgPFd6",
         * //     value: "1000",
         * //   },
         * // }
         * ```
         */
        async decodeOperation(op) {
          if (!this.id) throw new Error("Contract id is not defined");
          if (!this.abi || !this.abi.methods)
            throw new Error("Methods are not defined");
          if (!this.serializer) throw new Error("Serializer is not defined");
          if (!op.call_contract)
            throw new Error("Operation is not CallContractOperation");
          if (op.call_contract.contract_id !== this.id)
            throw new Error(
              `Invalid contract id. Expected: ${utils_1.encodeBase58(
                this.id
              )}. Received: ${utils_1.encodeBase58(
                op.call_contract.contract_id
              )}`
            );
          for (let i = 0; i < Object.keys(this.abi.methods).length; i += 1) {
            const opName = Object.keys(this.abi.methods)[i];
            const method = this.abi.methods[opName];
            if (op.call_contract.entry_point === method.entryPoint) {
              if (!method.input) return { name: opName };
              return {
                name: opName,
                args: await this.serializer.deserialize(
                  op.call_contract.args,
                  method.input
                ),
              };
            }
          }
          throw new Error(`Unknown method id ${op.call_contract.entry_point}`);
        }
      }
      exports.Contract = Contract;
      exports.default = Contract;

      /***/
    },

    /***/ 5635: /***/ function (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      "use strict";

      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Provider = void 0;
      const axios_1 = __importDefault(__webpack_require__(9669));
      async function sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
      }
      /**
       * Class to connect with the RPC node
       */
      class Provider {
        /**
         *
         * @param rpcNodes - URL of the rpc node, or array of urls
         * to switch between them when someone is down
         * @example
         * ```ts
         * const provider = new Provider([
         *   "http://45.56.104.152:8080",
         *   "http://159.203.119.0:8080"
         * ]);
         * ```
         */
        constructor(rpcNodes) {
          if (Array.isArray(rpcNodes)) this.rpcNodes = rpcNodes;
          else this.rpcNodes = [rpcNodes];
          this.currentNodeId = 0;
          this.onError = () => false;
        }
        /**
         * Function to make jsonrpc requests to the RPC node
         * @param method - jsonrpc method
         * @param params - jsonrpc params
         * @returns Result of jsonrpc response
         */
        async call(method, params) {
          let response = {
            data: {},
            status: 0,
            statusText: "",
            headers: {},
            config: {},
          };
          let success = false;
          /* eslint-disable no-await-in-loop */
          while (!success) {
            try {
              const data = {
                id: Math.round(Math.random() * 1000),
                jsonrpc: "2.0",
                method,
                params,
              };
              const url = this.rpcNodes[this.currentNodeId];
              // TODO: search conditional to enable fetch for Browser
              /* const response = await fetch(url, {
                  method: "POST",
                  body: JSON.stringify(data),
                });
                const json = await response.json();
                if (json.error && json.error.message) throw new Error(json.error.message);
                return json.result; */
              response = await axios_1.default.post(url, data, {
                validateStatus: (s) => s < 400,
              });
              success = true;
            } catch (e) {
              const currentNode = this.rpcNodes[this.currentNodeId];
              this.currentNodeId =
                (this.currentNodeId + 1) % this.rpcNodes.length;
              const newNode = this.rpcNodes[this.currentNodeId];
              const abort = this.onError(e, currentNode, newNode);
              if (abort) throw e;
            }
          }
          if (response.data.error)
            throw new Error(
              JSON.stringify({
                error: response.data.error,
                request: { method, params },
              })
            );
          return response.data.result;
        }
        /**
         * Function to call "chain.get_account_nonce" to return the number of
         * transactions for a particular account. This call is used
         * when creating new transactions.
         * @param account - account address
         * @returns Nonce
         */
        async getNonce(account) {
          const { nonce } = await this.call("chain.get_account_nonce", {
            account,
          });
          if (!nonce) return 0;
          return Number(nonce);
        }
        async getAccountRc(account) {
          const { rc } = await this.call("chain.get_account_rc", {
            account,
          });
          if (!rc) return "0";
          return rc;
        }
        /**
         * Get transactions by id and their corresponding block ids
         */
        async getTransactionsById(transactionIds) {
          return this.call("transaction_store.get_transactions_by_id", {
            transaction_ids: transactionIds,
          });
        }
        async getBlocksById(blockIds) {
          return this.call("block_store.get_blocks_by_id", {
            block_id: blockIds,
            return_block: true,
            return_receipt: false,
          });
        }
        /**
         * Function to get info from the head block in the blockchain
         */
        async getHeadInfo() {
          return this.call("chain.get_head_info", {});
        }
        /**
         * Function to get consecutive blocks in descending order
         * @param height - Starting block height
         * @param numBlocks - Number of blocks to fetch
         * @param idRef - Block ID reference to speed up searching blocks.
         * This ID must be from a greater block height. By default it
         * gets the ID from the block head.
         */
        async getBlocks(height, numBlocks = 1, idRef) {
          let blockIdRef = idRef;
          if (!blockIdRef) {
            const head = await this.getHeadInfo();
            blockIdRef = head.head_topology.id;
          }
          return (
            await this.call("block_store.get_blocks_by_height", {
              head_block_id: blockIdRef,
              ancestor_start_height: height,
              num_blocks: numBlocks,
              return_block: true,
              return_receipt: false,
            })
          ).block_items;
        }
        /**
         * Function to get a block by its height
         */
        async getBlock(height) {
          return (await this.getBlocks(height, 1))[0];
        }
        /**
         * Function to call "chain.submit_transaction" to send a signed
         * transaction to the blockchain. It returns an object with the async
         * function "wait", which can be called to wait for the
         * transaction to be mined.
         * @param transaction - Signed transaction
         * @example
         * ```ts
         * const { transactionResponse } = await provider.sendTransaction({
         *   id: "1220...",
         *   active: "...",
         *   signatureData: "...",
         * });
         * console.log("Transaction submitted to the mempool");
         * // wait to be mined
         * const blockId = await transactionResponse.wait();
         * console.log("Transaction mined")
         * ```
         */
        async sendTransaction(transaction) {
          await this.call("chain.submit_transaction", { transaction });
          const startTime = Date.now() + 10000;
          return {
            wait: async (type = "byTransactionId") => {
              // sleep some seconds before it gets mined
              await sleep(startTime - Date.now() - 1000);
              if (type === "byTransactionId") {
                for (let i = 0; i < 30; i += 1) {
                  await sleep(1000);
                  const { transactions } = await this.getTransactionsById([
                    transaction.id,
                  ]);
                  if (
                    transactions &&
                    transactions[0] &&
                    transactions[0].containing_blocks
                  )
                    return transactions[0].containing_blocks[0];
                }
                throw new Error(`Transaction not mined after 40 seconds`);
              }
              // byBlock
              let blockNumber = 0;
              let iniBlock = 0;
              for (let i = 0; i < 90; i += 1) {
                await sleep(1000);
                const { head_topology: headTopology } =
                  await this.getHeadInfo();
                if (i === 0) {
                  blockNumber = Number(headTopology.height);
                  iniBlock = blockNumber;
                } else {
                  blockNumber += 1;
                }
                if (blockNumber > Number(headTopology.height)) continue;
                const [block] = await this.getBlocks(
                  blockNumber,
                  1,
                  headTopology.id
                );
                if (
                  !block ||
                  !block.block ||
                  !block.block_id ||
                  !block.block.transactions
                )
                  continue;
                const tx = block.block.transactions.find(
                  (t) => t.id === transaction.id
                );
                if (tx) return blockNumber.toString();
              }
              throw new Error(
                `Transaction not mined from block ${iniBlock} to ${blockNumber}`
              );
            },
          };
        }
        /**
         * Function to call "chain.read_contract" to read a contract.
         * This function is used by [[Contract]] class when read methods
         * are invoked.
         */
        async readContract(operation) {
          return this.call("chain.read_contract", operation);
        }
      }
      exports.Provider = Provider;
      exports.default = Provider;

      /***/
    },

    /***/ 7187: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Serializer = void 0;
      /* eslint-disable @typescript-eslint/require-await */
      const light_1 = __webpack_require__(4492);
      const utils_1 = __webpack_require__(8593);
      const OP_BYTES = "(koinos_bytes_type)";
      /**
       * Makes a copy of a value. The returned value can be modified
       * without altering the original one. Although this is not needed
       * for strings or numbers and only needed for objects and arrays,
       * all these options are covered in a single function
       *
       * It is assumed that the argument is number, string, or contructions
       * of these types inside objects or arrays.
       */
      function copyValue(value) {
        if (typeof value === "string" || typeof value === "number") {
          return value;
        }
        return JSON.parse(JSON.stringify(value));
      }
      /**
       * The serializer class serialize and deserialize data using
       * protocol buffers.
       *
       * NOTE: This class uses the [protobufjs/light](https://www.npmjs.com/package/protobufjs)
       * library internally, which uses reflection (use of _eval_
       * and _new Function_) for the construction of the types.
       * This could cause issues in environments where _eval_ is not
       * allowed, like in browser extensions. In such cases, this class
       * must be confined in a [sandbox environment](https://developer.chrome.com/docs/apps/app_external/#sandboxing)
       * where _eval_ is allowed. This is the principal reason of
       * having the serializer in a separate class.
       *
       * @example
       *
       * ```ts
       * const descriptorJson = {
       *   nested: {
       *     awesomepackage: {
       *       nested: {
       *         AwesomeMessage: {
       *           fields: {
       *             awesomeField: {
       *               type: "string",
       *               id: 1
       *             }
       *           }
       *         }
       *       }
       *     }
       *   }
       * }
       * const serializer = new Serializer(descriptorJson)
       * ```
       */
      class Serializer {
        constructor(types, opts) {
          /**
           * Preformat bytes for base64, base58 or hex string
           */
          this.bytesConversion = true;
          this.types = types;
          this.root = light_1.Root.fromJSON(this.types);
          if (opts === null || opts === void 0 ? void 0 : opts.defaultTypeName)
            this.defaultType = this.root.lookupType(opts.defaultTypeName);
          if (opts && typeof opts.bytesConversion !== "undefined")
            this.bytesConversion = opts.bytesConversion;
        }
        /**
         * Function to encode a type using the protobuffer definitions
         * It also prepares the bytes for special cases (base58, hex string)
         * when bytesConversion param is true.
         */
        async serialize(valueDecoded, typeName) {
          const protobufType =
            this.defaultType || this.root.lookupType(typeName);
          let object = {};
          if (this.bytesConversion) {
            // TODO: format from Buffer to base58/base64 for nested fields
            Object.keys(protobufType.fields).forEach((fieldName) => {
              const { options, name, type } = protobufType.fields[fieldName];
              // No byte conversion
              if (type !== "bytes") {
                object[name] = copyValue(valueDecoded[name]);
                return;
              }
              // Default byte conversion
              if (!options || !options[OP_BYTES]) {
                object[name] = utils_1.decodeBase64(valueDecoded[name]);
                return;
              }
              // Specific byte conversion
              switch (options[OP_BYTES]) {
                case "BASE58":
                case "CONTRACT_ID":
                case "ADDRESS":
                  object[name] = utils_1.decodeBase58(valueDecoded[name]);
                  break;
                case "BASE64":
                  object[name] = utils_1.decodeBase64(valueDecoded[name]);
                  break;
                case "HEX":
                case "BLOCK_ID":
                case "TRANSACTION_ID":
                  object[name] = utils_1.toUint8Array(
                    valueDecoded[name].replace("0x", "")
                  );
                  break;
                default:
                  throw new Error(
                    `unknown koinos_byte_type ${options[OP_BYTES]}`
                  );
              }
            });
          } else {
            object = valueDecoded;
          }
          const message = protobufType.create(object);
          const buffer = protobufType.encode(message).finish();
          return buffer;
        }
        /**
         * Function to decode bytes using the protobuffer definitions
         * It also encodes the bytes for special cases (base58, hex string)
         * when bytesConversion param is true.
         */
        async deserialize(valueEncoded, typeName) {
          const valueBuffer =
            typeof valueEncoded === "string"
              ? utils_1.decodeBase64(valueEncoded)
              : valueEncoded;
          const protobufType =
            this.defaultType || this.root.lookupType(typeName);
          const message = protobufType.decode(valueBuffer);
          const object = protobufType.toObject(message, { longs: String });
          if (!this.bytesConversion) return object;
          // TODO: format from Buffer to base58/base64 for nested fields
          Object.keys(protobufType.fields).forEach((fieldName) => {
            const { options, name, type } = protobufType.fields[fieldName];
            // No byte conversion
            if (type !== "bytes") return;
            // Default byte conversion
            if (!options || !options[OP_BYTES]) {
              object[name] = utils_1.encodeBase64(object[name]);
              return;
            }
            // Specific byte conversion
            switch (options[OP_BYTES]) {
              case "BASE58":
              case "CONTRACT_ID":
              case "ADDRESS":
                object[name] = utils_1.encodeBase58(object[name]);
                break;
              case "BASE64":
                object[name] = utils_1.encodeBase64(object[name]);
                break;
              case "HEX":
              case "BLOCK_ID":
              case "TRANSACTION_ID":
                object[name] = `0x${utils_1.toHexString(object[name])}`;
                break;
              default:
                throw new Error(
                  `unknown koinos_byte_type ${options[OP_BYTES]}`
                );
            }
          });
          return object;
        }
      }
      exports.Serializer = Serializer;
      exports.default = Serializer;

      /***/
    },

    /***/ 6991: /***/ function (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signer = void 0;
      /* eslint-disable no-param-reassign */
      const sha256_1 = __webpack_require__(5374);
      const secp = __importStar(__webpack_require__(1337));
      const protocol_proto_json_1 = __importDefault(__webpack_require__(6139));
      const utils_1 = __webpack_require__(8593);
      const Serializer_1 = __webpack_require__(7187);
      /**
       * The Signer Class contains the private key needed to sign transactions.
       * It can be created using the seed, wif, or private key
       *
       * @example
       * using private key as hex string
       * ```ts
       * var privateKey = "ec8601a24f81decd57f4b611b5ac6eb801cb3780bb02c0f9cdfe9d09daaddf9c";
       * var signer = new Signer({ privateKey });
       * ```
       * <br>
       *
       * using private key as Uint8Array
       * ```ts
       * var buffer = new Uint8Array([
       *   236, 134,   1, 162,  79, 129, 222, 205,
       *    87, 244, 182,  17, 181, 172, 110, 184,
       *     1, 203,  55, 128, 187,   2, 192, 249,
       *   205, 254, 157,   9, 218, 173, 223, 156
       * ]);
       * var signer = new Signer({ privateKey: buffer });
       * ```
       *
       * <br>
       *
       * using private key as bigint
       * ```ts
       * var privateKey = 106982601049961974618234078204952280507266494766432547312316920283818886029212n;
       * var signer = new Signer({ privateKey });
       * ```
       *
       * <br>
       *
       * using the seed
       * ```ts
       * var signer = Signer.fromSeed("my seed");
       * ```
       *
       * <br>
       *
       * using private key in WIF format
       * ```ts
       * var signer = Signer.fromWif("L59UtJcTdNBnrH2QSBA5beSUhRufRu3g6tScDTite6Msuj7U93tM");
       * ```
       *
       * <br>
       *
       * defining a provider
       * ```ts
       * var provider = new Provider(["https://example.com/jsonrpc"]);
       * var privateKey = "ec8601a24f81decd57f4b611b5ac6eb801cb3780bb02c0f9cdfe9d09daaddf9c";
       * var signer = new Signer({ privateKey, provider });
       * ```
       */
      class Signer {
        /**
         * The constructor receives de private key as hexstring, bigint or Uint8Array.
         * See also the functions [[Signer.fromWif]] and [[Signer.fromSeed]]
         * to create the signer from the WIF or Seed respectively.
         *
         * @param privateKey - Private key as hexstring, bigint or Uint8Array
         * @param compressed - compressed format is true by default
         * @param provider - provider to connect with the blockchain
         * @example
         * ```ts
         * const privateKey = "ec8601a24f81decd57f4b611b5ac6eb801cb3780bb02c0f9cdfe9d09daaddf9c";
         * cons signer = new Signer({ privateKey });
         * console.log(signer.getAddress());
         * // 1MbL6mG8ASAvSYdoMnGUfG3ZXkmQ2dpL5b
         * ```
         */
        constructor(c) {
          this.compressed =
            typeof c.compressed === "undefined" ? true : c.compressed;
          this.privateKey = c.privateKey;
          this.provider = c.provider;
          if (c.serializer) {
            this.serializer = c.serializer;
          } else {
            this.serializer = new Serializer_1.Serializer(
              protocol_proto_json_1.default,
              {
                defaultTypeName: "active_transaction_data",
                bytesConversion: false,
              }
            );
          }
          if (typeof c.privateKey === "string") {
            this.publicKey = secp.getPublicKey(c.privateKey, this.compressed);
            this.address = utils_1.bitcoinAddress(
              utils_1.toUint8Array(this.publicKey)
            );
          } else {
            this.publicKey = secp.getPublicKey(c.privateKey, this.compressed);
            this.address = utils_1.bitcoinAddress(this.publicKey);
          }
        }
        /**
         * Function to import a private key from the WIF
         * @param wif  - Private key in WIF format
         * @example
         * ```ts
         * const signer = Signer.fromWif("L59UtJcTdNBnrH2QSBA5beSUhRufRu3g6tScDTite6Msuj7U93tM")
         * console.log(signer.getAddress());
         * // 1MbL6mG8ASAvSYdoMnGUfG3ZXkmQ2dpL5b
         * ```
         * @returns Signer object
         */
        static fromWif(wif) {
          const compressed = wif[0] !== "5";
          const privateKey = utils_1.bitcoinDecode(wif);
          return new Signer({
            privateKey: utils_1.toHexString(privateKey),
            compressed,
          });
        }
        /**
         * Function to import a private key from the seed
         * @param seed - Seed words
         * @param compressed -
         * @example
         * ```ts
         * const signer = Signer.fromSeed("my seed");
         * console.log(signer.getAddress());
         * // 1BqtgWBcqm9cSZ97avLGZGJdgso7wx6pCA
         * ```
         * @returns Signer object
         */
        static fromSeed(seed, compressed) {
          const privateKey = sha256_1.sha256(seed);
          return new Signer({ privateKey, compressed });
        }
        /**
         * @param compressed - determines if the address should be
         * derived from the compressed public key (default) or the public key
         * @returns Signer address
         */
        getAddress(compressed = true) {
          if (typeof this.privateKey === "string") {
            const publicKey = secp.getPublicKey(this.privateKey, compressed);
            return utils_1.bitcoinAddress(utils_1.toUint8Array(publicKey));
          }
          const publicKey = secp.getPublicKey(this.privateKey, compressed);
          return utils_1.bitcoinAddress(publicKey);
        }
        /**
         * Function to get the private key in hex format or wif format
         * @param format - The format must be "hex" (default) or "wif"
         * @param compressed - Optional arg when using WIF format. By default it
         * uses the compressed value defined in the signer
         * @example
         * ```ts
         * const signer = Signer.fromSeed("one two three four five six");
         * console.log(signer.getPrivateKey());
         * // bab7fd6e5bd624f4ea0c33f7e7219262a6fa93a945a8964d9f110148286b7b37
         *
         * console.log(signer.getPrivateKey("wif"));
         * // L3UfgFJWmbVziGB1uZBjkG1UjKkF7hhpXWY7mbTUdmycmvXCVtiL
         *
         * console.log(signer.getPrivateKey("wif", false));
         * // 5KEX4TMHG66fT7cM9HMZLmdp4hVq4LC4X2Fkg6zeypM5UteWmtd
         * ```
         */
        getPrivateKey(format = "hex", compressed) {
          let stringPrivateKey;
          if (this.privateKey instanceof Uint8Array) {
            stringPrivateKey = utils_1.toHexString(this.privateKey);
          } else if (typeof this.privateKey === "string") {
            stringPrivateKey = this.privateKey;
          } else {
            stringPrivateKey = BigInt(this.privateKey)
              .toString(16)
              .padStart(64, "0");
          }
          const comp = compressed === undefined ? this.compressed : compressed;
          switch (format) {
            case "hex":
              return stringPrivateKey;
            case "wif":
              return utils_1.bitcoinEncode(
                utils_1.toUint8Array(stringPrivateKey),
                "private",
                comp
              );
            default:
              /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */
              throw new Error(`Invalid format ${format}`);
          }
        }
        /**
         * Function to sign a transaction. It's important to remark that
         * the transaction parameter is modified inside this function.
         * @param tx - Unsigned transaction
         * @returns
         */
        async signTransaction(tx) {
          if (!tx.active) throw new Error("Active data is not defined");
          const hash = sha256_1.sha256(utils_1.decodeBase64(tx.active));
          const [compSignature, recovery] = await secp.sign(
            hash,
            this.privateKey,
            {
              recovered: true,
              canonical: true,
              der: false, // compact signature
            }
          );
          const compactSignature = new Uint8Array(65);
          compactSignature.set([recovery + 31], 0);
          compactSignature.set(compSignature, 1);
          tx.signature_data = utils_1.encodeBase64(compactSignature);
          const multihash = `0x1220${utils_1.toHexString(hash)}`; // 12: code sha2-256. 20: length (32 bytes)
          tx.id = multihash;
          return tx;
        }
        /**
         * Function to sign and send a transaction. It internally uses
         * [[Provider.sendTransaction]]
         * @param tx - Transaction to send. It will be signed inside this function
         * if it is not signed yet
         * @param _abis - Collection of Abis to parse the operations in the
         * transaction. This parameter is optional.
         * @returns
         */
        async sendTransaction(tx, _abis) {
          if (!tx.signature_data || !tx.id) await this.signTransaction(tx);
          if (!this.provider) throw new Error("provider is undefined");
          return this.provider.sendTransaction(tx);
        }
        /**
         * Function to recover the public key from a signed
         * transaction or block.
         * The output format can be compressed (default) or uncompressed.
         *
         * @example
         * ```ts
         * const publicKey = await Signer.recoverPublicKey(tx);
         * ```
         *
         * If the signature data contains more data, like in the
         * blocks for PoW consensus, use the "transformSignature"
         * function to extract the signature.
         *
         * @example
         * ```ts
         *  const powDescriptorJson = {
         *    nested: {
         *      mypackage: {
         *        nested: {
         *          pow_signature_data: {
         *            fields: {
         *              nonce: {
         *                type: "bytes",
         *                id: 1,
         *              },
         *              recoverable_signature: {
         *                type: "bytes",
         *                id: 2,
         *              },
         *            },
         *          },
         *        },
         *      },
         *    },
         *  };
         *
         *  const serializer = new Serializer(powDescriptorJson, {
         *   defaultTypeName: "pow_signature_data",
         *  });
         *
         *  const signer = await Signer.recoverPublicKey(block, {
         *    transformSignature: async (signatureData) => {
         *      const powSignatureData = await serializer.deserialize(signatureData);
         *      return powSignatureData.recoverable_signature;
         *    },
         *  });
         * ```
         */
        static async recoverPublicKey(txOrBlock, opts) {
          if (!txOrBlock.active) throw new Error("active is not defined");
          if (!txOrBlock.signature_data)
            throw new Error("signature_data is not defined");
          let signatureData = txOrBlock.signature_data;
          if (opts && typeof opts.transformSignature === "function") {
            signatureData = await opts.transformSignature(
              txOrBlock.signature_data
            );
          }
          let compressed = true;
          if (opts && typeof opts.compressed !== "undefined") {
            compressed = opts.compressed;
          }
          const hash = sha256_1.sha256(utils_1.decodeBase64(txOrBlock.active));
          const compactSignatureHex = utils_1.toHexString(
            utils_1.decodeBase64(signatureData)
          );
          const recovery = Number(`0x${compactSignatureHex.slice(0, 2)}`) - 31;
          const rHex = compactSignatureHex.slice(2, 66);
          const sHex = compactSignatureHex.slice(66);
          const r = BigInt(`0x${rHex}`);
          const s = BigInt(`0x${sHex}`);
          const sig = new secp.Signature(r, s);
          const publicKey = secp.recoverPublicKey(
            utils_1.toHexString(hash),
            sig.toHex(),
            recovery
          );
          if (!publicKey) throw new Error("Public key cannot be recovered");
          if (!compressed) return publicKey;
          return secp.Point.fromHex(publicKey).toHex(true);
        }
        /**
         * Function to recover the signer address from a signed
         * transaction or block.
         * The output format can be compressed (default) or uncompressed.
         * @example
         * ```ts
         * const publicKey = await Signer.recoverAddress(tx);
         * ```
         *
         * If the signature data contains more data, like in the
         * blocks for PoW consensus, use the "transformSignature"
         * function to extract the signature.
         *
         * @example
         * ```ts
         *  const powDescriptorJson = {
         *    nested: {
         *      mypackage: {
         *        nested: {
         *          pow_signature_data: {
         *            fields: {
         *              nonce: {
         *                type: "bytes",
         *                id: 1,
         *              },
         *              recoverable_signature: {
         *                type: "bytes",
         *                id: 2,
         *              },
         *            },
         *          },
         *        },
         *      },
         *    },
         *  };
         *
         *  const serializer = new Serializer(powDescriptorJson, {
         *   defaultTypeName: "pow_signature_data",
         *  });
         *
         *  const signer = await Signer.recoverAddress(block, {
         *    transformSignature: async (signatureData) => {
         *      const powSignatureData = await serializer.deserialize(signatureData);
         *      return powSignatureData.recoverable_signature;
         *    },
         *  });
         * ```
         */
        static async recoverAddress(txOrBlock, opts) {
          const publicKey = await Signer.recoverPublicKey(txOrBlock, opts);
          return utils_1.bitcoinAddress(utils_1.toUint8Array(publicKey));
        }
        /**
         * Function to encode a transaction
         * @param activeData - Active data consists of nonce, rc_limit, and
         * operations. Do not set the nonce to get it from the blockchain
         * using the provider. The rc_limit is 1000000 by default.
         * @returns A transaction encoded. The active field is encoded in
         * base64url
         */
        async encodeTransaction(activeData) {
          let { nonce } = activeData;
          if (activeData.nonce === undefined) {
            if (!this.provider)
              throw new Error(
                "Cannot get the nonce because provider is undefined. To skip this call set a nonce in the parameters"
              );
            // TODO: Option to resolve names
            // this depends on the final architecture for names on Koinos
            nonce = await this.provider.getNonce(this.getAddress());
          }
          const rcLimit =
            activeData.rc_limit === undefined ? 1000000 : activeData.rc_limit;
          const operations = activeData.operations ? activeData.operations : [];
          const activeData2 = {
            rc_limit: rcLimit,
            nonce,
            operations,
          };
          const buffer = await this.serializer.serialize(activeData2);
          return {
            active: utils_1.encodeBase64(buffer),
          };
        }
        /**
         * Function to decode a transaction
         */
        async decodeTransaction(tx) {
          if (!tx.active) throw new Error("Active data is not defined");
          return this.serializer.deserialize(tx.active);
        }
      }
      exports.Signer = Signer;
      exports.default = Signer;

      /***/
    },

    /***/ 5738: /***/ function (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      "use strict";

      /*! koilib - MIT License (c) Julian Gonzalez (joticajulian@gmail.com) */
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      const utils = __importStar(__webpack_require__(8593));
      const Contract_1 = __webpack_require__(9822);
      const Signer_1 = __webpack_require__(6991);
      const Provider_1 = __webpack_require__(5635);
      const Serializer_1 = __webpack_require__(7187);
      window.utils = utils;
      window.Contract = Contract_1.Contract;
      window.Signer = Signer_1.Signer;
      window.Provider = Provider_1.Provider;
      window.Serializer = Serializer_1.Serializer;

      /***/
    },

    /***/ 8593: /***/ function (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtocolTypes =
        exports.Krc20Abi =
        exports.parseUnits =
        exports.formatUnits =
        exports.bitcoinAddress =
        exports.bitcoinDecode =
        exports.bitcoinEncode =
        exports.decodeBase64 =
        exports.encodeBase64 =
        exports.decodeBase58 =
        exports.encodeBase58 =
        exports.toHexString =
        exports.toUint8Array =
          void 0;
      const multibase = __importStar(__webpack_require__(6957));
      const sha256_1 = __webpack_require__(5374);
      const ripemd160_1 = __webpack_require__(7050);
      const krc20_proto_json_1 = __importDefault(__webpack_require__(7177));
      const protocol_proto_json_1 = __importDefault(__webpack_require__(6139));
      /**
       * Converts an hex string to Uint8Array
       */
      function toUint8Array(hex) {
        const pairs = hex.match(/[\dA-F]{2}/gi);
        if (!pairs) throw new Error("Invalid hex");
        return new Uint8Array(
          pairs.map((s) => parseInt(s, 16)) // convert to integers
        );
      }
      exports.toUint8Array = toUint8Array;
      /**
       * Converts Uint8Array to hex string
       */
      function toHexString(buffer) {
        return Array.from(buffer)
          .map((n) => `0${Number(n).toString(16)}`.slice(-2))
          .join("");
      }
      exports.toHexString = toHexString;
      /**
       * Encodes an Uint8Array in base58
       */
      function encodeBase58(buffer) {
        return new TextDecoder().decode(multibase.encode("z", buffer)).slice(1);
      }
      exports.encodeBase58 = encodeBase58;
      /**
       * Decodes a buffer formatted in base58
       */
      function decodeBase58(bs58) {
        return multibase.decode(`z${bs58}`);
      }
      exports.decodeBase58 = decodeBase58;
      /**
       * Encodes an Uint8Array in base64
       */
      function encodeBase64(buffer) {
        return new TextDecoder().decode(multibase.encode("U", buffer)).slice(1);
      }
      exports.encodeBase64 = encodeBase64;
      /**
       * Decodes a buffer formatted in base64
       */
      function decodeBase64(bs64) {
        return multibase.decode(`U${bs64}`);
      }
      exports.decodeBase64 = decodeBase64;
      /**
       * Encodes a public or private key in base58 using
       * the bitcoin format (see [Bitcoin Base58Check encoding](https://en.bitcoin.it/wiki/Base58Check_encoding)
       * and [Bitcoin WIF](https://en.bitcoin.it/wiki/Wallet_import_format)).
       *
       * For private keys this encode is also known as
       * wallet import format (WIF).
       */
      function bitcoinEncode(buffer, type, compressed = false) {
        let bufferCheck;
        let prefixBuffer;
        let offsetChecksum;
        if (type === "public") {
          bufferCheck = new Uint8Array(25);
          prefixBuffer = new Uint8Array(21);
          bufferCheck[0] = 0;
          prefixBuffer[0] = 0;
          offsetChecksum = 21;
        } else {
          if (compressed) {
            bufferCheck = new Uint8Array(38);
            prefixBuffer = new Uint8Array(34);
            offsetChecksum = 34;
            bufferCheck[33] = 1;
            prefixBuffer[33] = 1;
          } else {
            bufferCheck = new Uint8Array(37);
            prefixBuffer = new Uint8Array(33);
            offsetChecksum = 33;
          }
          bufferCheck[0] = 128;
          prefixBuffer[0] = 128;
        }
        prefixBuffer.set(buffer, 1);
        const firstHash = sha256_1.sha256(prefixBuffer);
        const doubleHash = sha256_1.sha256(firstHash);
        const checksum = new Uint8Array(4);
        checksum.set(doubleHash.slice(0, 4));
        bufferCheck.set(buffer, 1);
        bufferCheck.set(checksum, offsetChecksum);
        return encodeBase58(bufferCheck);
      }
      exports.bitcoinEncode = bitcoinEncode;
      /**
       * Decodes a public or private key formatted in base58 using
       * the bitcoin format (see [Bitcoin Base58Check encoding](https://en.bitcoin.it/wiki/Base58Check_encoding)
       * and [Bitcoin WIF](https://en.bitcoin.it/wiki/Wallet_import_format)).
       *
       * For private keys this encode is also known as
       * wallet import format (WIF).
       */
      function bitcoinDecode(value) {
        const buffer = decodeBase58(value);
        const privateKey = new Uint8Array(32);
        const checksum = new Uint8Array(4);
        // const prefix = buffer[0];
        privateKey.set(buffer.slice(1, 33));
        if (value[0] !== "5") {
          // compressed
          checksum.set(buffer.slice(34, 38));
        } else {
          checksum.set(buffer.slice(33, 37));
        }
        // TODO: verify prefix and checksum
        return privateKey;
      }
      exports.bitcoinDecode = bitcoinDecode;
      /**
       * Computes a bitcoin address, which is the format used in Koinos
       *
       * address = bitcoinEncode( ripemd160 ( sha256 ( publicKey ) ) )
       */
      function bitcoinAddress(publicKey) {
        const hash = sha256_1.sha256(publicKey);
        const hash160 = ripemd160_1.ripemd160(hash);
        return bitcoinEncode(hash160, "public");
      }
      exports.bitcoinAddress = bitcoinAddress;
      /**
       * Function to format a number in a decimal point number
       * @example
       * ```js
       * const amount = formatUnits("123456", 8);
       * console.log(amount);
       * // '0.00123456'
       * ```
       */
      function formatUnits(value, decimals) {
        let v = typeof value === "string" ? value : BigInt(value).toString();
        const sign = v[0] === "-" ? "-" : "";
        v = v.replace("-", "").padStart(decimals + 1, "0");
        const integerPart = v
          .substring(0, v.length - decimals)
          .replace(/^0+(?=\d)/, "");
        const decimalPart = v.substring(v.length - decimals);
        return `${sign}${integerPart}.${decimalPart}`.replace(
          /(\.0+)?(0+)$/,
          ""
        );
      }
      exports.formatUnits = formatUnits;
      /**
       * Function to format a decimal point number in an integer
       * @example
       * ```js
       * const amount = parseUnits("0.00123456", 8);
       * console.log(amount);
       * // '123456'
       * ```
       */
      function parseUnits(value, decimals) {
        const sign = value[0] === "-" ? "-" : "";
        // eslint-disable-next-line prefer-const
        let [integerPart, decimalPart] = value
          .replace("-", "")
          .replace(",", ".")
          .split(".");
        if (!decimalPart) decimalPart = "";
        decimalPart = decimalPart.padEnd(decimals, "0");
        return `${sign}${`${integerPart}${decimalPart}`.replace(
          /^0+(?=\d)/,
          ""
        )}`;
      }
      exports.parseUnits = parseUnits;
      /**
       * ABI for tokens
       */
      exports.Krc20Abi = {
        methods: {
          name: {
            entryPoint: 0x76ea4297,
            input: "name_arguments",
            output: "name_result",
            readOnly: true,
          },
          symbol: {
            entryPoint: 0x7e794b24,
            input: "symbol_arguments",
            output: "symbol_result",
            readOnly: true,
          },
          decimals: {
            entryPoint: 0x59dc15ce,
            input: "decimals_arguments",
            output: "decimals_result",
            readOnly: true,
          },
          totalSupply: {
            entryPoint: 0xcf2e8212,
            input: "total_supply_arguments",
            output: "total_supply_result",
            readOnly: true,
          },
          balanceOf: {
            entryPoint: 0x15619248,
            input: "balance_of_arguments",
            output: "balance_of_result",
            readOnly: true,
            defaultOutput: { value: "0" },
          },
          transfer: {
            entryPoint: 0x62efa292,
            input: "transfer_arguments",
            output: "transfer_result",
          },
          mint: {
            entryPoint: 0xc2f82bdc,
            input: "mint_argumnets",
            output: "mint_result",
          },
        },
        types: krc20_proto_json_1.default,
      };
      exports.ProtocolTypes = protocol_proto_json_1.default;

      /***/
    },

    /***/ 5102: /***/ () => {
      /* (ignored) */
      /***/
    },

    /***/ 7177: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"nested":{"koinos":{"nested":{"contracts":{"nested":{"token":{"options":{"go_package":"github.com/koinos/koinos-proto-golang/koinos/contracts/token"},"nested":{"name_arguments":{"fields":{}},"name_result":{"fields":{"value":{"type":"string","id":1}}},"symbol_arguments":{"fields":{}},"symbol_result":{"fields":{"value":{"type":"string","id":1}}},"decimals_arguments":{"fields":{}},"decimals_result":{"fields":{"value":{"type":"uint32","id":1}}},"total_supply_arguments":{"fields":{}},"total_supply_result":{"fields":{"value":{"type":"uint64","id":1,"options":{"jstype":"JS_STRING"}}}},"balance_of_arguments":{"fields":{"owner":{"type":"bytes","id":1,"options":{"(koinos_bytes_type)":"ADDRESS"}}}},"balance_of_result":{"fields":{"value":{"type":"uint64","id":1,"options":{"jstype":"JS_STRING"}}}},"transfer_arguments":{"fields":{"from":{"type":"bytes","id":1,"options":{"(koinos_bytes_type)":"ADDRESS"}},"to":{"type":"bytes","id":2,"options":{"(koinos_bytes_type)":"ADDRESS"}},"value":{"type":"uint64","id":3,"options":{"jstype":"JS_STRING"}}}},"transfer_result":{"fields":{"value":{"type":"bool","id":1}}},"mint_arguments":{"fields":{"to":{"type":"bytes","id":1,"options":{"(koinos_bytes_type)":"ADDRESS"}},"value":{"type":"uint64","id":2,"options":{"jstype":"JS_STRING"}}}},"mint_result":{"fields":{"value":{"type":"bool","id":1}}},"balance_object":{"fields":{"value":{"type":"uint64","id":1,"options":{"jstype":"JS_STRING"}}}},"mana_balance_object":{"fields":{"balance":{"type":"uint64","id":1,"options":{"jstype":"JS_STRING"}},"mana":{"type":"uint64","id":2,"options":{"jstype":"JS_STRING"}},"last_mana_update":{"type":"uint64","id":3,"options":{"jstype":"JS_STRING"}}}}}}}}}}}}'
      );

      /***/
    },

    /***/ 6139: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"nested":{"koinos":{"nested":{"protocol":{"options":{"go_package":"github.com/koinos/koinos-proto-golang/koinos/protocol"},"nested":{"contract_call_bundle":{"fields":{"contract_id":{"type":"bytes","id":1,"options":{"(koinos_bytes_type)":"CONTRACT_ID"}},"entry_point":{"type":"uint32","id":2}}},"system_call_target":{"oneofs":{"target":{"oneof":["thunk_id","system_call_bundle"]}},"fields":{"thunk_id":{"type":"uint32","id":1},"system_call_bundle":{"type":"contract_call_bundle","id":2}}},"upload_contract_operation":{"fields":{"contract_id":{"type":"bytes","id":1,"options":{"(koinos_bytes_type)":"CONTRACT_ID"}},"bytecode":{"type":"bytes","id":2}}},"call_contract_operation":{"fields":{"contract_id":{"type":"bytes","id":1,"options":{"(koinos_bytes_type)":"CONTRACT_ID"}},"entry_point":{"type":"uint32","id":2},"args":{"type":"bytes","id":3}}},"set_system_call_operation":{"fields":{"call_id":{"type":"uint32","id":1},"target":{"type":"system_call_target","id":2}}},"operation":{"oneofs":{"op":{"oneof":["upload_contract","call_contract","set_system_call"]}},"fields":{"upload_contract":{"type":"upload_contract_operation","id":1},"call_contract":{"type":"call_contract_operation","id":2},"set_system_call":{"type":"set_system_call_operation","id":3}}},"active_transaction_data":{"fields":{"rc_limit":{"type":"uint64","id":1,"options":{"jstype":"JS_STRING"}},"nonce":{"type":"uint64","id":2,"options":{"jstype":"JS_STRING"}},"operations":{"rule":"repeated","type":"operation","id":3}}},"passive_transaction_data":{"fields":{}},"transaction":{"fields":{"id":{"type":"bytes","id":1,"options":{"(koinos_bytes_type)":"TRANSACTION_ID"}},"active":{"type":"bytes","id":2},"passive":{"type":"bytes","id":3},"signature_data":{"type":"bytes","id":4}}},"active_block_data":{"fields":{"transaction_merkle_root":{"type":"bytes","id":1},"passive_data_merkle_root":{"type":"bytes","id":2},"signer":{"type":"bytes","id":3}}},"passive_block_data":{"fields":{}},"block_header":{"fields":{"previous":{"type":"bytes","id":1,"options":{"(koinos_bytes_type)":"BLOCK_ID"}},"height":{"type":"uint64","id":2,"options":{"jstype":"JS_STRING"}},"timestamp":{"type":"uint64","id":3,"options":{"jstype":"JS_STRING"}}}},"block":{"fields":{"id":{"type":"bytes","id":1,"options":{"(koinos_bytes_type)":"BLOCK_ID"}},"header":{"type":"block_header","id":2},"active":{"type":"bytes","id":3},"passive":{"type":"bytes","id":4},"signature_data":{"type":"bytes","id":5},"transactions":{"rule":"repeated","type":"transaction","id":6}}},"block_receipt":{"fields":{}}}}}}}}'
      );

      /***/
    },

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ id: moduleId,
      /******/ loaded: false,
      /******/ exports: {},
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    );
    /******/
    /******/ // Flag the module as loaded
    /******/ module.loaded = true;
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/global */
  /******/ (() => {
    /******/ __webpack_require__.g = (function () {
      /******/ if (typeof globalThis === "object") return globalThis;
      /******/ try {
        /******/ return this || new Function("return this")();
        /******/
      } catch (e) {
        /******/ if (typeof window === "object") return window;
        /******/
      }
      /******/
    })();
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/node module decorator */
  /******/ (() => {
    /******/ __webpack_require__.nmd = (module) => {
      /******/ module.paths = [];
      /******/ if (!module.children) module.children = [];
      /******/ return module;
      /******/
    };
    /******/
  })();
  /******/
  /************************************************************************/
  /******/
  /******/ // startup
  /******/ // Load entry module and return exports
  /******/ // This entry module is referenced by other modules so it can't be inlined
  /******/ var __webpack_exports__ = __webpack_require__(5738);
  /******/
  /******/
})();
